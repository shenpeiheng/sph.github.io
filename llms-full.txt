---
url: /guide/static-deploy.md
---
# 部署静态站点 {#deploying-a-static-site}

本指南建立在以下几个假设基础之上：

* 你正在使用的是默认的构建输出路径（`dist`）。这个路径 [可以通过 `build.outDir` 更改](/config/build-options.md#build-outdir)，在这种情况下，你可以从这篇指南中找到所需的指引。
* 你正在使用 NPM；或者 Yarn 等其他可以运行下面的脚本指令的包管理工具。
* Vite 已作为一个本地开发依赖（dev dependency）安装在你的项目中，并且你已经配置好了如下的 npm scripts：

```json [package.json]
{
  "scripts": {
    "build": "vite build",
    "preview": "vite preview"
  }
}
```

值得注意的是 `vite preview` 用作预览本地构建，而不应直接作为生产服务器。

::: tip 注意
本篇指南提供了部署 Vite 静态站点的说明。Vite 也对服务端渲染（SSR）有了实验性的支持。SSR 是指支持在 Node 中运行相应应用的前端框架，预渲染成 HTML，最后在客户端激活（hydrate）。查看 [SSR 指南](./ssr) 了解更多细节。另一方面，如果你在寻找与传统服务端框架集成的方式，那么请查看 [后端集成](./backend-integration) 章节。
:::

## 构建应用 {#building-the-app}

你可以运行 `npm run build` 命令来执行应用的构建。

```bash
$ npm run build
```

默认情况下，构建会输出到 `dist` 文件夹中。你可以部署这个 `dist` 文件夹到任何你喜欢的平台。

### 本地测试应用 {#testing-the-app-locally}

当你构建完成应用后，你可以通过运行 `npm run preview` 命令，在本地测试该应用。

```bash
$ npm run preview
```

`vite preview` 命令会在本地启动一个静态 Web 服务器，将 `dist` 文件夹运行在 `http://localhost:4173`。这样在本地环境下查看该构建产物是否正常可用就方便多了。

你可以通过 `--port` 参数来配置服务的运行端口。

```json [package.json]
{
  "scripts": {
    "preview": "vite preview --port 8080"
  }
}
```

现在 `preview` 命令会将服务器运行在 `http://localhost:8080`。

## GitHub Pages {#github-pages}

1. 在 `vite.config.js` 中设置正确的 `base`。

   如果你正要部署到 `https://<USERNAME>.github.io/`，或者通过 GitHub Pages 部署到一个自定义域名（例如 `www.example.com`），请将 `base` 设置为 `'/'`。或者，你也可以从配置中移除 `base`，因为它默认为 `'/'`。

   如果你正在部署到 `https://<USERNAME>.github.io/<REPO>/`（例如你的仓库地址为 `https://github.com/<USERNAME>/<REPO>`），那么请将 `base` 设置为 `'/<REPO>/'`。

2. 进入仓库 settings 页面的 GitHub Pages 配置，选择部署来源为“GitHub Actions”，这将引导你创建一个构建和部署项目的工作流程，我们提供了一个安装依赖项和使用 npm 构建的工作流程样本：

   <<< ./static-deploy-github-pages.yaml#content

## GitLab Pages 配合 GitLab CI {#gitlab-pages-and-gitlab-ci}

1. 在 `vite.config.js` 中设置正确的 `base`。

   如果你要部署在 `https://<USERNAME or GROUP>.gitlab.io/` 上，你可以省略 `base` 使其默认为 `'/'`。

   如果你要部署在 `https://<USERNAME or GROUP>.gitlab.io/<REPO>/` 上，例如你的仓库地址为 `https://gitlab.com/<USERNAME>/<REPO>`，那么请设置 `base` 为 `'/<REPO>/'`。

2. 在项目根目录创建一个 `.gitlab-ci.yml` 文件，并包含以下内容。它将使得每次你更改内容时都重新构建与部署站点：

   ```yaml [.gitlab-ci.yml]
   image: node:lts
   pages:
     stage: deploy
     cache:
       key:
         files:
           - package-lock.json
         prefix: npm
       paths:
         - node_modules/
     script:
       - npm install
       - npm run build
       - cp -a dist/. public/
     artifacts:
       paths:
         - public
     rules:
       - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
   ```

## Netlify {#netlify}

### Netlify CLI {#netlify-cli}

1. 安装 [Netlify CLI](https://cli.netlify.com/)。
2. 使用 `ntl init` 创建一个新站点。
3. 使用 `ntl deploy` 来部署。

```bash
# 安装 Netlify CLI
$ npm install -g netlify-cli

# 在 Netlify 中创建一个新站点
$ ntl init

# 部署一个独一无二的预览 URL
$ ntl deploy
```

Netlify CLI 会给你分享一个预览的 URL 来检查部署结果。当你准备好了发布生产版本时，请使用 `prod` 标志：

```bash
# 部署站点到生产环境
$ ntl deploy --prod
```

### Netlify with Git {#netlify-with-git}

1. 将你的代码推送到 git 仓库（GitHub、GitLab、BitBucket 或是 Azure DevOps 等服务）
2. 在 Netlify 中 [导入该项目](https://app.netlify.com/start)
3. 选择分支，输出目录，如果需要还可以设置环境变量。
4. 点击 **部署**
5. 你的 Vite 应用就部署完成了！

在你的项目被导入和部署后，所有对生产分支以外的其他分支（可能来自合并请求）的后续推送都会生成 [预览部署](https://docs.netlify.com/site-deploys/deploy-previews/)，所有对生产分支（通常是 "main"）的更改都会生成一个 [生产部署](https://docs.netlify.com/site-deploys/overview/#definitions)。

## Vercel {#vercel}

### Vercel CLI {#vercel-cli}

1. 安装 [Vercel CLI](https://vercel.com/cli) 并运行 `vercel` 来部署。
2. Vercel 会检测到你正在使用 Vite，并会为你开启相应的正确配置。
3. 你的应用被部署好了！（示例：[vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/)）

```bash
$ npm i -g vercel
$ vercel init vite
Vercel CLI
> Success! Initialized "vite" example in ~/your-folder.
- To deploy, `cd vite` and run `vercel`.
```

### Vercel for Git {#vercel-for-git}

1. 将你的代码推送到远程仓库（GitHub，GitLab，Bitbucket）
2. [导入你的 Vite 仓库](https://vercel.com/new) 到 Vercel
3. Vercel 会检测到你正在使用 Vite，并会为你的部署开启相应的正确配置。
4. 你的应用被部署好了！（示例：[vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/)）

在你的项目被导入和部署后，所有对分支的后续推送都会生成 [预览部署](https://vercel.com/docs/concepts/deployments/environments#preview)，而所有对生产分支（通常是"main"）的更改都会生成一个 [生产构建](https://vercel.com/docs/concepts/deployments/environments#production)

查看 Vercel 的 [Git 集成](https://vercel.com/docs/concepts/git) 了解更多细节。

## Cloudflare Pages {#cloudflare-pages}

### Cloudflare Pages via Wrangler {#cloudflare-pages-via-wrangler}

1. 安装 [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).
2. 使用 `wrangler login`、通过你的 Cloudflare 账号完成 Wrangler 身份校验。
3. 运行你的构建命令
4. 使用 `npx wrangler pages deploy dist` 部署。

```bash
# 安装 Wrangler CLI
$ npm install -g wrangler

# 使用 CLI 工具登录 Cloudflare 账号
$ wrangler login

# 运行构建命令
$ npm run build

# 创建一个新的部署
$ npx wrangler pages deploy dist
```

在你的资产上传后，Wrangler 会给你一个预览 URL 来检查你的网站。当你登录到 Cloudflare Pages 仪表板时，你会看到你的新项目。

### Cloudflare Pages with Git {#cloudflare-pages-with-git}

1. 将你的代码推送到你的 Git 仓库（GitHub, GitLab）
2. 登录 Cloudflare 控制台，在 **Account Home** > **Pages** 下选择你的账号
3. 选择 **Create a new Project** 以及 **Connect Git** 选项
4. 选择你想要部署的 Git 项目，然后点击 **Begin setup**
5. 根据你所选择的 Vite 框架，在构建设置中选择相应的框架预设
6. 记得保存！然后部署吧！
7. 然后你的应用就部署完成了！（例如： `https://<PROJECTNAME>.pages.dev/`）

在你的项目被导入和部署后，所有对该分支的后续推送都会生成一个 [预览部署](https://developers.cloudflare.com/pages/platform/preview-deployments/)，除非你特意在 [控制分支构建](https://developers.cloudflare.com/pages/platform/branch-build-controls/) 的选项中写明不触发。所有对 **生产分支**（通常是 "main"）的更改都会生成一个 **生产构建**。

你也可以添加自定义域名，并自定义各个页面的构建设置。查看 [Cloudflare 页面与 Git 集成](https://developers.cloudflare.com/pages/get-started/#manage-your-site) 了解更多详情。

## Google Firebase {#google-firebase}

1. 确保已经安装 [firebase-tools](https://www.npmjs.com/package/firebase-tools)。

2. 在项目根目录创建 `firebase.json` 和 `.firebaserc` 两个文件，包含以下内容：

   ```json [firebase.json]
   {
     "hosting": {
       "public": "dist",
       "ignore": [],
       "rewrites": [
         {
           "source": "**",
           "destination": "/index.html"
         }
       ]
     }
   }
   ```

   ```js [.firebaserc]
   {
     "projects": {
       "default": "<YOUR_FIREBASE_ID>"
     }
   }
   ```

3. 运行 `npm run build` 后，通过 `firebase deploy` 命令部署。

## Surge {#surge}

1. 首先确保已经安装 [surge](https://www.npmjs.com/package/surge)。

2. 运行 `npm run build`。

3. 运行 `surge dist` 命令部署到 surge。

你也可以通过添加 `surge dist yourdomain.com` 部署到一个 [自定义域名](http://surge.sh/help/adding-a-custom-domain)。

## Azure 的静态网站应用 {#azure-static-web-apps}

你可以通过微软 Azure 的 [静态网站应用](https://aka.ms/staticwebapps) 服务来快速部署你的 Vite 应用。你只需：

* 注册 Azure 账号并获取一个订阅（subscription）的 key。可以在 [此处快速完成注册](https://azure.microsoft.com/free)。
* 将你的应用代码托管到 [GitHub](https://github.com)。
* 在 [VSCode](https://code.visualstudio.com) 中安装 [SWA 扩展](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps)。

安装完此扩展后，进入你应用的根目录。打开 SWA 的扩展程序，登录 Azure，并点击 '+'，来创建一个全新的 SWA。系统会提示你指定所需的订阅 key。

按照扩展程序的启动向导，给你的应用程序起个名字，选择框架预设，并指定应用程序的根目录（通常为 `/`）以及构建文件的路径 `/dist`。此向导完成后，会在你的 repo 中的 `.github` 文件夹中创建一个 GitHub Action。

这个 action 致力于部署你的应用程序（可以在仓库的 Actions 标签中，查看相关进度），成功完成后，你可以点击 GitHub 中出现的 “浏览站点” 的按钮，查看你的应用程序。

## Render {#render}

你可以在 [Render](https://render.com/) 部署你的 Vite 应用。

1. 创建一个 [Render 账号](https://dashboard.render.com/register)

2. 在 [控制台](https://dashboard.render.com/) 页面点击 **New** 按钮并选择 **Static Site**。

3. 链接你的 GitHub/GitLab 账号或使用一个公共仓库

4. 指定一个项目名称和所用分支

   * **构建命令**：`npm install && npm run build`
   * **发布目录**：`dist`

5. 点击 **Create Static Site**

   你的应用将会被部署在 `https://<PROJECTNAME>.onrender.com/`。

默认情况下，推送到该指定分支的任何新的 commit 都会自动触发一个新的部署。[Auto-Deploy](https://render.com/docs/deploys#toggling-auto-deploy-for-a-service) 可以在项目设置中部署。

还可以为项目添加一个 [自定义域名](https://render.com/docs/custom-domains)。

## Flightcontrol

根据 [说明](https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite)，使用 [Flightcontrol](https://www.flightcontrol.dev/?ref=docs-vite) 来部署你的静态站点。

## Kinsta 静态站点托管 {#kinsta-static-site-hosting}

根据 [说明](https://kinsta.com/docs/react-vite-example/)，使用 [Kinsta](https://kinsta.com/static-site-hosting/) 来部署你的静态站点。

## xmit 静态站点托管 {#xmit-static-site-hosting}

根据 [说明](https://xmit.dev/posts/vite-quickstart/)，使用 [xmit](https://xmit.co) 来部署你的静态站点。

---

---
url: /plugins.md
---
# 插件 {#plugins}

:::tip 注意
Vite 旨在为常见的 web 开发工作提供开箱即用的支持。在搜索一个 Vite 或 Rollup 兼容插件之前，请先查看 [功能指引](../guide/features.md)。很多场景下，在 Rollup 项目中需要添加插件，而在 Vite 中已经内建支持了。
:::

请查看 [使用插件](../guide/using-plugins) 一章了解更多插件使用方式。

## 官方插件 {#official-plugins}

### [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) {#vitejs-plugin-vue}

* 提供 Vue 3 单文件组件支持。

### [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) {#vitejs-plugin-vue-jsx}

* 提供 Vue 3 JSX 支持（通过 [专用的 Babel 转换插件](https://github.com/vuejs/jsx-next)）。

### [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2) {#vitejs-plugin-vue2}

* 提供对 Vue 2.7 的单文件组件支持。

### [@vitejs/plugin-vue2-jsx](https://github.com/vitejs/vite-plugin-vue2-jsx) {#vitejs-plugin-vue2-jsx}

* 提供对 Vue 2.7 JSX 对支持（通过 [dedicated Babel transform](https://github.com/vuejs/jsx-vue2/)）。

### [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react) {#vitejs-plugin-react}

* 使用 esbuild 和 Babel，以较小的软件包占用空间和使用 Babel 转换管道的灵活性实现快速 HMR。如果没有额外的 Babel 插件，在构建过程中只能使用 esbuild。

### [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) {#vitejs-plugin-react-swc}

* 在开发时会将 Babel 替换为 SWC。在生产环境构建期间，若使用了插件则会使用 SWC+esbuild，若没有使用插件则仅会用到 esbuild。对不需要非标准 React 扩展的大型项目，冷启动和模块热替换（HMR）将会有显著提升。

### [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) {#vitejs-plugin-legacy}

* 为打包后的文件提供传统浏览器兼容性支持。

## 社区插件 {#community-plugins}

查看 [awesome-vite](https://github.com/vitejs/awesome-vite#plugins) - 你也可以通过 PR 的方式将你的插件添加到此列表中。

## Rollup 插件 {#rollup-plugins}

[Vite 插件](../guide/api-plugin) 是 Rollup 插件接口的一种扩展。查看 [Rollup 插件兼容性章节](../guide/api-plugin#rollup-plugin-compatibility) 获取更多信息。

---

---
url: /guide/api-plugin.md
---
# 插件 API {#plugin-api}

Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因此，你只需要编写一个 Vite 插件，就可以同时为开发环境和生产环境工作。

**推荐在阅读下面的章节之前，首先阅读下 [Rollup 插件文档](https://cn.rollupjs.org/plugin-development/)**

## 致插件创作者 {#authoring-a-plugin}

Vite 努力秉承开箱即用的原则，因此在创作一款新插件前，请确保已经阅读过 [Vite 的功能指南](/guide/features)，避免重复劳作。同时还应查看社区是否存在可用插件，包括 [兼容 Rollup 的插件](https://github.com/rollup/awesome) 以及 [Vite 的专属插件](https://github.com/vitejs/awesome-vite#plugins)。

当创作插件时，你可以在 `vite.config.js` 中直接使用它。没必要直接为它创建一个新的 package。当你发现某个插件在你项目中很有用时，可以考虑 [在社区中](https://chat.vite.dev) 将其与他人分享。

::: tip
在学习、调试或创作插件时，我们建议在你的项目中引入 [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect)。 它可以帮助你检查 Vite 插件的中间状态。安装后，你可以访问 `localhost:5173/__inspect/` 来检查你项目的模块和栈信息。请查阅 [vite-plugin-inspect 文档](https://github.com/antfu/vite-plugin-inspect) 中的安装说明。
![vite-plugin-inspect](/images/vite-plugin-inspect.png)
:::

## 约定 {#conventions}

如果插件不使用 Vite 特有的钩子，可以作为 [兼容 Rollup 的插件](#rollup-plugin-compatibility) 来实现，推荐使用 [Rollup 插件名称约定](https://cn.rollupjs.org/plugin-development/#conventions)。

* Rollup 插件应该有一个带 `rollup-plugin-` 前缀、语义清晰的名称。
* 在 package.json 中包含 `rollup-plugin` 和 `vite-plugin` 关键字。

这样，插件也可以用于纯 Rollup 或基于 WMR 的项目。

对于 Vite 专属的插件：

* Vite 插件应该有一个带 `vite-plugin-` 前缀、语义清晰的名称。
* 在 package.json 中包含 `vite-plugin` 关键字。
* 在插件文档增加一部分关于为什么本插件是一个 Vite 专属插件的详细说明（如，本插件使用了 Vite 特有的插件钩子）。

如果你的插件只适用于特定的框架，它的名字应该遵循以下前缀格式：

* `vite-plugin-vue-` 前缀作为 Vue 插件
* `vite-plugin-react-` 前缀作为 React 插件
* `vite-plugin-svelte-` 前缀作为 Svelte 插件

更多详情参见 [虚拟模块的相关内容](#virtual-modules-convention).

## 插件配置 {#plugins-config}

用户会将插件添加到项目的 `devDependencies` 中并使用数组形式的 `plugins` 选项配置它们。

```js [vite.config.js]
import vitePlugin from 'vite-plugin-feature'
import rollupPlugin from 'rollup-plugin-feature'

export default defineConfig({
  plugins: [vitePlugin(), rollupPlugin()],
})
```

假值的插件将被忽略，可以用来轻松地启用或停用插件。

`plugins` 也可以接受将多个插件作为单个元素的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化（flatten）。

```js
// 框架插件
import frameworkRefresh from 'vite-plugin-framework-refresh'
import frameworkDevtools from 'vite-plugin-framework-devtools'

export default function framework(config) {
  return [frameworkRefresh(config), frameworkDevTools(config)]
}
```

```js [vite.config.js]
import { defineConfig } from 'vite'
import framework from 'vite-plugin-framework'

export default defineConfig({
  plugins: [framework()],
})
```

## 简单示例 {#simple-examples}

:::tip
通常的惯例是创建一个 Vite/Rollup 插件作为一个返回实际插件对象的工厂函数。该函数可以接受允许用户自定义插件行为的选项。
:::

### 转换自定义文件类型 {#transforming-custom-file-types}

```js
const fileRegex = /\.(my-file-ext)$/

export default function myPlugin() {
  return {
    name: 'transform-file',

    transform(src, id) {
      if (fileRegex.test(id)) {
        return {
          code: compileFileToJS(src),
          map: null // 如果可行将提供 source map
        }
      }
    },
  }
}
```

### 引入一个虚拟文件 {#importing-a-virtual-file}

请在 [下一小节中](#virtual-modules-convention) 中查看示例：

## 虚拟模块相关说明 {#virtual-modules-convention}

虚拟模块是一种很实用的模式，使你可以对使用 ESM 语法的源文件传入一些编译时信息。

```js
export default function myPlugin() {
  const virtualModuleId = 'virtual:my-module'
  const resolvedVirtualModuleId = '\0' + virtualModuleId

  return {
    name: 'my-plugin', // 必须的，将会在 warning 和 error 中显示
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId
      }
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `export const msg = "from virtual module"`
      }
    },
  }
}
```

这使得可以在 JavaScript 中引入这些模块：

```js
import { msg } from 'virtual:my-module'

console.log(msg)
```

虚拟模块在 Vite（以及 Rollup）中都以 `virtual:` 为前缀，作为面向用户路径的一种约定。如果可能的话，插件名应该被用作命名空间，以避免与生态系统中的其他插件发生冲突。举个例子，`vite-plugin-posts` 可以要求用户导入一个 `virtual:posts` 或者 `virtual:posts/helpers` 虚拟模块来获得编译时信息。在内部，使用了虚拟模块的插件在解析时应该将模块 ID 加上前缀 `\0`，这一约定来自 rollup 生态。这避免了其他插件尝试处理这个 ID（比如 node 解析），而例如 sourcemap 这些核心功能可以利用这一信息来区别虚拟模块和正常文件。`\0` 在导入 URL 中不是一个被允许的字符，因此我们需要在导入分析时替换掉它们。一个虚拟 ID 为 `\0{id}` 在浏览器中开发时，最终会被编码为 `/@id/__x00__{id}`。这个 id 会被解码回进入插件处理管线前的样子，因此这对插件钩子的代码是不可见的。

请注意，直接从真实文件派生出来的模块，就像单文件组件中的脚本模块（如.vue 或 .svelte SFC）不需要遵循这个约定。SFC 通常在处理时生成一组子模块，但这些模块中的代码可以映射回文件系统。对这些子模块使用 `\0` 会使 sourcemap 无法正常工作。

## 通用钩子 {#universal-hooks}

在开发中，Vite 开发服务器会创建一个插件容器来调用 [Rollup 构建钩子](https://cn.rollupjs.org/plugin-development/#build-hooks)，与 Rollup 如出一辙。

以下钩子在服务器启动时被调用：

* [`options`](https://cn.rollupjs.org/plugin-development/#options)
* [`buildStart`](https://cn.rollupjs.org/plugin-development/#buildstart)

以下钩子会在每个传入模块请求时被调用：

* [`resolveId`](https://cn.rollupjs.org/plugin-development/#resolveid)
* [`load`](https://cn.rollupjs.org/plugin-development/#load)
* [`transform`](https://cn.rollupjs.org/plugin-development/#transform)

它们还有一个扩展的 `options` 参数，包含其他特定于 Vite 的属性。你可以在 [SSR 文档](/guide/ssr#ssr-specific-plugin-logic) 中查阅更多内容。

一些 `resolveId` 调用的 `importer` 值可能是根目录下的通用 `index.html` 的绝对路径，这是由于 Vite 非打包的开发服务器模式无法始终推断出实际的导入者。对于在 Vite 的解析管道中处理的导入，可以在导入分析阶段跟踪导入者，提供正确的 `importer` 值。

以下钩子在服务器关闭时被调用：

* [`buildEnd`](https://cn.rollupjs.org/plugin-development/#buildend)
* [`closeBundle`](https://cn.rollupjs.org/plugin-development/#closebundle)

请注意 [`moduleParsed`](https://cn.rollupjs.org/plugin-development/#moduleparsed) 钩子在开发中是 **不会** 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。

[Output Generation Hooks](https://cn.rollupjs.org/plugin-development/#output-generation-hooks)（除了 `closeBundle`) 在开发中是 **不会** 被调用的。你可以认为 Vite 的开发服务器只调用了 `rollup.rollup()` 而没有调用 `bundle.generate()`。

## Vite 独有钩子 {#vite-specific-hooks}

Vite 插件也可以提供钩子来服务于特定的 Vite 目标。这些钩子会被 Rollup 忽略。

### `config` {#config}

* **类型：** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`
* **种类：** `async`，`sequential`

  在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 `mode` 和 `command`。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。

  **示例：**

  ```js
  // 返回部分配置（推荐）
  const partialConfigPlugin = () => ({
    name: 'return-partial',
    config: () => ({
      resolve: {
        alias: {
          foo: 'bar',
        },
      },
    }),
  })

  // 直接改变配置（应仅在合并不起作用时使用）
  const mutateConfigPlugin = () => ({
    name: 'mutate-config',
    config(config, { command }) {
      if (command === 'build') {
        config.root = 'foo'
      }
    },
  })
  ```

  ::: warning 注意
  用户插件在运行这个钩子之前会被解析，因此在 `config` 钩子中注入其他插件不会有任何效果。
  :::

### `configResolved` {#configresolved}

* **类型：** `(config: ResolvedConfig) => void | Promise<void>`
* **种类：** `async`，`parallel`

  在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。

  **示例：**

  ```js
  const examplePlugin = () => {
    let config

    return {
      name: 'read-config',

      configResolved(resolvedConfig) {
        // 存储最终解析的配置
        config = resolvedConfig
      },

      // 在其他钩子中使用存储的配置
      transform(code, id) {
        if (config.command === 'serve') {
          // dev: 由开发服务器调用的插件
        } else {
          // build: 由 Rollup 调用的插件
        }
      },
    }
  }
  ```

  注意，在开发环境下，`command` 的值为 `serve`（在 CLI 中，`vite` 和 `vite dev` 是 `vite serve` 的别名）。

### `configureServer` {#configureserver}

* **类型：** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`
* **种类：** `async`，`sequential`
* **此外请看** [ViteDevServer](./api-javascript#vitedevserver)

  是用于配置开发服务器的钩子。最常见的用例是在内部 [connect](https://github.com/senchalabs/connect) 应用程序中添加自定义中间件:

  ```js
  const myPlugin = () => ({
    name: 'configure-server',
    configureServer(server) {
      server.middlewares.use((req, res, next) => {
        // 自定义请求处理...
      })
    },
  })
  ```

  **注入后置中间件**

  `configureServer` 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 **之后** 运行的中间件，你可以从 `configureServer` 返回一个函数，将会在内部中间件安装后被调用：

  ```js
  const myPlugin = () => ({
    name: 'configure-server',
    configureServer(server) {
      // 返回一个在内部中间件安装后
      // 被调用的后置钩子
      return () => {
        server.middlewares.use((req, res, next) => {
          // 自定义请求处理...
        })
      }
    },
  })
  ```

  **存储服务器访问**

  在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问:

  ```js
  const myPlugin = () => {
    let server
    return {
      name: 'configure-server',
      configureServer(_server) {
        server = _server
      },
      transform(code, id) {
        if (server) {
          // 使用 server...
        }
      },
    }
  }
  ```

  注意 `configureServer` 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。

### `configurePreviewServer` {#configurepreviewserver}

* **类型：** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`
* **种类：** `async`，`sequential`
* **参见：** [PreviewServerForHook](./api-javascript#previewserverforhook)

  与 [`configureServer`](/guide/api-plugin.html#configureserver) 相同，但用于预览服务器。`configurePreviewServer` 这个钩子与 `configureServer` 类似，也是在其他中间件安装前被调用。如果你想要在其他中间件 **之后** 安装一个插件，你可以从 `configurePreviewServer` 返回一个函数，它将会在内部中间件被安装之后再调用：

  ```js
  const myPlugin = () => ({
    name: 'configure-preview-server',
    configurePreviewServer(server) {
      // 返回一个钩子，会在其他中间件安装完成后调用
      return () => {
        server.middlewares.use((req, res, next) => {
          // 自定义处理请求 ...
        })
      }
    },
  })
  ```

### `transformIndexHtml` {#transformindexhtml}

* **类型：** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`
* **种类：** `async`，`sequential`

  转换 `index.html` 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露[`ViteDevServer`](./api-javascript#vitedevserver)实例，在构建期间暴露 Rollup 输出的包。

  这个钩子可以是异步的，并且可以返回以下其中之一:

  * 经过转换的 HTML 字符串
  * 注入到现有 HTML 中的标签描述符对象数组（`{ tag, attrs, children }`）。每个标签也可以指定它应该被注入到哪里（默认是在 `<head>` 之前）
  * 一个包含 `{ html, tags }` 的对象

  默认情况下 `order` 是 `undefined`，这个钩子会在 HTML 被转换后应用。为了注入一个应该通过 Vite 插件管道的脚本， `order: 'pre'` 指将在处理 HTML 之前应用。 `order: 'post'` 是在所有未定义的 `order` 的钩子函数被应用后才应用。

  **基础示例：**

  ```js
  const htmlPlugin = () => {
    return {
      name: 'html-transform',
      transformIndexHtml(html) {
        return html.replace(
          /<title>(.*?)<\/title>/,
          `<title>Title replaced!</title>`,
        )
      },
    }
  }
  ```

  **完整钩子签名：**

  ```ts
  type IndexHtmlTransformHook = (
    html: string,
    ctx: {
      path: string
      filename: string
      server?: ViteDevServer
      bundle?: import('rollup').OutputBundle
      chunk?: import('rollup').OutputChunk
    },
  ) =>
    | IndexHtmlTransformResult
    | void
    | Promise<IndexHtmlTransformResult | void>

  type IndexHtmlTransformResult =
    | string
    | HtmlTagDescriptor[]
    | {
        html: string
        tags: HtmlTagDescriptor[]
      }

  interface HtmlTagDescriptor {
    tag: string
    attrs?: Record<string, string>
    children?: string | HtmlTagDescriptor[]
    /**
     * 默认： 'head-prepend'
     */
    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'
  }
  ```

  ::: warning 注意
  如果你正在使用一个对入口文件有特殊处理方式的框架（比如 [SvelteKit](https://github.com/sveltejs/kit/discussions/8269#discussioncomment-4509145)），那么这个钩子就不会被触发。
  :::

### `handleHotUpdate` {#handlehotupdate}

* **类型：** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`
* **参见：** [HMR API](./api-hmr)

  执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：

  ```ts
  interface HmrContext {
    file: string
    timestamp: number
    modules: Array<ModuleNode>
    read: () => string | Promise<string>
    server: ViteDevServer
  }
  ```

  * `modules` 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。

  * `read` 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 `fs.readFile` 直接会返回空内容。传入的 `read` 函数规范了这种行为。

  钩子可以选择:

  * 过滤和缩小受影响的模块列表，使 HMR 更准确。

  * 返回一个空数组并进行全面刷新：

    ```js
    handleHotUpdate({ server, modules, timestamp }) {
      // 手动使模块失效
      const invalidatedModules = new Set()
      for (const mod of modules) {
        server.moduleGraph.invalidateModule(
          mod,
          invalidatedModules,
          timestamp,
          true
        )
      }
      server.ws.send({ type: 'full-reload' })
      return []
    }
    ```

  * 返回一个空数组，并通过向客户端发送自定义事件，来进行完全自定义的 HMR处理：

    ```js
    handleHotUpdate({ server }) {
      server.ws.send({
        type: 'custom',
        event: 'special-update',
        data: {}
      })
      return []
    }
    ```

    客户端代码应该使用 [HMR API](./api-hmr) 注册相应的处理器（这应该被相同插件的 `transform` 钩子注入）：

    ```js
    if (import.meta.hot) {
      import.meta.hot.on('special-update', (data) => {
        // 执行自定义更新
      })
    }
    ```

## 插件顺序 {#plugin-ordering}

一个 Vite 插件可以额外指定一个 `enforce` 属性（类似于 webpack 加载器）来调整它的应用顺序。`enforce` 的值可以是`pre` 或 `post`。解析后的插件将按照以下顺序排列：

* Alias
* 带有 `enforce: 'pre'` 的用户插件
* Vite 核心插件
* 没有 enforce 值的用户插件
* Vite 构建用的插件
* 带有 `enforce: 'post'` 的用户插件
* Vite 后置构建插件（最小化，manifest，报告）

请注意，这与钩子的排序是分开的，钩子的顺序仍然会受到它们的 `order` 属性的影响，这一点 [和 Rollup 钩子的表现一样](https://cn.rollupjs.org/plugin-development/#build-hooks)。

## 情景应用 {#conditional-application}

默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 `apply` 属性指明它们仅在 `'build'` 或 `'serve'` 模式时调用：

```js
function myPlugin() {
  return {
    name: 'build-only',
    apply: 'build' // 或 'serve'
  }
}
```

同时，还可以使用函数来进行更精准的控制：

```js
apply(config, { command }) {
  // 非 SSR 情况下的 build
  return command === 'build' && !config.build.ssr
}
```

## Rollup 插件兼容性 {#rollup-plugin-compatibility}

相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：`@rollup/plugin-alias` 或 `@rollup/plugin-json`），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。

一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：

* 没有使用 [`moduleParsed`](https://cn.rollupjs.org/plugin-development/#moduleparsed) 钩子。
* 它在打包钩子和输出钩子之间没有很强的耦合。

如果一个 Rollup 插件只在构建阶段有意义，则在 `build.rollupOptions.plugins` 下指定即可。它的工作原理与 Vite 插件的 `enforce: 'post'` 和 `apply: 'build'` 相同。

你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:

```js [vite.config.js]
import example from 'rollup-plugin-example'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...example(),
      enforce: 'post',
      apply: 'build',
    },
  ],
})
```

## 路径规范化 {#path-normalization}

Vite 对路径进行了规范化处理，在解析路径时使用 POSIX 分隔符（ / ），同时保留了 Windows 中的卷名。而另一方面，Rollup 在默认情况下保持解析的路径不变，因此解析的路径在 Windows 中会使用 win32 分隔符（ \ ）。然而，Rollup 插件会使用 `@rollup/pluginutils` 内部的 [`normalizePath` 工具函数](https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath)，它在执行比较之前将分隔符转换为 POSIX。所以意味着当这些插件在 Vite 中使用时，`include` 和 `exclude` 两个配置模式，以及与已解析路径比较相似的路径会正常工作。

所以对于 Vite 插件来说，在将路径与已解析的路径进行比较时，首先规范化路径以使用 POSIX 分隔符是很重要的。从 `vite` 模块中也导出了一个等效的 `normalizePath` 工具函数。

```js
import { normalizePath } from 'vite'

normalizePath('foo\\bar') // 'foo/bar'
normalizePath('foo/bar') // 'foo/bar'
```

## 过滤与 include/exclude 模式 {#filtering-include-exclude-pattern}

Vite 暴露了 [`@rollup/pluginutils` 的 `createFilter`](https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter) 函数，以支持 Vite 独有插件和集成使用标准的 include/exclude 过滤模式，Vite 核心自身也正在使用它。

## 客户端与服务端间通信 {#client-server-communication}

从 Vite 2.9 开始，我们为插件提供了一些实用工具，以帮助处理与客户端的通信。

### 服务端到客户端 {#server-to-client}

在插件一侧，我们可以使用 `server.ws.send` 来向客户端广播事件：

```js [vite.config.js]
export default defineConfig({
  plugins: [
    {
      // ...
      configureServer(server) {
        server.ws.on('connection', () => {
          server.ws.send('my:greetings', { msg: 'hello' })
        })
      },
    },
  ],
})
```

::: tip 注意
我们建议总是给你的事件名称 **添加前缀**，以避免与其他插件冲突。
:::

在客户端侧，使用 [`hot.on`](/guide/api-hmr.html#hot-on-event-cb) 去监听事件：

```ts twoslash
import 'vite/client'
// ---cut---
// 客户端
if (import.meta.hot) {
  import.meta.hot.on('my:greetings', (data) => {
    console.log(data.msg) // hello
  })
}
```

### 客户端到服务端 {#client-to-server}

为了从客户端向服务端发送事件，我们可以使用 [`hot.send`](/guide/api-hmr.html#hot-send-event-payload)：

```ts
// 客户端
if (import.meta.hot) {
  import.meta.hot.send('my:from-client', { msg: 'Hey!' })
}
```

然后使用 `server.ws.on` 并在服务端监听这些事件：

```js [vite.config.js]
export default defineConfig({
  plugins: [
    {
      // ...
      configureServer(server) {
        server.ws.on('my:from-client', (data, client) => {
          console.log('Message from client:', data.msg) // Hey!
          //  只回复客户端（如果需要的话）
          client.send('my:ack', { msg: 'Hi! I got your message!' })
        })
      },
    },
  ],
})
```

### 自定义事件的 TypeScript 类型定义指南 {#typeScript-for-custom-events}

Vite 会在内部从 `CustomEventMap` 这个接口推断出 payload 的类型，可以通过扩展这个接口来为自定义事件进行类型定义：

:::tip 提示
在指定 TypeScript 声明文件时，确保包含 `.d.ts` 扩展名。否则，TypeScript 可能不会知道试图扩展的是哪个文件。
:::

```ts [events.d.ts]
import 'vite/types/customEvent.d.ts'

declare module 'vite/types/customEvent.d.ts' {
  interface CustomEventMap {
    'custom:foo': { msg: string }
    // 'event-key': payload
  }
}
```

这个接口扩展被 `InferCustomEventPayload<T>` 所使用，用来推断事件 `T` 的 payload 类型。要了解更多关于这个接口如何被使用的信息，请参考 [HMR API 文档](./api-hmr#hmr-api)。

```ts twoslash
import 'vite/client'
import type { InferCustomEventPayload } from 'vite/types/customEvent.d.ts'
declare module 'vite/types/customEvent.d.ts' {
  interface CustomEventMap {
    'custom:foo': { msg: string }
  }
}
// ---cut---
type CustomFooPayload = InferCustomEventPayload<'custom:foo'>
import.meta.hot?.on('custom:foo', (payload) => {
  // payload 的类型为 { msg: string }
})
import.meta.hot?.on('unknown:event', (payload) => {
  // payload 的类型为 any
})
```

---

---
url: /guide/migration-from-v1.md
---
# 从 v1 迁移 {#migration-from-v1}

## 配置项变化 {#config-options-change}

* 以下选项已被删除，应通过 [插件](./api-plugin) 实现：

  * `resolvers`
  * `transforms`
  * `indexHtmlTransforms`

* `jsx` 和 `enableEsbuild` 都已被删除，请使用新的 [`esbuild`](/config/#esbuild) 选项。

* [CSS 相关选项](/config/#css-modules) 都包含在 `css` 字段下。

* 所有 [用于构建的选项](/config/#build-options) 都包含在 `build` 字段下。

  * `rollupInputOptions` 和 `rollupOutputOptions` 已经被 [`build.rollupOptions`](/config/#build-rollupoptions) 替代。
  * `esbuildTarget` 变更为 [`build.target`](/config/#build-target)
  * `emitManifest` 变更为 [`build.manifest`](/config/#build-manifest)
  * 以下构建选项已经被移除，因为它们可以通过插件钩子或其他选项实现：
    * `entry`
    * `rollupDedupe`
    * `emitAssets`
    * `emitIndex`
    * `shouldPreload`
    * `configureBuild`

* 所有的 [server-specific options](/config/#server-options) 都包含在 `server` 字段下。

  * `hostname` 变更为 [`server.host`](/config/#server-host)。
  * `httpsOptions` 已被删除，[`server.https`](/config/#server-https) 可以直接接收选项对象。
  * `chokidarWatchOptions` 变更为 [`server.watch`](/config/#server-watch)。

* [`assetsInclude`](/config/#assetsinclude) 现在接收 `string | RegExp | (string | RegExp)[]` 而不是一个函数。

* 所有 Vue 特定选项都已移除；应将选项传递给 Vue 插件。

## 别名用法变化 {#alias-behavior-change}

[`alias`](/config/#resolve-alias) 现在会被传递给 `@rollup/plugin-alias` 并不再需要开始/结尾处的斜线了。此行为目前是一个直接替换，所以 1.0 风格的目录别名需要删除其结尾处的斜线：

```diff
- alias: { '/@foo/': path.resolve(__dirname, 'some-special-dir') }
+ alias: { '/@foo': path.resolve(__dirname, 'some-special-dir') }
```

另外，你可以对该选项使用 `[{ find: RegExp, replacement: string }]` 格式以求更精确的控制。

## Vue Support {#vue-support}

Vite 2.0 核心已经是框架无关的了。对 Vue 的支持目前详见 [`@vitejs/plugin-vue`](https://github.com/vitejs/vite/tree/main/packages/plugin-vue)。安装它并添加到 Vite 配置十分简单:

```js
import vue from '@vitejs/plugin-vue'
import { defineConfig } from 'vite'
export default defineConfig({
  plugins: [vue()]
})
```

### 自定义块转换 {#custom-blocks-transforms}

一个自定义插件可以用来转换 Vue 自定义块，如下所示:

```ts
// vite.config.js
import vue from '@vitejs/plugin-vue'
import { defineConfig } from 'vite'
const vueI18nPlugin = {
  name: 'vue-i18n',
  transform(code, id) {
    if (!/vue&type=i18n/.test(id)) {
      return
    }
    if (/\.ya?ml$/.test(id)) {
      code = JSON.stringify(require('js-yaml').load(code.trim()))
    }
    return `export default Comp => {
      Comp.i18n = ${code}
    }`
  }
}
export default defineConfig({
  plugins: [vue(), vueI18nPlugin]
})
```

## React 支持 {#react-support}

现已支持 React Fast Refresh，详见 [`@vitejs/plugin-react`](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react)。

## HMR API 变化 {#hmr-api-change}

`import.meta.hot.acceptDeps()` 已经弃用。[`import.meta.hot.accept()`](./api-hmr#hot-accept-deps-cb) 现在可以接收一个或多个依赖。

## Manifest 格式变化 {#manifest-format-change}

构建清单现在使用以下格式:

```json
{
  "index.js": {
    "file": "assets/index.acaf2b48.js",
    "imports": [...]
  },
  "index.css": {
    "file": "assets/index.7b7dbd85.css",
  },
  "asset.png": {
    "file": "assets/asset.0ab0f9cd.png",
  }
}
```

对于入口 JS chunk，它还列出了它导入的 chunk，这些 chunk 可以用来渲染预加载指令。

## 致插件作者 {#for-plugin-authors}

Vite 2 使用了一套完全重定义的，扩展了 Rollup 插件的接口。请阅读新的 [插件开发指南](./api-plugin).

一些将 v1 插件迁移到 v2 的提示:

* `resolvers` -> 使用 [`resolveId`](https://cn.rollupjs.org/guide/en/#resolveid) 钩子
* `transforms` -> 使用 [`transform`](https://cn.rollupjs.org/guide/en/#transform) 钩子
* `indexHtmlTransforms` -> 使用 [`transformIndexHtml`](./api-plugin#transformindexhtml) 钩子
* 虚拟文件支持 -> 使用 [`resolveId`](https://cn.rollupjs.org/guide/en/#resolveid) + [`load`](https://cn.rollupjs.org/guide/en/#load) 钩子
* 添加 `alias`，`define` 或其他配置项 -> 使用 [`config`](./api-plugin#config) 钩子

由于大多数逻辑应通过插件钩子实现，而无需使用中间件，因此对中间件的需求大大减少。内部服务器应用现在看起来像旧版的 [connect](https://github.com/senchalabs/connect) 实例，而不是 Koa。

---

---
url: /guide/migration-from-v2.md
---
# 从 v2 迁移 {#migration-from-v2}

## Node 支持 {#node-support}

Vite 不再支持 Node 12 / 13 / 15，因为上述版本已经进入了 EOL 阶段。现在你必须使用 Node 14.18+ / 16+ 版本。

## 现代浏览器基准线变化 {#modern-browser-baseline-change}

生产构建打包时会假定目标支持现代 JavaScript。默认情况下，Vite 的目标是支持 [原生 ES 模块](https://caniuse.com/es6-module)、[原生 ESM 动态导入](https://caniuse.com/es6-module-dynamic-import) 以及 [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) 的浏览器：

* Chrome >=87
* Firefox >=78
* Safari >=13
* Edge >=88

一小部分用户需要 [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)，它会自动生成兼容性 chunk 以及相应的 ES 语言功能的 polyfill。

## 配置选项变化 {#config-options-changes}

* 下列在 v2 当中我们已经标记为弃用选项，现在已经被移除：

  * `alias`（改为了 [`resolve.alias`](../config/shared-options.md#resolve-alias)）
  * `dedupe`（改为了 [`resolve.dedupe`](../config/shared-options.md#resolve-dedupe)）
  * `build.base`（改为了 [`base`](../config/shared-options.md#base)）
  * `build.brotliSize`（改为了 [`build.reportCompressedSize`](../config/build-options.md#build-reportcompressedsize)）
  * `build.cleanCssOptions`（Vite 现在使用 esbuild 来做 CSS 最小化压缩）
  * `build.polyfillDynamicImport`（在没有支持动态导入的浏览器中，使用 [`@vitejs/plugin-legacy`](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)）
  * `optimizeDeps.keepNames`（改为了 [`optimizeDeps.esbuildOptions.keepNames`](../config/dep-optimization-options.md#optimizedeps-esbuildoptions)）

## 架构变更和兼容选项 {#achitecture-changes-and-legacy-options}

这一小节描述了 Vite v3 中最大的架构变更。在项目从 v2 迁移、遇到兼容性问题时，可以使用新添加的兼容选项来恢复到 Vite v2 策略。

### 开发服务器变化 {#dev-server-changes}

Vite 的默认开发服务器端口号现在改为了 5173。你可以使用 [`server.port`](../config/server-options.md#server-port) 将其设置为 3000。

Vite 的默认开发服务器主机地址现在改为了 `localhost`。在 Vite v2，Vite 默认监听的是 `127.0.0.1`。Node.js 在 v17 版本以下通常会解析 `localhost` 到 `127.0.0.1`，因此对这些版本，主机地址并未变更。若明确需要，对于 Node.js v17 版本以上，你可以使用 [`server.host`](../config/server-options.md#server-host)、将其设置为 `127.0.0.1`。

请注意，现在 Vite v3 会打印出正确的主机地址。这意味着使用 `localhost` 时 Vite 可能会打印 `127.0.0.1` 作为正在监听的地址。你可以设置 [`dns.setDefaultResultOrder('verbatim')`](https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order) 来避免这一表现。查看 [`server.host`](../config/server-options.md#server-host) 了解详情。

### SSR Changes {#ssr-changes}

Vite v3 默认在 SSR 构建时使用 ESM 格式。当使用 ESM 时，[SSR 外部化的启发式方法](/guide/ssr.html#ssr-externals) 将不再需要。默认情况下所有的依赖都将被外部化。你可以使用 [`ssr.noExternal`](../config/ssr-options.md#ssrnoexternal) 来控制哪些依赖需要被包含进 SSR 的打包产物中。

如果你无法在你的 SSR 项目中使用 ESM，你可以设置 `ssr.format: 'cjs'` 来生成一个 CJS 格式的产物。在这种情况下，会使用和 Vite v2 相同的外部化策略。

同样 [`build.rollupOptions.output.inlineDynamicImports`](https://cn.rollupjs.org/guide/en/#outputinlinedynamicimports) 现在在 `ssr.target` 是 `node` 时，也默认置为了 `false`。`inlineDynamicImports` 它会改变执行顺序，并且 node 构建不需要打包到单个文件。

## 其他一般性变化 {#general-changes}

* SSR 和库模式中将会根据语法格式和包的类型，为输出的 JS 文件提供一个更合理的文件扩展名（`js`、`mjs` 或是 `cjs`）。
* Terser 现在是一个可选依赖。如果你使用的是 `build.minify: 'terser'`，你需要手动安装它：
  ```
  npm add -D terser
  ```

### `import.meta.glob` {#importmetaglob}

* [原始 `import.meta.glob`](features.md#glob-import-as) 从 `{ assert: { type: 'raw' }}` 迁移为 `{ as: 'raw' }`

* `import.meta.glob` 的 key 现在是相对于当前模块。

  ```diff
  // 文件：/foo/index.js
  const modules = import.meta.glob('../foo/*.js')
  // 转换为：
  const modules = {
  -  '../foo/bar.js': () => {}
  +  './bar.js': () => {}
  }
  ```

* 当在 `import.meta.glob` 中使用别名（alias）时，键值总是绝对路径。

* `import.meta.globEager` 已经弃用，请使用 `import.meta.glob('*', { eager: true })` 来代替。

### WebAssembly 支持 {#webassembly-support}

`import init from 'example.wasm'` 语法被弃用，以防止将来与 ["WASM 的 ESM 集成"](https://github.com/WebAssembly/esm-integration) 冲突。

你可以使用 `?init` 参数，和之前的行为类似：

```diff
-import init from 'example.wasm'
+import init from 'example.wasm?init'
-init().then((exports) => {
+init().then(({ exports }) => {
  exports.test()
})
```

### 自动生成 https 证书 {#automatic-https-certificate-generation}

当使用 `https` 时需要一个合法可用的证书。在 Vite v2 中，如果没有配置证书，Vite 会自动生成和缓存一个自签名的证书。
从 Vite v3 开始，我们推荐手动创建你自己的证书。如果你仍想要使用 v2 中的自动生成，该功能可以通过添加 [@vitejs/plugin-basic-ssl](https://github.com/vitejs/vite-plugin-basic-ssl) 到项目插件中来实现。

```js
import basicSsl from '@vitejs/plugin-basic-ssl'
export default {
  plugins: [basicSsl()]
}
```

## 实验性 {#experimental}

### 在构建阶段使用 esbuild 依赖优化

在 v3 版本下，Vite 允许在构建阶段使用 esbuild 进行依赖优化。如果开启此项，那么它将消除 v2 版本中存在的最明显的开发与构建最终产物之间的区别。[`@rollupjs/plugin-commonjs`](https://github.com/rollup/plugins/tree/master/packages/commonjs) 在此处不再需要，因为 esbuild 会将纯 CommonJS 依赖转换为 ESM。

如果你想尝试该构建策略，你可以使用 `optimizeDeps.disabled: false`（在 v3 中默认是 `disabled: 'build'`）。`@rollup/plugin-commonjs`
可以通过设置 `build.commonjsOptions: { include: [] }` 来移除。

## 进阶 {#advanced}

下列改动仅会影响到插件/工具的作者：

* [\[#5868\] refactor: remove deprecated api for 3.0](https://github.com/vitejs/vite/pull/5868)
  * `printHttpServerUrls` 被移除
  * `server.app`、`server.transformWithEsbuild` 被移除
  * `import.meta.hot.acceptDeps` 被移除
* [\[#6901\] fix: sequential injection of tags in transformIndexHtml](https://github.com/vitejs/vite/pull/6901)
  * `transformIndexHtml` 现在会从更早的插件处获取到正确的内容，因此，现在注入的标签的顺序与预期的一样。
* [\[#7995\] chore: do not fixStacktrace](https://github.com/vitejs/vite/pull/7995)
  * `ssrLoadModule` 的 `fixStacktrace` 选项现在默认为 `false`
* [\[#8178\] feat!: migrate to ESM](https://github.com/vitejs/vite/pull/8178)
  * `formatPostcssSourceMap` 现在是异步的
  * `resolvePackageEntry`、`resolvePackageData` 在 CJS 构建中将不再可用（需要在 CJS 中使用动态导入）
* [\[#8626\] refactor: type client maps](https://github.com/vitejs/vite/pull/8626)
  * `import.meta.hot.accept` 的回调函数类型现在更严格了。现在是 `(mod: (Record<string, any> & { [Symbol.toStringTag]: 'Module' }) | undefined) => void`（之前是 `(mod: any) => void`）。

此外，还有其他一些只影响少数用户的破坏性变化。

* [\[#5018\] feat: enable `generatedCode: 'es2015'` for rollup build](https://github.com/vitejs/vite/pull/5018)
  * 转义到 ES5 现在是必要的，即使用户代码仅含 ES5。
* [\[#7877\] fix: vite client types](https://github.com/vitejs/vite/pull/7877)
  * `/// <reference lib="dom" />` 已从 `vite/client.d.ts` 中移除。必须在 `tsconfig.json` 使用 `{ "lib": ["dom"] }` 或 `{ "lib": ["webworker"] }`。
* [\[#8090\] feat: preserve process env vars in lib build](https://github.com/vitejs/vite/pull/8090)
  * `process.env.*` 现在在库模式下是被保留的了。
* [\[#8280\] feat: non-blocking esbuild optimization at build time](https://github.com/vitejs/vite/pull/8280)
  * `server.force` 选项现已移除，改为了直接的 `force` 选项。
* [\[#8550\] fix: dont handle sigterm in middleware mode](https://github.com/vitejs/vite/pull/8550)
  * 当以中间件模式运行时，Vite 不再在 `SIGTERM` 强制杀进程。

## 从 v1 迁移 {#migration-from-v1}

在 Vite v2 文档中查看 [从 v1 迁移指南](https://v2.vite.dev/guide/migration.html)（[中文版](/guide/migration-from-v1)），了解如何将你的应用迁移到 Vite v2，然后再处理本页中所提及的变化。

---

---
url: /guide/migration-from-v3.md
---
# 从 v3 迁移 {#migration-from-v3}

## Rollup 3 {#rollup-3}

Vite 现在正式启用 [Rollup 3](https://github.com/vitejs/vite/issues/9870)，这使得我们可以简化 Vite 内部的资源处理并同时拥有许多改进。详情请查看 [Rollup 3 版本记录](https://github.com/rollup/rollup/releases/tag/v3.0.0)。

Rollup 3 尽最大可能兼容了 Rollup 2。如果你在项目中使用了自定义的 [`rollupOptions`](../config/build-options.md#rollup-options) 并（升级后）遇到了问题，请先查看 [Rollup 迁移指南](https://cn.rollupjs.org/migration/) 来更新升级你的配置。

## 现代浏览器基准线变化 {#modern-browser-baseline-change}

当前对于现代浏览器的构建目标及现调整为了默认 `safari14` 以求更广的 ES2020 兼容性（从 `safari13` 升级）。这意味着现代化构建现在可以使用 [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)，同时 [空值合并运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) 将不再被转译。如果你需要支持更旧版本的浏览器，你可以照常添加 [`@vitejs/plugin-legacy`](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)。

## 其他一般性变化 {#general-changes}

### 编码 {#encoding}

构建的默认字符集现在是 utf8（查看 [#10753](https://github.com/vitejs/vite/issues/10753) 了解更多细节）。

### 以字符串形式导入 CSS {#importing-css-as-a-string}

在过往的 Vite 3 之中，以默认导入形式导入一个 `.css` 文件的可能会造成对 CSS 的双重加载。

In Vite 4, the manifest files (`build.manifest`, `build.ssrManifest`) was generated in the root of `build.outDir` by default. From Vite 5, those will be generated in the `.vite` directory in the `build.outDir` by default.

这种双重加载出现的原因是 `.css` 文件是将会被释放（emit）到最终产物的，并且很可能 CSS 字符串将会在应用代码中被使用到，就比如被框架运行时注入的时候。对于现在的 Vite 4，`.css` 默认导出 [已经被废弃](https://github.com/vitejs/vite/issues/11094)。在这种情况下你将需要使用 `?inline` 这个查询参数后缀，而这时将不会将导入的 `.css` 样式文件释放到最终产物。

CLI shortcuts, like `r` to restart the dev server, now require an additional `Enter` press to trigger the shortcut. For example, `r + Enter` to restart the dev server.

### 默认情况下的生产构建 {#production-builds-by-default}

不管所传递的 `--mode` 是什么，`vite build` 总是构建生产版本。之前，若将 `mode` 改为 `production` 之外的模式会构建开发版本，如果现在希望用于开发构建，可以在 `.env.{mode}` 文件中设置 `NODE_ENV=development`。

在本次变动中，如果 `process.env.NODE_ENV` 已经被定义，`vite dev` 和 `vite build` 将不再覆盖它。所以如果在构建前设置了 `process.env.NODE_ENV = 'development'`，将会构建开发版本。这在并行执行多个构建或开发服务器时提供了更多的控制权。

请参阅更新后的 [`mode` 文档](/guide/env-and-mode.md#modes) 了解更多详细信息。

### 环境变量 {#environment-variables}

Vite 现在使用 `dotenv` 16 和 `dotenv-expand` 9（之前是 `dotenv` 14 和 `dotenv-expand` 5）如果你有一个包含 `#` 或者 `` ` `` 的值，你将需要将它们以双引号包裹起来。

```diff
-VITE_APP=ab#cd`ef
+VITE_APP="ab#cd`ef"
```

了解更多详情，请查看 [`dotenv`](https://github.com/motdotla/dotenv/blob/master/CHANGELOG.md) 和 [`dotenv-expand` 更新日志](https://github.com/motdotla/dotenv-expand/blob/master/CHANGELOG.md)。

## 进阶 {#advanced}

下列改动仅会影响到插件/工具的作者：

* [\[#11036\] feat(client)!: remove never implemented hot.decline](https://github.com/vitejs/vite/issues/11036)
  * 使用 `hot.invalidate` 来代替
* [\[#9669\] feat: align object interface for `transformIndexHtml` hook](https://github.com/vitejs/vite/issues/9669)
  * 使用 `order` 来代替 `enforce`

此外，还有其他一些只影响少数用户的破坏性变化。

* [\[#11101\] feat(ssr)!: remove dedupe and mode support for CJS](https://github.com/vitejs/vite/pull/11101)
  * 您应该迁移到 SSR 的默认 ESM 模式，CJS SSR 支持可能会在下一个 Vite 主要版本删除。
* [\[#10475\] feat: handle static assets in case-sensitive manner](https://github.com/vitejs/vite/pull/10475)
  * 您的项目不应该依赖于会被不同操作系统忽略大小写的文件名。
* [\[#10996\] fix!: make `NODE_ENV` more predictable](https://github.com/vitejs/vite/pull/10996)
  * 有关此更改的解释，请参阅 PR。
* [\[#10903\] refactor(types)!: remove facade type files](https://github.com/vitejs/vite/pull/10903)

## 从 v2 迁移 {#migration-from-v2}

请先查看之前 Vite v3 文档中的 [从 v2 迁移指南](/guide/migration-from-v2) 了解迁移到 v3 所需要的更改，然后再继续执行本页提到的相关更改。

---

---
url: /guide/migration-from-v4.md
---
# 从 v4 迁移 {#migration-from-v4}

## Node.js 支持 {#nodejs-support}

Vite 不再支持 Node.js 14 / 16 / 17 / 19，因为它们已经到了 EOL。现在需要 Node.js 18 / 20+。

Some internal APIs have been removed due to changes in Vite's implementation. If you were relying on one of them, please create a [feature request](https://github.com/vitejs/vite/issues/new?assignees=\&labels=enhancement%3A+pending+triage\&projects=\&template=feature_request.yml).

Vite 现在使用 Rollup 4，它也带来了一些重大的变化，特别是：

* 导入断言（`assertions` 属性）已被重命名为导入属性（`attributes` 属性）。
* 不再支持 Acorn 插件。
* 对于 Vite 插件，`this.resolve` 的 `skipSelf` 选项现在默认为 `true`。
* 对于 Vite 插件，`this.parse` 现在只支持 `allowReturnOutsideFunction` 选项。

你可以阅读 [Rollup 的发布说明](https://github.com/rollup/rollup/releases/tag/v4.0.0) 中的破坏性变更，了解在 [`build.rollupOptions`](/config/build-options.md#build-rollupoptions) 中构建相关的变更。

如果你正在使用 TypeScript，请确保设置 `moduleResolution: 'bundler'`（或 `node16`/`nodenext`）因为 Rollup 4 需要它。或者你可以设置 `skipLibCheck: true`。

## 废弃 CJS Node API {#deprecate-cjs-node-api}

CJS 的 Node API 已经被废弃。当调用 `require('vite')` 时，将会记录一个废弃警告。你应该更新你的文件或框架来导入 Vite 的 ESM 构建。

在一个基础的 Vite 项目中，请确保：

1. `vite.config.js` 配置文件的内容使用 ESM 语法。
2. 最近的 `package.json` 文件中有 `"type": "module"`，或者使用 `.mjs`/`.mts` 扩展名，例如 `vite.config.mjs` 或者 `.vite.config.mts`。

对于其他项目，有几种常见的方法：

* **配置 ESM 为默认，如果需要则选择 CJS：** 在项目 `package.json` 中添加 `"type": "module"`。所有 `*.js` 文件现在都被解释为 ESM，并且需要使用 ESM 语法。你可以将一个文件重命名为 `.cjs` 扩展名来继续使用 CJS。
* **保持 CJS 为默认，如果需要则选择 ESM：** 如果项目 `package.json` 没有 `"type": "module"`，所有 `*.js` 文件都被解释为 CJS。你可以将一个文件重命名为 `.mjs` 扩展名来使用 ESM。
* **动态导入 Vite：** 如果你需要继续使用 CJS，你可以使用 `import('vite')` 动态导入 Vite。这要求你的代码必须在一个 `async` 上下文中编写，但是由于 Vite 的 API 大多是异步的，所以应该还是可以管理的。

查看 [排错指南](/guide/troubleshooting.html#vite-cjs-node-api-deprecated) 获取更多信息。

## 重新设计 `define` 和 `import.meta.env.*` 的替换策略 {#rework-define-and-import-meta-env-replacement-strategy}

在 Vite 4 中，[`define`](/config/shared-options.md#define) 和 [`import.meta.env.*`](/guide/env-and-mode.md#env-variables) 特性在开发和构建中使用的是不同的替换策略：

* 在开发时，这两个特性分别作为全局变量注入到 `globalThis` 和 `import.meta` 中。
* 在构建时，这两个特性都使用正则表达式进行静态替换。

这导致在尝试访问这些变量时，开发和构建存在一致性问题，有时甚至导致构建失败。例如：

```js
// vite.config.js
export default defineConfig({
  define: {
    __APP_VERSION__: JSON.stringify('1.0.0'),
  },
})
```

```js
const data = { __APP_VERSION__ }
// 开发：{ __APP_VERSION__: "1.0.0" } ✅
// 构建：{ "1.0.0" } ❌

const docs = 'I like import.meta.env.MODE'
// 开发："I like import.meta.env.MODE" ✅
// 构建："I like "production"" ❌
```

Vite 5 通过在构建中使用 `esbuild` 来处理替换，使其与开发行为保持一致。

这个改动不应该影响大部分设置，因为已经在文档中说明了 `define` 的值应该遵循 esbuild 的语法：

> 为了与 esbuild 行为保持一致，表达式必须是一个 JSON 对象（null、boolean、number、string、array 或 object）或一个单一标识符字符串。

然而，如果你更喜欢对值直接使用静态替换，你可以使用 [`@rollup/plugin-replace`](https://github.com/rollup/plugins/tree/master/packages/replace)。

## 其他一般性变化 {#general-changes}

### SSR 外部模块值现在符合生产环境行为 {#ssr-externalized-modules-value-now-matches-production}

在 Vite 4 中，服务端渲染的外部模块被包装为 `.default` 和 `.__esModule` 处理，以实现更好的互操作性，但是它并不符合运行时环境（例如 Node.js）加载时的生产环境行为，导致难以捕获的不一致性。默认情况下，所有直接的项目依赖都是 SSR 外部化的。

Vite 5 现在删除了 `.default` 和 `.__esModule` 处理，以匹配生产环境行为。在实践中，这不应影响正确打包的依赖项，但是如果你在加载模块时遇到新的问题，你可以尝试以下重构：

```js
// 之前：
import { foo } from 'bar'

// 之后：
import _bar from 'bar'
const { foo } = _bar
```

```js
// 之前：
import foo from 'bar'

// 之后：
import * as _foo from 'bar'
const foo = _foo.default
```

注意，这些更改符合 Node.js 的行为，因此也可以在 Node.js 中运行这些导入进行测试。如果你更喜欢坚持使用之前的方式，你可以将 `legacy.proxySsrExternalModules` 设置为 `true`。

### `worker.plugins` 现在是一个函数 {#worker-plugins-is-now-a-function}

在 Vite 4 中，[`worker.plugins`](/config/worker-options.md#worker-plugins) 接受一个插件数组 (`(Plugin | Plugin[])[]`)。从 Vite 5 开始，它需要配置为一个返回插件数组的函数 (`() => (Plugin | Plugin[])[]`)。这个改变是为了让并行的 worker 构建运行得更加一致和可预测。

### 允许路径包含 `.` 回退到 index.html {#allow-path-containing-to-fallback-to-index-html}

在 Vite 4 中，即使 [`appType`](/config/shared-options.md#apptype) 被设置为 `'SPA'`（默认），访问包含 `.` 的路径也不会回退到 index.html。从 Vite 5 开始，它将会回退到 index.html。

注意浏览器将不再在控制台中显示 404 错误消息，如果你将图片路径指向一个不存在的文件（例如 `<img src="./file-does-not-exist.png">`）。

### Align dev and preview HTML serving behaviour {#align-dev-and-preview-html-serving-behaviour}

在 Vite 4 中，开发服务器和预览服务器会根据 HTML 的目录结构和尾部斜杠的不同来提供 HTML。这会导致在测试构建后的应用时出现不一致的情况。Vite 5 重构成了一个单一的行为，如下所示，给定以下文件结构：

```
├── index.html
├── file.html
└── dir
    └── index.html
```

| 请求               | 过往版本 (dev)                | 过往版本 (preview) | 现在 (dev & preview)          |
| ----------------- | ---------------------------- | ----------------- | ---------------------------- |
| `/dir/index.html` | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |
| `/dir`            | `/index.html` (SPA fallback) | `/dir/index.html` | `/index.html` (SPA fallback) |
| `/dir/`           | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |
| `/file.html`      | `/file.html`                 | `/file.html`      | `/file.html`                 |
| `/file`           | `/index.html` (SPA fallback) | `/file.html`      | `/file.html`                 |
| `/file/`          | `/index.html` (SPA fallback) | `/file.html`      | `/index.html` (SPA fallback) |

### Manifest 文件现在默认生成到 `.vite` 目录中 {#manifest-files-are-now-generated-in-vite-directory-by-default}

在 Vite 4 中，manifest 文件（[`build.manifest`](/config/build-options.md#build-manifest)，[`build.ssrManifest`](/config/build-options.md#build-ssrmanifest)）默认会生成在 [`build.outDir`](/config/build-options.md#build-outdir) 的根目录中。

从 Vite 5 开始，这些文件将默认生成在 `build.outDir` 中的 `.vite` 目录中。这个改变有助于解决当公共文件被复制到 `build.outDir` 时，具有相同 manifest 文件名时的冲突。

### 对应的 CSS 文件未在 manifest.json 文件中作为顶级入口列出 {#corresponding-css-files-are-not-listed-as-top-level-entry-in-manifest-json-file}

在 Vite 4 中，JavaScript 入口起点的对应 CSS 文件也被列为了 manifest 文件的顶级入口（[`build.manifest`](/config/build-options.md#build-manifest)）。这些条目是非故意添加的，仅对简单情况有效。

在 Vite 5 中，对应的 CSS 文件只能在 JavaScript 入口起点中找到。
在注入 JS 文件时，对应的 CSS 文件 [应被注入](/guide/backend-integration.md#:~:text=%3C!%2D%2D%20if%20production%20%2D%2D%3E%0A%3Clink%20rel%3D%22stylesheet%22%20href%3D%22/assets/%7B%7B%20manifest%5B%27main.js%27%5D.css%20%7D%7D%22%20/%3E%0A%3Cscript%20type%3D%22module%22%20src%3D%22/assets/%7B%7B%20manifest%5B%27main.js%27%5D.file%20%7D%7D%22%3E%3C/script%3E)。
当需要单独注入 CSS 时，必需将其添加为单独的入口起点。

### CLI 快捷功能键需要一个额外的 `Enter` 按键 {#cli-shortcuts-require-an-additional-enter-press}

CLI 快捷功能键，例如 `r` 重启开发服务器，现在需要额外的 `Enter` 按键来触发快捷功能。例如，`r + Enter` 重启开发服务器。

这个改动防止 Vite 吞噬和控制操作系统特定的快捷键，允许更好的兼容性，当将 Vite 开发服务器与其他进程结合使用时，并避免了[之前的注意事项](https://github.com/vitejs/vite/pull/14342)。

### Update `experimentalDecorators` and `useDefineForClassFields` TypeScript behaviour {#update-experimentaldecorators-and-usedefineforclassfields-typescript-behaviour}

Vite 5 使用 esbuild 0.19 并移除了 esbuild 0.18 的兼容层，这改变了 [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) 和 [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) 的处理方式。

* **`useDefineForClassFields` 默认不启用**

  你需要在 `tsconfig.json` 中设置 `compilerOptions.experimentalDecorators` 为 `true` 来使用装饰器。

* **`useDefineForClassFields` 默认依赖 TypeScript 的 `target` 值**

  如果 `target` 不是 `ESNext` 或 `ES2022` 或更新的版本，或者没有 `tsconfig.json` 文件，`useDefineForClassFields` 将默认为 `false`，这可能会导致默认的 `esbuild.target` 值 `esnext` 出现问题。它可能会转译为[静态初始化块](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility)，这在你的浏览器中可能不被支持。

  因此，建议在配置 `tsconfig.json` 时将 `target` 设置为 `ESNext` 或 `ES2022` 或更新的版本，或者将 `useDefineForClassFields` 显式地设置为 `true`。

```jsonc
{
  "compilerOptions": {
    // 若要使用装饰器就设为 true
    "experimentalDecorators": true,
    // 如果你在浏览器中看到解析错误，请设置为 true
    "useDefineForClassFields": true,
  },
}
```

### 移除 `--https` 标志和 `https: true` {#remove-https-flag-and-https-true}

`--https` 标志会在内部设置 `server.https: true` 和 `preview.https: true`。这个配置本来是为了与自动 https 证书生成功能一起使用的，但是这个功能在[Vite 3 中被移除](https://v3.vitejs.dev/guide/migration.html#automatic-https-certificate-generation)。因此，这个配置已经不再有用，因为它会启动一个没有证书的 Vite HTTPS 服务器。

如果你使用 [`@vitejs/plugin-basic-ssl`](https://github.com/vitejs/vite-plugin-basic-ssl) 或者 [`vite-plugin-mkcert`](https://github.com/liuweiGL/vite-plugin-mkcert)，它们已经在内部设置了 `https` 配置，所以你可以在你的设置中移除 `--https`，`server.https: true`，和`preview.https: true`。

### 移除 `resolvePackageEntry` 和 `resolvePackageData` API {#remove-resolvepackageentry-and-resolvepackagedata-apis}

`resolvePackageEntry` 和 `resolvePackageData` API 已被移除，因为它们暴露了 Vite 的内部机制，并在过去阻碍了 Vite 4.3 的潜在优化。这些 API 可以被第三方包替代，例如：

* `resolvePackageEntry`: [`import.meta.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve) 或者 [`import-meta-resolve`](https://github.com/wooorm/import-meta-resolve) 库。
* `resolvePackageData`: 与上述相同，向上爬取包目录以获取根 `package.json`。或者使用社区的 [`vitefu`](https://github.com/svitejs/vitefu) 库。

```js
import { resolve } from 'import-meta-resolve'
import { findDepPkgJsonPath } from 'vitefu'
import fs from 'node:fs'

const pkg = 'my-lib'
const basedir = process.cwd()

// `resolvePackageEntry`:
const packageEntry = resolve(pkg, basedir)

// `resolvePackageData`:
const packageJsonPath = findDepPkgJsonPath(pkg, basedir)
const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))
```

## 移除部分废弃 API {#removed-deprecated-apis}

* CSS 文件的默认导出（例如 `import style from './foo.css'`）：使用 `?inline` 查询参数代替
* `import.meta.globEager`：使用 `import.meta.glob('*', { eager: true })` 来代替
* `ssr.format: 'cjs'` 和 `legacy.buildSsrCjsExternalHeuristics`（[#13816](https://github.com/vitejs/vite/discussions/13816)）
* `server.middlewareMode: 'ssr'` 和 `server.middlewareMode: 'html'`：使用 [`appType`](/config/shared-options.md#apptype) + [`server.middlewareMode: true`](/config/server-options.md#server-middlewaremode) 来代替（[#8452](https://github.com/vitejs/vite/pull/8452)）

## 进阶 {#advanced}

下列改动仅会影响到插件/工具的作者：

* [\[#14119\] refactor!: merge `PreviewServerForHook` into `PreviewServer` type](https://github.com/vitejs/vite/pull/14119)
  * The `configurePreviewServer` hook now accepts the `PreviewServer` type instead of `PreviewServerForHook` type.
* [\[#14818\] refactor(preview)!: use base middleware](https://github.com/vitejs/vite/pull/14818)
  * Middlewares added from the returned function in `configurePreviewServer` now does not have access to the `base` when comparing the `req.url` value. This aligns the behaviour with the dev server. You can check the `base` from the `configResolved` hook if needed.
* [\[#14834\] fix(types)!: expose httpServer with Http2SecureServer union](https://github.com/vitejs/vite/pull/14834)
  * `http.Server | http2.Http2SecureServer` is now used instead of `http.Server` where appropriate.

此外，还有其他一些只影响少数用户的破坏性变化。

* [\[#14098\] fix!: avoid rewriting this (reverts #5312)](https://github.com/vitejs/vite/pull/14098)
  * 之前顶层 `this` 将会在构建时被默认地改写为 `globalThis`，这个行为现在已被移除
* [\[#14231\] feat!: add extension to internal virtual modules](https://github.com/vitejs/vite/pull/14231)
  * 内置虚拟模块的 id 现在包含一个扩展名（`.js`）
* [\[#14583\] refactor!: remove exporting internal APIs](https://github.com/vitejs/vite/pull/14583)
  * 移除意外导出的内部 API：`isDepsOptimizerEnabled` 和 `getDepOptimizationConfig`
  * 移除导出的内部类型：`DepOptimizationResult`，`DepOptimizationProcessing` 和 `DepsOptimizer`
  * 改名 `ResolveWorkerOptions` 类型为 `ResolvedWorkerOptions`
* [\[#5657\] fix: return 404 for resources requests outside the base path](https://github.com/vitejs/vite/pull/5657)
  * 过去，Vite 对于不带 `Accept: text/html` 的请求，会将其当作带有基础路径的请求来处理。现在 Vite 不再这样做，而是返回 404。
* [\[#14723\] fix(resolve)!: remove special .mjs handling](https://github.com/vitejs/vite/pull/14723)
  * 在过去，当一个库的 `"exports"` 字段映射到一个 `.mjs` 文件时，Vite 仍然会尝试匹配 `"browser"` 和 `"module"` 字段，以修复与某些库的兼容性。现在，这种行为已被移除，以便与导出解析算法保持一致。
* [\[#14733\] feat(resolve)!: remove `resolve.browserField`](https://github.com/vitejs/vite/pull/14733)
  * `resolve.browserField` 已从 Vite 3 开始被弃用，而是使用 [`resolve.mainFields`](/config/shared-options.md#resolve-mainfields) 的更新默认值 `['browser', 'module', 'jsnext:main', 'jsnext']`。
* [\[#14855\] feat!: add isPreview to ConfigEnv and resolveConfig](https://github.com/vitejs/vite/pull/14855)
  * 在 `ConfigEnv` 对象中，重命名 `ssrBuild` 为 `isSsrBuild`。
* [\[#14945\] fix(css): correctly set manifest source name and emit CSS file](https://github.com/vitejs/vite/pull/14945)
  * CSS 文件名现在是基于 chunk 名生成的。

## 从 v3 迁移 {#migration-from-v3}

请先查看 [从 v3 迁移指南](/guide/migration-from-v3) 文档查看对您的应用所有需要迁移的改动，然后再执行本篇指南所述的改动。

---

---
url: /guide/migration.md
---
# 从 v5 迁移 {#migration-from-v5}

## 环境 API {#environment-api}

作为新的实验性 [环境 API](/guide/api-environment.md) 的一部分，我们进行了大规模的内部重构。Vite 6 努力避免引入破坏性的变更，以确保大多数项目能够快速升级到新的主要版本。我们会等待大部分的生态系统迁移并稳定后，再开始推荐使用新的 API。可能会有一些边缘情况，但这些应该只会影响到框架和工具的底层使用。我们已经与生态系统中的维护者合作，在发布前减轻了这些差异。如果你发现了回退性问题，请 [新建 issue](https://github.com/vitejs/vite/issues/new?assignees=\&labels=pending+triage\&projects=\&template=bug_report.yml)。

由于 Vite 的实现发生了改变，一些内部的 API 已经被移除了。如果你依赖于其中的某一个，那么请创建一个 [feature request](https://github.com/vitejs/vite/issues/new?assignees=\&labels=enhancement%3A+pending+triage\&projects=\&template=feature_request.yml)。

## Vite Runtime API {#vite-runtime-api}

实验性的 Vite Runtime API 已经演变为模块运行器 API（Module Runner API），这是作为新的实验性 [环境 API](/guide/api-environment) 的一部分，在 Vite 6 中发布。鉴于这个功能是实验性的，所以在 Vite 5.1 中引入的先前 API 的移除并不是一个破坏性的更改，但是用户在迁移到 Vite 6 的过程中，需要将他们的使用方式更新为与模块运行器相等的方式。

## 总体变化 {#general-changes}

### `resolve.conditions` 的默认值 {#default-value-for-resolve-conditions}

此更改不会影响未配置 [`resolve.conditions`](/config/shared-options#resolve-conditions) / [`ssr.resolve.conditions`](/config/ssr-options#ssr-resolve-conditions) / [`ssr.resolve.externalConditions`](/config/ssr-options#ssr-resolve-externalconditions) 的用户。

在 Vite 5 中，`resolve.conditions` 的默认值是 `[]`，某些条件是内部添加的。`ssr.resolve.conditions` 的默认值是 `resolve.conditions` 的值。

从 Vite 6 开始，部分条件不再在内部添加，需要包含在配置值中。
不再在内部添加的条件为

* `resolve.conditions` 是 `['module', 'browser', 'development|production']`
* `ssr.resolve.conditions` 是 `['module', 'node', 'development|production']`

这些选项的默认值会更新为相应的值，`ssr.resolve.conditions` 不再使用 `resolve.conditions` 作为默认值。请注意，`development|production`是一个特殊变量，会根据 `process.env.NODE_ENV` 的值被替换为 `production` 或 `development`。这些默认值从 `vite` 导出为 `defaultClientConditions` 和 `defaultServerConditions`。

如果为 `resolve.conditions` 或 `ssr.resolve.conditions` 指定了自定义值，则需要更新该值以包含新条件。
例如，如果先前为 `resolve.conditions` 指定了 `['custom']`，那么现在就需要指定 `['custom', ...defaultClientConditions]`。

### JSON stringify

在 Vite 5 中，当设置 [`json.stringify: true`](/config/shared-options#json-stringify) 时，[`json.namedExports`](/config/shared-options#json-namedexports) 会被禁用。

从 Vite 6 开始，即使设置了 `json.stringify: true`，`json.namedExports` 也不会被禁用。如果希望实现以前的行为，可以设置 `json.namedExports: false`。

Vite 6 还为 `json.stringify` 引入了一个新的默认值，即 `'auto'`，它只会对大型 JSON 文件进行字符串化处理。要禁用此行为，请设置 `json.stringify: false`。

### 在 HTML 元素中扩展对资源引用的支持 {#extended-support-of-asset-references-in-html-elements}

在 Vite 5 中，只有少数支持的 HTML 元素能够引用由 Vite 处理和打包的资源，如`<link href>`、`<img src>` 等。

Vite 6 扩展了对更多 HTML 元素的支持。完整列表请参见 [HTML 功能介绍](/guide/features.html#html) 文档。

要在某些元素上选择不进行 HTML 处理，可以在元素上添加 `vite-ignore` 属性。

### postcss-load-config

[`postcss-load-config`](https://npmjs.com/package/postcss-load-config) 已从 v4 更新至 v6。现在需要 [`tsx`](https://www.npmjs.com/package/tsx) 或 [`jiti`](https://www.npmjs.com/package/jiti) 来加载 TypeScript postcss 配置文件，而非 [`ts-node`](https://www.npmjs.com/package/ts-node)。此外，现在需要 [`yaml`](https://www.npmjs.com/package/yaml) 来加​​载 YAML postcss 配置文件。

### Sass 现在默认使用现代 API {#sass-now-uses-modern-api-by-default}

在 Vite 5 中，Sass 默认使用传统 API。Vite 5.4 增加了对现代 API 的支持。

从 Vite 6 开始，Sass 默认使用现代 API。如果想继续使用传统 API，可以设置 [`css.preprocessorOptions.sass.api: 'legacy'` / `css.preprocessorOptions.scss.api: 'legacy'`](/config/shared-options#css-preprocessoroptions)。但请注意，传统 API 支持将在 Vite 7 中移除。

要迁移到现代 API，请参阅 [Sass 文档](https://sass-lang.com/documentation/breaking-changes/legacy-js-api/)。

### 在 library 模式下自定义 CSS 输出文件名 {#customize-css-output-file-name-in-library-mode}

在 Vite 5 中，library 模式下的 CSS 输出文件名始终是 `style.css`，无法通过 Vite 配置轻松更改。

从 Vite 6 开始，默认文件名将使用 `package.json` 中的 `"name"`，与 JS 输出文件类似。如果 [`build.lib.fileName`](/config/build-options.md#build-lib) 设置为字符串，该值也将用于 CSS 输出文件名。要明确设置不同的 CSS 文件名，可以使用新的 [`build.lib.cssFileName`](/config/build-options.md#build-lib) 进行配置。

迁移时，如果您依赖于 `style.css` 文件名，则应根据软件包名称将对该文件的引用更新为新名称。例如:

```json [package.json]
{
  "name": "my-lib",
  "exports": {
    "./style.css": "./dist/style.css" // [!code --]
    "./style.css": "./dist/my-lib.css" // [!code ++]
  }
}
```

如果你更喜欢像在 Vite 5 中那样使用 `style.css`，可以设置 `build.lib.cssFileName: 'style'`。

## 进阶 {#advanced}

还有其他一些只影响少数用户的破坏性更改。

* [\[#17922\] fix(css)!: remove default import in ssr dev](https://github.com/vitejs/vite/pull/17922)
  * 对 CSS 文件默认导入的支持在 Vite 4 中[已被弃用](https://v4.vite.dev/guide/migration.html#importing-css-as-a-string)，并在 Vite 5 中被移除，但在 SSR 开发模式中仍被无意支持。现在该支持已被移除。
* [\[#15637\] fix!: default `build.cssMinify` to `'esbuild'` for SSR](https://github.com/vitejs/vite/pull/15637)
  * [`build.cssMinify`](/config/build-options#build-cssminify) 现在即使是 SSR 版本也默认为启用。
* [\[#18070\] feat!: proxy bypass with WebSocket](https://github.com/vitejs/vite/pull/18070)
  * `server.proxy[path].bypass` 现在用于 WebSocket 升级请求，在这种情况下，`res` 参数将是 `undefined`。
* [\[#18209\] refactor!: bump minimal terser version to 5.16.0](https://github.com/vitejs/vite/pull/18209)
  * [`build.minify: 'terser'`](/config/build-options#build-minify) 所支持的最小 terser 版本从 5.4.0 提升至 5.16.0
* [\[#18231\] chore(deps): update dependency @rollup/plugin-commonjs to v28](https://github.com/vitejs/vite/pull/18231)
  * [`commonjsOptions.strictRequires`](https://github.com/rollup/plugins/blob/master/packages/commonjs/README.md#strictrequires) 现在默认为 `true`（之前为 `'auto'`）。
    * 这可能会导致包的大小增大，但会使构建更加确定。
    * 如果将 CommonJS 文件指定为入口点，则可能需要额外的步骤。阅读 [commonjs plugin 文档](https://github.com/rollup/plugins/blob/master/packages/commonjs/README.md#using-commonjs-files-as-entry-points) 了解更多详情.
* [\[#18243\] chore(deps)!: migrate `fast-glob` to `tinyglobby`](https://github.com/vitejs/vite/pull/18243)
  * globs 中不再支持范围大括号 (`{01..03}` ⇒ `['01', '02', '03']`) 和递增大括号 (`{2..8..2}` ⇒ `['2', '4', '6', '8']`) 。
* [\[#18395\] feat(resolve)!: allow removing conditions](https://github.com/vitejs/vite/pull/18395)
  * 此 PR 不仅引入了上文提到的 " `resolve.conditions` 的默认值" 这一破坏性变更，还使得在 SSR 中，`resolve.mainFields` 不能用于无外部化依赖关系。如果您正在使用 `resolve.mainFields`，并希望将其应用于 SSR 中的无外部化依赖关系，您可以使用 [`ssr.resolve.mainFields`](/config/ssr-options#ssr-resolve-mainfields)。
* [\[#18493\] refactor!: remove fs.cachedChecks option](https://github.com/vitejs/vite/pull/18493)
  * 由于在缓存文件夹中写入文件并立即导入时会出现边缘情况，因此删除了这一选择优化。
* \~~[\[#18697\] fix(deps)!: update dependency dotenv-expand to v12](https://github.com/vitejs/vite/pull/18697)~~
  * \~~插值中使用的变量应在插值之前声明。更多详情，请参阅 [`dotenv-expand` changelog](https://github.com/motdotla/dotenv-expand/blob/v12.0.1/CHANGELOG.md#1200-2024-11-16)。~~ 此重大变化已在 v6.1.0 中恢复。
* [\[#16471\] feat: v6 - Environment API](https://github.com/vitejs/vite/pull/16471)

  * 对仅 SSR 模块的更新不再触发客户端的页面重载。要恢复以前的行为，可使用自定义 Vite 插件：

    ```ts twoslash
    import type { Plugin, EnvironmentModuleNode } from 'vite'

    function hmrReload(): Plugin {
      return {
        name: 'hmr-reload',
        enforce: 'post',
        hotUpdate: {
          order: 'post',
          handler({ modules, server, timestamp }) {
            if (this.environment.name !== 'ssr') return

            let hasSsrOnlyModules = false

            const invalidatedModules = new Set<EnvironmentModuleNode>()
            for (const mod of modules) {
              if (mod.id == null) continue
              const clientModule =
                server.environments.client.moduleGraph.getModuleById(mod.id)
              if (clientModule != null) continue

              this.environment.moduleGraph.invalidateModule(
                mod,
                invalidatedModules,
                timestamp,
                true,
              )
              hasSsrOnlyModules = true
            }

            if (hasSsrOnlyModules) {
              server.ws.send({ type: 'full-reload' })
              return []
            }
          },
        },
      }
    }
    ```

## 从 v4 迁移 {#migration-from-v4}

在 Vite v5 文档中查看 [从 v4 迁移指南](https://v5.vite.dev/guide/migration.html)（[中文版](/guide/migration-from-v4)），了解如何将你的应用迁移到 Vite v5，然后再处理本页中所提及的变化。

---

---
url: /releases.md
---
# 发布 {#releases}

Vite 的发布遵循 [语义化版本控制](https://semver.org/)。你可以在 [Vite npm 包页面](https://www.npmjs.com/package/vite) 查看 Vite 的最新稳定版本。

过去版本的完整变更日志可以在 [GitHub](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md) 上找到。

## 发布周期 {#release-cycle}

Vite 没有固定的发布周期。

* **补丁版本** 根据需要发布（通常每周）。
* **次要版本** 总是包含新功能，并根据需要发布。且总会有一个 beta 预发布阶段（通常每两个月）。
* **主要版本** 通常与 [Node.js 生命周期终止计划](https://endoflife.date/nodejs) 保持一致，并会提前宣布。这些版本会经过与生态系统的长期讨论，并有 alpha 和 beta 预发布阶段（通常每年）。

Vite 团队支持的 Vite 版本范围是这样确定的：

* **当前次要版本** 会定期提供修复。
* **上一个主要版本** （仅限其最新的次要版本）和 **上一个次要版本** 会接收重要修复和安全补丁。
* **倒数第二个主要版本** （仅限其最新的次要版本）和 **倒数第二个次要版本** 会接收安全补丁。
* 这些之前的所有版本将不再支持。

例如，如果 Vite 最新版本为 5.3.10：

* `vite@5.3` 会定期发布补丁版本。
* 重要修复和安全补丁会回溯到 `vite@4` 和 `vite@5.2`。
* 安全补丁也会回溯到 `vite@3` 和 `vite@5.1`。
* `vite@2` 和 `vite@5.0` 不再支持更新。用户应升级以接收更新。

我们建议定期更新 Vite。在每次主要版本更新时，请查看 [迁移指南](/guide/migration)。Vite 团队与生态系统中的主要项目紧密合作，以确保新版本的质量。我们通过 [vite-ecosystem-ci 项目](https://github.com/vitejs/vite-ecosystem-ci) 在发布新版本前测试它们。大多数使用 Vite 的项目应该能够快速提供支持或迁移到新版本。

## 语义化版本控制的特殊情况 {#semantic-versioning-edge-cases}

### TypeScript 定义 {#type-script-definitions}

我们可能会在次要版本之间对 TypeScript 定义进行不兼容的更改。这是因为：

* 有时 TypeScript 本身会在次要版本之间进行不兼容的更改，我们可能需要调整类型以支持更新所需的 TypeScript 版本。
* 偶尔我们可能需要采用仅在更新版本的 TypeScript 中可用的功能，这会提高最低要求的 TypeScript 版本。
* 如果你使用 TypeScript，可以使用一个锁定当前次要版本的 semver 范围，并在 Vite 发布新次要版本时手动升级。

### esbuild

[esbuild](https://esbuild.github.io/) 目前是 pre-1.0.0，有时它会有主要版本更新，我们可能需要包含这些变化以使用新的功能和性能改进，并可能会在 Vite 次要版本中提升 esbuild 的版本。

### Node.js 非 LTS 版本 {#node-js-non-lts-versions}

非 LTS 的 Node.js 版本（奇数版本）不在 Vite 的 CI 测试范围内，但在其 [生命周期终止](https://endoflife.date/nodejs) 之前应该仍然可以工作。

## 预发布 {#pre-releases}

次要版本通常会经历不固定数量的 beta 发布。主要版本会经历 alpha 和 beta 阶段。

预发布允许早期采用者和生态系统中的维护者进行集成和稳定性测试，并提供反馈。不要在生产环境中使用预发布版本。所有预发布版本都被认为是不稳定的，并且可能会在其中发布破坏性更改。在使用预发布版本时，请始终锁定到确切的版本。

## 弃用 {#deprecations}

我们定期在次要版本中弃用已被更好替代方案取代的功能。弃用的功能将继续工作，但会有类型或日志警告。在进入弃用状态后的下一个主要版本中将移除这些功能。每个主要版本的 [迁移指南](/guide/migration) 将列出这些移除，并记录升级路径。

## 实验性功能 {#experimental-features}

某些功能在 Vite 的稳定版本中发布时被标记为实验性功能。实验性功能允许我们收集实际使用经验，以影响其最终设计。目的是让用户通过在生产环境中测试它们来提供反馈。实验性功能本身被认为是不稳定的，应该仅在受控环境中使用。这些功能可能会在小版本之间发生变化，因此当依赖它们时，用户必须锁定 Vite 版本。我们将为每个实验性功能创建一个 [GitHub 讨论](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=is%3Aopen+label%3Aexperimental+category%3AFeedback)。

---

---
url: /guide/ssr.md
---
# 服务端渲染 (SSR) {#server-side-rendering}

:::tip 注意
SSR 特别指支持在 Node.js 中运行相同应用程序的前端框架（例如 React、Preact、Vue 和 Svelte），将其预渲染成 HTML，最后在客户端进行水合处理。如果你正在寻找与传统服务器端框架的集成，请查看 [后端集成指南](./backend-integration)。

下面的指南还假定你在选择的框架中有使用 SSR 的经验，并且只关注特定于 Vite 的集成细节。
:::

:::warning 底层 API
这是一个底层 API，是为库和框架作者准备的。如果你的目标是构建一个应用程序，请确保优先查看 [Vite SSR 章节](https://github.com/vitejs/awesome-vite#ssr) 中更上层的 SSR 插件和工具。也就是说，大部分应用都是基于 Vite 的底层 API 之上构建的。

目前，Vite 正在用 [环境 API](https://github.com/vitejs/vite/discussions/16358) 来改进 SSR API。查看链接了解更多详情。
:::

## 示例项目 {#example-projects}

Vite 为服务端渲染（SSR）提供了内建支持。[`create-vite-extra`](https://github.com/bluwy/create-vite-extra) 包含了一些你可以用作参考的SSR设置示例：

* [Vanilla](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla)
* [Vue](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue)
* [React](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react)
* [Preact](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact)
* [Svelte](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte)
* [Solid](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid)

你也可以通过 [运行 `create-vite`](./index.md#scaffolding-your-first-vite-project) 在本地搭建这些项目，并在框架选项下选择 `Others > create-vite-extra`。

## 源码结构 {#source-structure}

一个典型的 SSR 应用应该有如下的源文件结构：

```
- index.html
- server.js # main application server
- src/
  - main.js          # 导出环境无关的（通用的）应用代码
  - entry-client.js  # 将应用挂载到一个 DOM 元素上
  - entry-server.js  # 使用某框架的 SSR API 渲染该应用
```

`index.html` 将需要引用 `entry-client.js` 并包含一个占位标记供给服务端渲染时注入：

```html [index.html]
<div id="app"><!--ssr-outlet--></div>
<script type="module" src="/src/entry-client.js"></script>
```

你可以使用任何你喜欢的占位标记来替代 `<!--ssr-outlet-->`，只要它能够被正确替换。

## 情景逻辑 {#conditional-logic}

如果需要执行 SSR 和客户端间情景逻辑，可以使用：

```js twoslash
import 'vite/client'
// ---cut---
if (import.meta.env.SSR) {
  // ... 仅在服务端执行的逻辑
}
```

这是在构建过程中被静态替换的，因此它将允许对未使用的条件分支进行摇树优化。

## 设置开发服务器 {#setting-up-the-dev-server}

在构建 SSR 应用程序时，你可能希望完全控制主服务器，并将 Vite 与生产环境脱钩。因此，建议以中间件模式使用 Vite。下面是一个关于 [express](https://expressjs.com/) 的例子：

```js{15-18} twoslash [server.js]
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'
import { createServer as createViteServer } from 'vite'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

async function createServer() {
  const app = express()

  // 以中间件模式创建 Vite 应用，并将 appType 配置为 'custom'
  // 这将禁用 Vite 自身的 HTML 服务逻辑
  // 并让上级服务器接管控制
  const vite = await createViteServer({
    server: { middlewareMode: true },
    appType: 'custom'
  })

  // 使用 vite 的 Connect 实例作为中间件
  // 如果你使用了自己的 express 路由（express.Router()），你应该使用 router.use
  // 当服务器重启（例如用户修改了 vite.config.js 后），
  // `vite.middlewares` 仍将保持相同的引用
  // （带有 Vite 和插件注入的新的内部中间件堆栈）。
  // 即使在重新启动后，以下内容仍然有效。
  app.use(vite.middlewares)

  app.use('*all', async (req, res) => {
    // 服务 index.html - 下面我们来处理这个问题
  })

  app.listen(5173)
}

createServer()
```

这里 `vite` 是 [ViteDevServer](./api-javascript#vitedevserver) 的一个实例。`vite.middlewares` 是一个 [Connect](https://github.com/senchalabs/connect) 实例，它可以在任何一个兼容 connect 的 Node.js 框架中被用作一个中间件。

下一步是实现 `*` 处理程序供给服务端渲染的 HTML：

```js twoslash [server.js]
// @noErrors
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

/** @type {import('express').Express} */
var app
/** @type {import('vite').ViteDevServer}  */
var vite

// ---cut---
app.use('*all', async (req, res, next) => {
  const url = req.originalUrl

  try {
    // 1. 读取 index.html
    let template = fs.readFileSync(
      path.resolve(__dirname, 'index.html'),
      'utf-8',
    )

    // 2. 应用 Vite HTML 转换。这将会注入 Vite HMR 客户端，
    //    同时也会从 Vite 插件应用 HTML 转换。
    //    例如：@vitejs/plugin-react 中的 global preambles
    template = await vite.transformIndexHtml(url, template)

    // 3. 加载服务器入口。vite.ssrLoadModule 将自动转换
    //    你的 ESM 源码使之可以在 Node.js 中运行！无需打包
    //    并提供了一种高效的模块失效机制，类似于模块热替换（HMR）。
    const { render } = await vite.ssrLoadModule('/src/entry-server.js')

    // 4. 渲染应用的 HTML。这假设 entry-server.js 导出的 `render`
    //    函数调用了适当的 SSR 框架 API。
    //    例如 ReactDOMServer.renderToString()
    const appHtml = await render(url)

    // 5. 注入渲染后的应用程序 HTML 到模板中。
    const html = template.replace(`<!--ssr-outlet-->`, () => appHtml)

    // 6. 返回渲染后的 HTML。
    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
  } catch (e) {
    // 如果捕获到了一个错误，让 Vite 来修复该堆栈，这样它就可以映射回
    // 你的实际源码中。
    vite.ssrFixStacktrace(e)
    next(e)
  }
})
```

`package.json` 中的 `dev` 脚本也应该相应地改变，使用服务器脚本：

```diff [package.json]
  "scripts": {
-   "dev": "vite"
+   "dev": "node server"
  }
```

## 生产环境构建 {#building-for-production}

为了将 SSR 项目交付生产，我们需要：

1. 正常生成一个客户端构建；
2. 再生成一个 SSR 构建，使其通过 `import()` 直接加载，这样便无需再使用 Vite 的 `ssrLoadModule`；

`package.json` 中的脚本应该看起来像这样：

```json [package.json]
{
  "scripts": {
    "dev": "node server",
    "build:client": "vite build --outDir dist/client",
    "build:server": "vite build --outDir dist/server --ssr src/entry-server.js"
  }
}
```

注意使用 `--ssr` 标志表明这将会是一个 SSR 构建。同时需要指定 SSR 的入口。

接着，在 `server.js` 中，通过 `process.env.NODE_ENV` 条件分支，需要添加一些用于生产环境的特定逻辑：

* 使用 `dist/client/index.html` 作为模板，而不是根目录的 `index.html`，因为前者包含了到客户端构建的正确资源链接。

* 使用 `import('./dist/server/entry-server.js')` （该文件是 SSR 构建产物），而不是使用 `await vite.ssrLoadModule('/src/entry-server.js')`。

* 将 `vite` 开发服务器的创建和所有使用都移到 dev-only 条件分支后面，然后添加静态文件服务中间件来服务 `dist/client` 中的文件。

可以参考 [示例项目](#example-projects) 以获取一个可运行的设置。

## 生成预加载指令 {#generating-preload-directives}

`vite build` 支持使用 `--ssrManifest` 标志，这将会在构建输出目录中生成一份 `.vite/ssr-manifest.json`：

```diff
- "build:client": "vite build --outDir dist/client",
+ "build:client": "vite build --outDir dist/client --ssrManifest",
```

上面的脚本将会为客户端构建生成 `dist/client/.vite/ssr-manifest.json`（是的，该 SSR 清单是从客户端构建生成而来，因为我们想要将模块 ID 映射到客户端文件上）。清单包含模块 ID 到它们关联的 chunk 和资源文件的映射。

为了利用该清单，框架需要提供一种方法来收集在服务端渲染调用期间使用到的组件模块 ID。

`@vitejs/plugin-vue` 支持该功能，开箱即用，并会自动注册使用的组件模块 ID 到相关的 Vue SSR 上下文：

```js [src/entry-server.js]
const ctx = {}
const html = await vueServerRenderer.renderToString(app, ctx)
// ctx.modules 现在是一个渲染期间使用的模块 ID 的 Set
```

我们现在需要在 `server.js` 的生产环境分支下读取该清单，并将其传递到 `src/entry-server.js` 导出的 `render` 函数中。这将为我们提供足够的信息，来为异步路由相应的文件渲染预加载指令！查看 [示例代码](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js) 获取完整示例。你还可以利用 [103 Early Hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103) 所提供的信息。

## 预渲染 / SSG {#pre-rendering--ssg}

如果预先知道某些路由所需的路由和数据，我们可以使用与生产环境 SSR 相同的逻辑将这些路由预先渲染到静态 HTML 中。这也被视为一种静态站点生成（SSG）的形式。查看 [示例渲染代码](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js) 获取有效示例。

## SSR 外部化 {#ssr-externals}

当运行 SSR 时依赖会由 Vite 的 SSR 转换模块系统作外部化。这会同时提速开发与构建。

如果依赖需要被 Vite 的管道转换，例如因为其中使用了未经过转译的 Vite 特性，那么它们可以被添加到 [`ssr.noExternal`](../config/ssr-options.md#ssr-noexternal) 中。

对于采用链接的依赖，它们将默认不会被外部化，这是为了能使其利用 Vite HMR 的优势。如果你不需要这一功效，例如，想要把这些依赖当成非链接情况来测试，你可以将其添加到 [`ssr.external`](../config/ssr-options.md#ssr-external)。

:::warning 使用别名
如果你为某个包配置了一个别名，为了能使 SSR 外部化依赖功能正常工作，你可能想要使用的别名应该指的是实际的 `node_modules` 中的包。[Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) 和 [pnpm](https://pnpm.io/aliases/) 都支持通过 `npm:` 前缀来设置别名。
:::

## SSR 专有插件逻辑 {#ssr-specific-plugin-logic}

一些框架，如 Vue 或 Svelte，会根据客户端渲染和服务端渲染的区别，将组件编译成不同的格式。可以向以下的插件钩子中，给 Vite 传递额外的 `options` 对象，对象中包含 `ssr` 属性来支持根据情景转换：

* `resolveId`
* `load`
* `transform`

**示例：**

```js twoslash
/** @type {() => import('vite').Plugin} */
// ---cut---
export function mySSRPlugin() {
  return {
    name: 'my-ssr',
    transform(code, id, options) {
      if (options?.ssr) {
        // 执行 ssr 专有转换...
      }
    },
  }
}
```

`load` 和 `transform` 中的 `options` 对象为可选项，rollup 目前并未使用该对象，但将来可能会用额外的元数据来扩展这些钩子函数。

:::tip Note
Vite 2.7 之前的版本，会提示你 `ssr` 参数的位置不应该是 `options` 对象。目前所有主要框架和插件都已对应更新，但你可能还是会发现使用过时 API 的旧文章。
:::

## SSR 构建目标 {#ssr-target}

SSR 构建的默认目标为 node 环境，但你也可以让服务运行在 Web Worker 上。每个平台的打包条目解析是不同的。你可以将`ssr.target` 设置为 `webworker`，以将目标配置为 Web Worker。

## SSR 构建产物 {#ssr-bundle}

在某些如 `webworker` 运行时等特殊情况中，你可能想要将你的 SSR 打包成单个 JavaScript 文件。你可以通过设置 `ssr.noExternal` 为 `true` 来启用这个行为。这将会做两件事：

* 将所有依赖视为 `noExternal`（非外部化）
* 若任何 Node.js 内置内容被引入，将抛出一个错误

## SSR Resolve Conditions

默认情况下包的入口解析将会使用 [`resolve.conditions`](../config/shared-options.md#resolve-conditions) 中设置的条件来进行 SSR 构建。你可以使用 [`ssr.resolve.conditions`](../config/ssr-options.md#ssr-resolve-conditions) 和 [`ssr.resolve.externalConditions`](../config/ssr-options.md#ssr-resolve-externalconditions) 来自定义这个行为。

## Vite CLI {#vite-cli}

CLI 命令 `$ vite dev` 和 `$ vite preview` 也可以用于 SSR 应用：你可以将你的 SSR 中间件通过 [`configureServer`](/guide/api-plugin#configureserver) 添加到开发服务器、以及通过 [`configurePreviewServer`](/guide/api-plugin#configurepreviewserver) 添加到预览服务器。

:::tip 注意
使用一个后置钩子，使得你的 SSR 中间件在 Vite 的中间件 *之后* 运行。
:::

---

---
url: /guide/features.md
---
# 功能 {#features}

对非常基础的使用来说，使用 Vite 开发和使用一个静态文件服务器并没有太大区别。然而，Vite 还通过原生 ESM 导入提供了许多主要用于打包场景的增强功能。

## npm 依赖解析和预构建 {#npm-dependency-resolving-and-pre-bundling}

原生 ES 导入不支持下面这样的裸模块导入：

```js
import { someMethod } from 'my-dep'
```

上面的代码会在浏览器中抛出一个错误。Vite 将会检测到所有被加载的源文件中的此类裸模块导入，并执行以下操作:

1. [预构建](./dep-pre-bundling) 它们可以提高页面加载速度，并将 CommonJS / UMD 转换为 ESM 格式。预构建这一步由 [esbuild](http://esbuild.github.io/) 执行，这使得 Vite 的冷启动时间比任何基于 JavaScript 的打包器都要快得多。

2. 重写导入为合法的 URL，例如 `/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd` 以便浏览器能够正确导入它们。

**依赖是强缓存的**

Vite 通过 HTTP 头来缓存请求得到的依赖，所以如果你想要编辑或调试一个依赖，请按照 [这里](./dep-pre-bundling#浏览器缓存) 的步骤操作。

## 模块热替换 {#hot-module-replacement}

Vite 提供了一套原生 ESM 的 [HMR API](./api-hmr)。 具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。Vite 内置了 HMR 到 [Vue 单文件组件（SFC）](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) 和 [React Fast Refresh](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react) 中。也通过 [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite) 对 Preact 实现了官方集成。

注意，你不需要手动设置这些 —— 当你通过 [`create-vite`](./) 创建应用程序时，所选模板已经为你预先配置了这些。

## TypeScript {#typescript}

Vite 天然支持引入 `.ts` 文件。

### 仅执行转译 {#transpile-only}

请注意，Vite 仅执行 `.ts` 文件的转译工作，**并不执行** 任何类型检查。并假定类型检查已经被你的 IDE 或构建过程处理了。

Vite 之所以不把类型检查作为转换过程的一部分，是因为这两项工作在本质上是不同的。转译可以在每个文件的基础上进行，与 Vite 的按需编译模式完全吻合。相比之下，类型检查需要了解整个模块图。把类型检查塞进 Vite 的转换管道，将不可避免地损害 Vite 的速度优势。

Vite 的工作是尽可能快地将源模块转化为可以在浏览器中运行的形式。为此，我们建议将静态分析检查与 Vite 的转换管道分开。这一原则也适用于其他静态分析检查，例如 ESLint。

* 在构建生产版本时，你可以在 Vite 的构建命令之外运行 `tsc --noEmit`。

* 在开发时，如果你需要更多的 IDE 提示，我们建议在一个单独的进程中运行 `tsc --noEmit --watch`，或者如果你喜欢在浏览器中直接看到上报的类型错误，可以使用 [vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker)。

Vite 使用 [esbuild](https://github.com/evanw/esbuild) 将 TypeScript 转译到 JavaScript，约是 `tsc` 速度的 20~30 倍，同时 HMR 更新反映到浏览器的时间小于 50ms。

使用 [仅含类型的导入和导出](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) 形式的语法可以避免潜在的 “仅含类型的导入被不正确打包” 的问题，写法示例如下：

```ts
import type { T } from 'only/types'
export type { T }
```

### TypeScript 编译器选项 {#typescript-compiler-options}

`tsconfig.json` 中 `compilerOptions` 下的一些配置项需要特别注意。

#### `isolatedModules`

* [TypeScript 文档](https://www.typescriptlang.org/tsconfig#isolatedModules)

应该设置为 `true`。

这是因为 `esbuild` 只执行没有类型信息的转译，它并不支持某些特性，如 `const enum` 和隐式类型导入。

你必须在 `tsconfig.json` 中的 `compilerOptions` 下设置 `"isolatedModules": true`。如此做，TS 会警告你不要使用隔离（isolated）转译的功能。

如果一个依赖项和 `"isolatedModules": true` 不兼容的话，你可以在上游仓库修复好之前暂时使用 `"skipLibCheck": true` 来缓解这个错误。

#### `useDefineForClassFields`

* [TypeScript 文档](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)

如果 TypeScript 的 target 是 `ES2022` 或更高版本，包括 `ESNext`，那么默认值将为 `true`。这与 [TypeScript 4.3.2 及以后版本的行为](https://github.com/microsoft/TypeScript/pull/42663) 保持一致。
若设了其他 TypeScript target，则本项会默认为 `false`.

`true` 是标准的 ECMAScript 运行时行为。

如果你正在使用一个严重依赖 class fields 的库，请注意该库对此选项的预期设置。
虽然大多数库期望 `"useDefineForClassFields": true`，但如果你的库不支持它，你可以明确地将 `useDefineForClassFields` 设置为 `false`。

#### `target` {#target}

* [TypeScript 文档](https://www.typescriptlang.org/tsconfig#target)

Vite 忽略 `tsconfig.json` 中的 `target` 值，遵循与 `esbuild` 相同的行为。

要在开发中指定目标，可使用 [`esbuild.target`](/config/shared-options.html#esbuild) 选项，默认值为 `esnext`，以实现最小的转译。在构建中，[`build.target`](/config/build-options.html#build-target) 选项优先于 `esbuild.target`，如有需要也可以进行设置。

::: warning `useDefineForClassFields`

如果 `target` 不是 `ESNext` 或 `ES2022` 或更新版本，或者没有 `tsconfig.json` 文件，`useDefineForClassFields` 将默认为 `false`，这可能会导致默认的 `esbuild.target` 值为 `esnext` 的问题。它可能会转译为 [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility)，这在你的浏览器中可能不被支持。

因此，建议将 `target` 设置为 `ESNext` 或 `ES2022` 或更新版本，或者在配置 `tsconfig.json` 时将 `useDefineForClassFields` 显式设置为 `true`。
:::

#### 影响构建结果的其他编译器选项 {#other-compiler-options-affecting-the-build-result}

* [`extends`](https://www.typescriptlang.org/tsconfig#extends)
* [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)
* [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)
* [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax)
* [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)
* [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)
* [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)
* [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)
* [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)
* [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)

::: tip `skipLibCheck`
Vite 启动模板默认情况下会设置 `"skipLibCheck": "true"`，以避免对依赖项进行类型检查，因为它们可能只支持特定版本和配置的 TypeScript。你可以在 [vuejs/vue-cli#5688](https://github.com/vuejs/vue-cli/pull/5688) 了解更多信息。
:::

### 客户端类型 {#client-types}

Vite 默认的类型定义是写给它的 Node.js API 的。要将其补充到一个 Vite 应用的客户端代码环境中，请添加一个 `d.ts` 声明文件：

```typescript
/// <reference types="vite/client" />
```

::: details 使用 `compilerOptions.types`

或者，你也可以将 `vite/client` 添加到 `tsconfig.json` 中的 `compilerOptions.types` 下：

```json [tsconfig.json]
{
  "compilerOptions": {
    "types": ["vite/client", "some-other-global-lib"]
  }
}
```

需要注意的是，如果指定了 [`compilerOptions.types`](https://www.typescriptlang.org/tsconfig#types)，则只有这些包会被包含在全局作用域内（而不是所有的“@types”包）。

:::

`vite/client` 会提供以下类型定义补充：

* 资源导入 (例如：导入一个 `.svg` 文件)
* `import.meta.env` 上 Vite 注入的 [常量](./env-and-mode#env-variables) 的类型定义
* `import.meta.hot` 上的 [HMR API](./api-hmr) 类型定义

::: tip
要覆盖默认的类型定义，请添加一个包含你所定义类型的文件，请在三斜线注释 reference `vite/client` 前添加定义。

例如，要为 React 组件中的 `*.svg` 文件定义类型：

* `vite-env-override.d.ts` (the file that contains your typings):
  ```ts
  declare module '*.svg' {
    const content: React.FC<React.SVGProps<SVGElement>>
    export default content
  }
  ```
* The file containing the reference to `vite/client`:
  ```ts
  /// <reference types="./vite-env-override.d.ts" />
  /// <reference types="vite/client" />
  ```

:::

## HTML {#html}

HTML 文件位于 Vite 项目的[最前端和中心](/guide/#index-html-and-project-root)，作为应用程序的入口点，可轻松构建单页和[多页应用程序](/guide/build.html#multi-page-app)。

项目根目录中的任何 HTML 文件都可以通过各自的目录路径直接访问：

* `<root>/index.html` -> `http://localhost:5173/`
* `<root>/about.html` -> `http://localhost:5173/about.html`
* `<root>/blog/index.html` -> `http://localhost:5173/blog/index.html`

由 HTML 元素引用的资源，例如 `<script type="module" src>` 和 `<link href>`，会作为应用的一部分进行处理和打包。支持的完整元素列表如下：

* `<audio src>`
* `<embed src>`
* `<img src>` 和 `<img srcset>`
* `<image src>`
* `<input src>`
* `<link href>` 和 `<link imagesrcset>`
* `<object data>`
* `<script type="module" src>`
* `<source src>` 和 `<source srcset>`
* `<track src>`
* `<use href>` 和 `<use xlink:href>`
* `<video src>` 和 `<video poster>`
* `<meta content>`
  * 仅当 `name` 属性匹配以下值时：`msapplication-tileimage`，`msapplication-square70x70logo`，`msapplication-square150x150logo`，`msapplication-wide310x150logo`，`msapplication-square310x310logo`，`msapplication-config`，或 `twitter:image`
  * 或仅当 `property` 属性匹配以下值时：`og:image`，`og:image:url`，`og:image:secure_url`，`og:audio`，`og:audio:secure_url`，`og:video`，或 `og:video:secure_url`

```html {4-5,8-9}
<!doctype html>
<html>
  <head>
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/src/styles.css" />
  </head>
  <body>
    <img src="/src/images/logo.svg" alt="logo" />
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

要退出对某些元素的 HTML 处理，可以在元素上添加 `vite-ignore` 属性，这在引用外部 assets 或 CDN 时非常有用。

## 框架支持 {#frameworks}

所有现代框架都已和 Vite 集成。大多数框架插件由各自的框架团队维护，唯有官方的 Vue 和 React Vite 插件由 Vite 组织维护。

* Vue 支持：[@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)
* Vue JSX 支持：[@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)
* React 支持：[@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react)
* React 使用 SWC 的支持：[@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc)

查看 [插件指南](/plugins/) 了解更多信息。

## JSX {#jsx}

`.jsx` 和 `.tsx` 文件同样开箱即用。JSX 的转译同样是通过 [esbuild](https://esbuild.github.io)。

你选择的框架已经可以开箱即用地配置 JSX（例如，Vue 用户应使用官方的 [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) 插件，它提供了 Vue 3 特定的功能，包括 HMR，全局组件解析，指令和插槽）。

如果你使用自己的框架运行 JSX，可以使用 [`esbuild` 选项](/config/shared-options.md#esbuild) 来配置自定义的 `jsxFactory` 和 `jsxFragment`。例如，Preact 插件会使用：

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment',
  },
})
```

更多细节详见 [esbuild 文档](https://esbuild.github.io/content-types/#jsx).

你可以使用 `jsxInject`（这是一个仅在 Vite 中使用的选项）为 JSX 注入 helper，以避免手动导入：

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxInject: `import React from 'react'`,
  },
})
```

## CSS {#css}

导入 `.css` 文件将会把内容插入到 `<style>` 标签中，同时也带有 HMR 支持。

### `@import` 内联和变基 {#import-inlining-and-rebasing}

Vite 通过 `postcss-import` 预配置支持了 CSS `@import` 内联，Vite 的路径别名也遵从 CSS `@import`。换句话说，所有 CSS `url()` 引用，即使导入的文件在不同的目录中，也总是自动变基，以确保正确性。

Sass 和 Less 文件也支持 `@import` 别名和 URL 变基（具体请参阅 [CSS 预处理器](#css-pre-processors)）。

### PostCSS {#postcss}

如果项目包含有效的 PostCSS 配置 (任何受 [postcss-load-config](https://github.com/postcss/postcss-load-config) 支持的格式，例如 `postcss.config.js`)，它将会自动应用于所有已导入的 CSS。

请注意，CSS 最小化压缩将在 PostCSS 之后运行，并会使用 [`build.cssTarget`](/config/build-options.md#build-csstarget) 选项。

### CSS Modules {#css-modules}

任何以 `.module.css` 为后缀名的 CSS 文件都被认为是一个 [CSS modules 文件](https://github.com/css-modules/css-modules)。导入这样的文件会返回一个相应的模块对象：

```css [example.module.css]
.red {
  color: red;
}
```

```js twoslash
import 'vite/client'
// ---cut---
import classes from './example.module.css'
document.getElementById('foo').className = classes.red
```

CSS modules 行为可以通过 [`css.modules` 选项](/config/shared-options.md#css-modules) 进行配置。

如果 `css.modules.localsConvention` 设置开启了 camelCase 格式变量名转换（例如 `localsConvention: 'camelCaseOnly'`），你还可以使用按名导入。

```js twoslash
import 'vite/client'
// ---cut---
// .apply-color -> applyColor
import { applyColor } from './example.module.css'
document.getElementById('foo').className = applyColor
```

### CSS 预处理器 {#css-pre-processors}

由于 Vite 的目标仅为现代浏览器，因此建议使用原生 CSS 变量和实现 CSSWG 草案的 PostCSS 插件（例如 [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting)）来编写简单的、符合未来标准的 CSS。

话虽如此，但 Vite 也同时提供了对 `.scss`，`.sass`，`.less`，`.styl` 和 `.stylus` 文件的内置支持。没有必要为它们安装特定的 Vite 插件，但必须安装相应的预处理器依赖：

```bash
# .scss 和 .sass
npm add -D sass-embedded # 或 sass

# .less
npm add -D less

# .styl 和 .stylus
npm add -D stylus
```

如果使用的是单文件组件，可以通过 `<style lang="sass">`（或其他预处理器）自动开启。

Vite 为 Sass 和 Less 改进了 `@import` 解析，以保证 Vite 别名也能被使用。另外，`url()` 中的相对路径引用的，与根文件不同目录中的 Sass/Less 文件会自动变基以保证正确性。

由于 Stylus API 限制，`@import` 别名和 URL 变基不支持 Stylus。

你还可以通过在文件扩展名前加上 `.module` 来结合使用 CSS modules 和预处理器，例如 `style.module.scss`。

### 禁用 CSS 注入页面 {#disabling-css-injection-into-the-page}

自动注入 CSS 内容的行为可以通过 `?inline` 参数来关闭。在关闭时，被处理过的 CSS 字符串将会作为该模块的默认导出，但样式并没有被注入到页面中。

```js twoslash
import 'vite/client'
// ---cut---
import './foo.css' // 样式将会注入页面
import otherStyles from './bar.css?inline' // 样式不会注入页面
```

::: tip 注意
自 Vite 5 起，CSS 文件的默认导入和按名导入（例如 `import style from './foo.css'`）将被移除。请使用 `?inline` 参数代替。
:::

### Lightning CSS

从 Vite 4.4 开始，已经实验性地支持 [Lightning CSS](https://lightningcss.dev/)。可以通过在配置文件中添加 [`css.transformer: 'lightningcss'`](../config/shared-options.md#css-transformer) 并安装可选的 [`lightningcss`](https://www.npmjs.com/package/lightningcss) 依赖项来选择使用它：

```bash
npm add -D lightningcss
```

如果启用，CSS 文件将由 Lightning CSS 处理，而不是 PostCSS。可以将 Lightning CSS 的选项传递给 [`css.lightningcss`](../config/shared-options.md#css-lightningcss) 选项来配置。

要配置 CSS Modules，需要使用 [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) 而不是 [`css.modules`](../config/shared-options.md#css-modules)（后者是用于配置 PostCSS 处理 CSS Modules 的方式）。

默认情况下，Vite 使用 esbuild 来压缩 CSS。通过 [`build.cssMinify: 'lightningcss'`](../config/build-options.md#build-cssminify) 进行配置，也可以将 Lightning CSS 用作 CSS 最小化压缩。

## 静态资源处理 {#static-assets}

导入一个静态资源会返回解析后的 URL：

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl
```

添加一些特殊的查询参数可以更改资源被引入的方式：

```js twoslash
import 'vite/client'
// ---cut---
// 显式加载资源为一个 URL
import assetAsURL from './asset.js?url'
```

```js twoslash
import 'vite/client'
// ---cut---
// 以字符串形式加载资源
import assetAsString from './shader.glsl?raw'
```

```js twoslash
import 'vite/client'
// ---cut---
// 加载为 Web Worker
import Worker from './worker.js?worker'
```

```js twoslash
import 'vite/client'
// ---cut---
// 在构建时 Web Worker 内联为 base64 字符串
import InlineWorker from './worker.js?worker&inline'
```

更多细节请见 [静态资源处理](./assets)。

## JSON {#json}

JSON 可以被直接导入 —— 同样支持具名导入：

```js twoslash
import 'vite/client'
// ---cut---
// 导入整个对象
import json from './example.json'
// 对一个根字段使用具名导入 —— 有效帮助 treeshaking！
import { field } from './example.json'
```

## Glob 导入 {#glob-import}

Vite 支持使用特殊的 `import.meta.glob` 函数从文件系统导入多个模块：

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js')
```

以上将会被转译为下面的样子：

```js
// vite 生成的代码
const modules = {
  './dir/bar.js': () => import('./dir/bar.js'),
  './dir/foo.js': () => import('./dir/foo.js'),
}
```

你可以遍历 `modules` 对象的 key 值来访问相应的模块：

```js
for (const path in modules) {
  modules[path]().then((mod) => {
    console.log(path, mod)
  })
}
```

匹配到的文件默认是懒加载的，通过动态导入实现，并会在构建时分离为独立的 chunk。如果你倾向于直接引入所有的模块（例如依赖于这些模块中的副作用首先被应用），你可以传入 `{ eager: true }` 作为第二个参数：

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', { eager: true })
```

以上会被转译为下面的样子：

```js
// vite 生成的代码
import * as __vite_glob_0_0 from './dir/bar.js'
import * as __vite_glob_0_1 from './dir/foo.js'
const modules = {
  './dir/bar.js': __vite_glob_0_0,
  './dir/foo.js': __vite_glob_0_1,
}
```

### 多个匹配模式 {#multiple-patterns}

第一个参数可以是一个 glob 数组，例如：

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob(['./dir/*.js', './another/*.js'])
```

### 反面匹配模式 {#negative-patterns}

同样也支持反面 glob 匹配模式（以 `!` 作为前缀）。若要忽略结果中的一些文件，你可以添加“排除匹配模式”作为第一个参数：

```js twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])
```

```js
// vite 生成的代码
const modules = {
  './dir/foo.js': () => import('./dir/foo.js'),
}
```

#### 具名导入 {#named-imports}

也可能你只想要导入模块中的部分内容，那么可以利用 `import` 选项。

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', { import: 'setup' })
```

```ts
// vite 生成的代码
const modules = {
  './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),
  './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),
}
```

当与 `eager` 一同存在时，甚至可以对这些模块进行 tree-shaking。

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', {
  import: 'setup',
  eager: true,
})
```

```ts
// vite 生成的代码
import { setup as __vite_glob_0_0 } from './dir/bar.js'
import { setup as __vite_glob_0_1 } from './dir/foo.js'
const modules = {
  './dir/bar.js': __vite_glob_0_0,
  './dir/foo.js': __vite_glob_0_1,
}
```

设置 `import` 为 `default` 可以加载默认导出。

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', {
  import: 'default',
  eager: true,
})
```

```ts
// vite 生成的代码
import { default as __vite_glob_0_0 } from './dir/bar.js'
import { default as __vite_glob_0_1 } from './dir/foo.js'
const modules = {
  './dir/bar.js': __vite_glob_0_0,
  './dir/foo.js': __vite_glob_0_1,
}
```

#### 自定义查询 {#custom-queries}

你也可以使用 `query` 选项来提供对导入的自定义查询，比如，可以将资源 [作为字符串引入](/guide/assets#importing-asset-as-string) 或者 [作为 URL 引入](/guide/assets#importing-asset-as-url) ：

```ts twoslash
import 'vite/client'
// ---cut---
const moduleStrings = import.meta.glob('./dir/*.svg', {
  query: '?raw',
  import: 'default',
})
const moduleUrls = import.meta.glob('./dir/*.svg', {
  query: '?url',
  import: 'default',
})
```

```ts
// vite 生成的代码
const moduleStrings = {
  './dir/bar.svg': () => import('./dir/bar.svg?raw').then((m) => m['default']),
  './dir/foo.svg': () => import('./dir/foo.svg?raw').then((m) => m['default']),
}
const moduleUrls = {
  './dir/bar.svg': () => import('./dir/bar.svg?url').then((m) => m['default']),
  './dir/foo.svg': () => import('./dir/foo.svg?url').then((m) => m['default']),
}
```

你还可以为其他插件提供定制化的查询参数：

```ts twoslash
import 'vite/client'
// ---cut---
const modules = import.meta.glob('./dir/*.js', {
  query: { foo: 'bar', bar: true },
})
```

### Glob 导入注意事项 {#glob-import-caveats}

请注意：

* 这只是一个 Vite 独有的功能而不是一个 Web 或 ES 标准
* 该 Glob 模式会被当成导入标识符：必须是相对路径（以 `./` 开头）或绝对路径（以 `/` 开头，相对于项目根目录解析）或一个别名路径（请看 [`resolve.alias` 选项](/config/shared-options.md#resolve-alias))。
* Glob 匹配是使用 [`tinyglobby`](https://github.com/SuperchupuDev/tinyglobby) 来实现的 —— 阅读它的文档来查阅 [支持的 Glob 模式](https://github.com/mrmlnc/fast-glob#pattern-syntax)。
* 你还需注意，所有 `import.meta.glob` 的参数都必须以字面量传入。你 **不** 可以在其中使用变量或表达式。

## 动态导入 {#dynamic-import}

和 [glob 导入](#glob-import) 类似，Vite 也支持带变量的动态导入。

```ts
const module = await import(`./dir/${file}.js`)
```

注意变量仅代表一层深的文件名。如果 `file` 是 `foo/bar`，导入将会失败。对于更进阶的使用详情，你可以使用 [glob 导入](#glob-import) 功能。

## WebAssembly {#webassembly}

预编译的 `.wasm` 文件可以通过 `?init` 来导入。
默认导出一个初始化函数，返回值为所导出 [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance) 实例对象的 Promise：

```js twoslash
import 'vite/client'
// ---cut---
import init from './example.wasm?init'

init().then((instance) => {
  instance.exports.test()
})
```

`init` 函数还可以将传递给 [`WebAssembly.instantiate`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate) 的导入对象作为其第二个参数：

```js twoslash
import 'vite/client'
import init from './example.wasm?init'
// ---cut---
init({
  imports: {
    someFunc: () => {
      /* ... */
    },
  },
}).then(() => {
  /* ... */
})
```

在生产构建当中，体积小于 `assetInlineLimit` 的 `.wasm` 文件将会被内联为 base64 字符串。否则，它们将被视为 [静态资源](./assets) ，并按需获取。

::: tip 注意
[对 WebAssembly 的 ES 模块集成提案](https://github.com/WebAssembly/esm-integration) 尚未支持。
请使用 [`vite-plugin-wasm`](https://github.com/Menci/vite-plugin-wasm) 或其他社区上的插件来处理。
:::

### 访问 WebAssembly 模块 {#accessing-the-webassembly-module}

如果需要访问 `Module` 对象，例如将它多次实例化，可以使用 [显式 URL 引入](./assets#explicit-url-imports) 来解析资源，然后执行实例化：

```js twoslash
import 'vite/client'
// ---cut---
import wasmUrl from 'foo.wasm?url'

const main = async () => {
  const responsePromise = fetch(wasmUrl)
  const { module, instance } =
    await WebAssembly.instantiateStreaming(responsePromise)
  /* ... */
}

main()
```

### 在 Node.js 中获取模块 {#fetching-the-module-in-node-js}

在 SSR 中，作为 `?init` 导入的 `fetch()` 可能会失败，导致 `TypeError: Invalid URL` 报错。
请参见问题 [在 SSR 中支持 wasm](https://github.com/vitejs/vite/issues/8882)。

以下是一种替代方案，假设项目根目录在当前目录：

```js twoslash
import 'vite/client'
// ---cut---
import wasmUrl from 'foo.wasm?url'
import { readFile } from 'node:fs/promises'

const main = async () => {
  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default
  const buffer = await readFile('.' + resolvedUrl)
  const { instance } = await WebAssembly.instantiate(buffer, {
    /* ... */
  })
  /* ... */
}

main()
```

## Web Workers {#web-workers}

### 通过构造器导入 {#import-with-constructors}

一个 Web Worker 可以使用 [`new Worker()`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) 和 [`new SharedWorker()`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker) 导入。与 worker 后缀相比，这种语法更接近于标准，是创建 worker 的 **推荐** 方式。

```ts
const worker = new Worker(new URL('./worker.js', import.meta.url))
```

worker 构造函数会接受可以用来创建 “模块” worker 的选项：

```ts
const worker = new Worker(new URL('./worker.js', import.meta.url), {
  type: 'module',
})
```

只有在 `new Worker()` 声明中直接使用 `new URL()` 构造函数时，work 线程的检测才会生效。此外，所有选项参数必须是静态值（即字符串字面量）。

### 带有查询后缀的导入 {#import-with-query-suffixes}

你可以在导入请求上添加 `?worker` 或 `?sharedworker` 查询参数来直接导入一个 web worker 脚本。默认导出会是一个自定义 worker 的构造函数：

```js twoslash
import 'vite/client'
// ---cut---
import MyWorker from './worker?worker'

const worker = new MyWorker()
```

这个 worker 脚本也可以使用 ESM `import` 语句而不是 `importScripts()`。**注意**：在开发时，这依赖于 [浏览器原生支持](https://caniuse.com/?search=module%20worker)，但是在生产构建中，它会被编译掉。

默认情况下，worker 脚本将在生产构建中编译成单独的 chunk。如果你想将 worker 内联为 base64 字符串，请添加 `inline` 查询参数：

```js twoslash
import 'vite/client'
// ---cut---
import MyWorker from './worker?worker&inline'
```

如果你想要以一个 URL 的形式读取该 worker，请添加 `url` 这个 query：

```js twoslash
import 'vite/client'
// ---cut---
import MyWorker from './worker?worker&url'
```

关于如何配置打包全部 worker，可以查看 [Worker 选项](/config/worker-options.md) 了解更多相关细节。

## 内容安全策略（CSP） {#content-security-policy-csp}

由于 Vite 的内部机制，为了部署 CSP 必须设置某些指令或配置。

### [`'nonce-{RANDOM}'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value)

当设置了 [`html.cspNonce`](/config/shared-options#html-cspnonce) 时，Vite 会为任何 `<script>` 和 `<style>` 标签，以及样式表和模块预加载的 `<link>` 标签添加一个 nonce 属性。此外，当设置了这个选项时，Vite 会注入一个 meta 标签 (`<meta property="csp-nonce" nonce="PLACEHOLDER" />`)。

带有 `property="csp-nonce"` 的 meta 标签的 nonce 值将在开发和构建后的必要时刻被 Vite 使用。

:::warning
确保为每个请求替换的占位符为唯一值。这对于防止绕过资源的策略非常重要，否则很容易被绕过。
:::

### [`data:`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20\(not%20recommended\).-,data%3A,-Allows%20data%3A)

默认情况下，Vite 在构建过程中会将小型资源内联为 data URI。允许 `data:` 用于相关指令（例如 [`img-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src)，[`font-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)），或者，通过设置 [`build.assetsInlineLimit: 0`](/config/build-options#build-assetsinlinelimit) 来禁用它是必要的。

:::warning
不要为 [`script-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) 允许 `data:`。这将会允许注入任何脚本。
:::

## 构建优化 {#build-optimizations}

> 下面所罗列的功能会自动应用为构建过程的一部分，除非你想禁用它们，否则没有必要显式配置。

### CSS 代码分割 {#css-code-splitting}

Vite 会自动地将一个异步 chunk 模块中使用到的 CSS 代码抽取出来并为其生成一个单独的文件。这个 CSS 文件将在该异步 chunk 加载完成时自动通过一个 `<link>` 标签载入，该异步 chunk 会保证只在 CSS 加载完毕后再执行，避免发生 [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.) 。

如果你更倾向于将所有的 CSS 抽取到一个文件中，你可以通过设置 [`build.cssCodeSplit`](/config/build-options.md#build-csscodesplit) 为 `false` 来禁用 CSS 代码分割。

### 预加载指令生成 {#preload-directives-generation}

Vite 会为入口 chunk 和它们在打包出的 HTML 中的直接引入自动生成 `<link rel="modulepreload">` 指令。

### 异步 Chunk 加载优化 {#async-chunk-loading-optimization}

在实际项目中，Rollup 通常会生成 “共用” chunk —— 被两个或以上的其他 chunk 共享的 chunk。与动态导入相结合，会很容易出现下面这种场景：

在无优化的情境下，当异步 chunk `A` 被导入时，浏览器将必须请求和解析 `A`，然后它才能弄清楚它也需要共用 chunk `C`。这会导致额外的网络往返：

```
Entry ---> A ---> C
```

Vite 将使用一个预加载步骤自动重写代码，来分割动态导入调用，以实现当 `A` 被请求时，`C` 也将 **同时** 被请求：

```
Entry ---> (A + C)
```

`C` 也可能有更深的导入，在未优化的场景中，这会导致更多的网络往返。Vite 的优化会跟踪所有的直接导入，无论导入的深度如何，都能够完全消除不必要的往返。

---

---
url: /config/shared-options.md
---
# 共享选项 {#shared-options}

除非另有说明，本节中的选项适用于所有开发、构建和预览。

## root

* **类型：** `string`
* **默认：** `process.cwd()`

项目根目录（`index.html` 文件所在的位置）。可以是一个绝对路径，或者一个相对于该配置文件本身的相对路径。

更多细节请见 [项目根目录](/guide/#index-html-and-project-root)。

## base {#base}

* **类型：** `string`
* **默认：** `/`
* **相关：** [`server.origin`](/config/server-options.md#server-origin)

开发或生产环境服务的公共基础路径。合法的值包括以下几种：

* 绝对 URL 路径名，例如 `/foo/`
* 完整的 URL，例如 `https://bar.com/foo/ `（域名部分在开发环境中不会被使用，因此该值与 `/foo/` 相同）
* 空字符串或 `./`（用于嵌入形式的开发）

更多信息详见 [公共基础路径](/guide/build#public-base-path)。

## mode {#mode}

* **类型：** `string`
* **默认：** `'development'` 用于开发，`'production'` 用于构建

在配置中指明将会把 **serve 和 build** 时的模式 **都** 覆盖掉。也可以通过命令行 `--mode` 选项来重写。

查看 [环境变量与模式](/guide/env-and-mode) 章节获取更多细节。

## define {#define}

* **类型：** `Record<string, any>`

定义全局常量替换方式。其中每项在开发环境下会被定义在全局，而在构建时被静态替换。

Vite 使用 [esbuild define](https://esbuild.github.io/api/#define) 来进行替换，因此值的表达式必须是一个包含 JSON 可序列化值（null、boolean、number、string、array 或 object）或单一标识符的字符串。对于非字符串值，Vite 将自动使用 `JSON.stringify` 将其转换为字符串。

**示例：**

```js
export default defineConfig({
  define: {
    __APP_VERSION__: JSON.stringify('v1.0.0'),
    __API_URL__: 'window.__backend_api_url',
  },
})
```

::: tip NOTE
对于使用 TypeScript 的开发者来说，请确保在 `env.d.ts` 或 `vite-env.d.ts` 文件中添加类型声明，以获得类型检查以及代码提示。

示例：

```ts
// vite-env.d.ts
declare const __APP_VERSION__: string
```

:::

## plugins

* **类型：** `(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[]`

需要用到的插件数组。Falsy 虚值的插件将被忽略，插件数组将被扁平化（flatten）。查看 [插件 API](/guide/api-plugin) 获取 Vite 插件的更多细节。

## publicDir {#publicdir}

* **类型：** `string | false`
* **默认：** `"public"`

作为静态资源服务的文件夹。该目录中的文件在开发期间在 `/` 处提供，并在构建期间复制到 `outDir` 的根目录，并且始终按原样提供或复制而无需进行转换。该值可以是文件系统的绝对路径，也可以是相对于项目根目录的相对路径。

将 `publicDir` 设定为 `false` 可以关闭此项功能。

欲了解更多，请参阅 [`public` 目录](/guide/assets#the-public-directory)。

## cacheDir {#cachedir}

* **类型：** `string`
* **默认：** `"node_modules/.vite"`

存储缓存文件的目录。此目录下会存储预打包的依赖项或 vite 生成的某些缓存文件，使用缓存可以提高性能。如需重新生成缓存文件，你可以使用 `--force` 命令行选项或手动删除目录。此选项的值可以是文件的绝对路径，也可以是以项目根目录为基准的相对路径。当没有检测到 package.json 时，则默认为 `.vite`。

## resolve.alias {#resolve-alias}

* **类型：**
  `Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`

将会被传递到 `@rollup/plugin-alias` 作为 [entries 的选项](https://github.com/rollup/plugins/tree/master/packages/alias#entries)。也可以是一个对象，或一个 `{ find, replacement, customResolver }` 的数组。

当使用文件系统路径的别名时，请始终使用绝对路径。相对路径的别名值会原封不动地被使用，因此无法被正常解析。

更高级的自定义解析方法可以通过 [插件](/guide/api-plugin) 实现。

::: warning 在 SSR 中使用
如果你已经为 [SSR 外部化的依赖](/guide/ssr.md#ssr-externals) 配置了别名，你可能想要为真实的 `node_modules` 包配别名。[Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) 和 [pnpm](https://pnpm.io/aliases/) 都支持通过 `npm:` 前缀配置别名。
:::

## resolve.dedupe {#resolve-dedupe}

* **类型：** `string[]`

如果你在你的应用程序中有相同依赖的副本（比如 monorepos），请使用此选项强制 Vite 始终将列出的依赖项解析为同一副本（从项目根目录）。

:::warning SSR + ESM
对于服务端渲染构建，配置项 `build.rollupOptions.output` 为 ESM 构建输出时去重过程将不工作。一个替代方案是先使用 CJS 构建输出，直到 ESM 在插件中有了更好的模块加载支持。
:::

## resolve.conditions {#resolve-conditions}

* **类型：** `string[]`
* **默认：** `['module', 'browser', 'development|production']` (`defaultClientConditions`)

解决程序包中 [情景导出](https://nodejs.org/api/packages.html#packages_conditional_exports) 时的其他允许条件。

一个带有情景导出的包可能在它的 `package.json` 中有以下 `exports` 字段：

```json
{
  "exports": {
    ".": {
      "import": "./index.esm.js",
      "require": "./index.cjs.js"
    }
  }
}
```

在这里，`import` 和 `require` 被称为“情景”。情景可以嵌套，并且应该从最特定的到最不特定的指定。

`development|production` 是一个特殊值，根据 `process.env.NODE_ENV` 的值替换为 `production` 或  `development` 。如果 `process.env.NODE_ENV === 'production'`，则替换为 `production`，否则替换为 `development`。

请注意，如果符合要求，`import`，`require`，`default` 始终会被应用。

## resolve.mainFields {#resolve-mainfields}

* **类型：** `string[]`
* **默认：** `['browser', 'module', 'jsnext:main', 'jsnext']` (`defaultClientMainFields`)

`package.json` 中，在解析包的入口点时尝试的字段列表。注意：这比从 `exports` 字段解析的情景导出优先级低：如果一个入口起点从 `exports` 成功解析，`resolve.mainFields` 将被忽略。

## resolve.extensions {#resolve-extensions}

* **类型：** `string[]`
* **默认：** `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`

导入时想要省略的扩展名列表。注意，**不** 建议忽略自定义导入类型的扩展名（例如：`.vue`），因为它会影响 IDE 和类型支持。

## resolve.preserveSymlinks {#resolve-preservesymlinks}

* **类型：** `boolean`
* **默认：** `false`

启用此选项会使 Vite 通过原始文件路径（即不跟随符号链接的路径）而不是真正的文件路径（即跟随符号链接后的路径）确定文件身份。

* **相关：** [esbuild#preserve-symlinks](https://esbuild.github.io/api/#preserve-symlinks)，[webpack#resolve.symlinks
  ](https://webpack.js.org/configuration/resolve/#resolvesymlinks)

## html.cspNonce

* **类型：** `string`
* **相关：** [内容安全策略（CSP）](/guide/features#content-security-policy-csp)

一个在生成脚本或样式标签时会用到的 nonce 值占位符。设置此值还会生成一个带有 nonce 值的 meta 标签。

## css.modules

* **类型：**
  ```ts
  interface CSSModulesOptions {
    getJSON?: (
      cssFileName: string,
      json: Record<string, string>,
      outputFileName: string,
    ) => void
    scopeBehaviour?: 'global' | 'local'
    globalModulePaths?: RegExp[]
    exportGlobals?: boolean
    generateScopedName?:
      | string
      | ((name: string, filename: string, css: string) => string)
    hashPrefix?: string
    /**
     * default: undefined
     */
    localsConvention?:
      | 'camelCase'
      | 'camelCaseOnly'
      | 'dashes'
      | 'dashesOnly'
      | ((
          originalClassName: string,
          generatedClassName: string,
          inputFile: string,
        ) => string)
  }
  ```

配置 CSS modules 的行为。选项将被传递给 [postcss-modules](https://github.com/css-modules/postcss-modules)。

当使用 [Lightning CSS](../guide/features.md#lightning-css) 时，该选项不会产生任何效果。如果要启用该选项，则应该使用 [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) 来替代。

## css.postcss {#css-postcss}

* **类型：** `string | (postcss.ProcessOptions & { plugins?: postcss.AcceptedPlugin[] })`

内联的 PostCSS 配置（格式同 `postcss.config.js`），或者一个（默认基于项目根目录的）自定义的 PostCSS 配置路径。

对内联的 PostCSS 配置，它期望接收与 `postcss.config.js` 一致的格式。但对于 `plugins` 属性有些特别，只接收使用 [数组格式](https://github.com/postcss/postcss-load-config/blob/main/README.md#array)。

搜索是使用 [postcss-load-config](https://github.com/postcss/postcss-load-config) 完成的，只有被支持的文件名才会被加载。默认情况下，不会搜索工作区根目录（或 [项目根目录](/guide/#index-html-and-project-root)，如果未找到工作区）之外的配置文件。如有必要，您可以指定根目录之外的自定义路径来加载特定的配置文件。

注意：如果提供了该内联配置，Vite 将不会搜索其他 PostCSS 配置源。

## css.preprocessorOptions {#css-preprocessoroptions}

* **类型：** `Record<string, object>`

指定传递给 CSS 预处理器的选项。文件扩展名用作选项的键。每个预处理器支持的选项可以在它们各自的文档中找到：

* `sass`/`scss`:
  * 选择要使用的 sass 应用程序接口 `api: "modern-compiler" | "modern" | "legacy"` (如果安装了`sass-embedded`，默认为`"modern-compiler"`，否则为 `"modern"`). 为获得最佳性能，建议使用 `api: "modern-compiler"` 和 `sass-embedded` 软件包。`"legacy"` API 已过时，将在 Vite 7 中移除。
  * [Options (modern)](https://sass-lang.com/documentation/js-api/interfaces/stringoptions/)
  * [Options (legacy)](https://sass-lang.com/documentation/js-api/interfaces/LegacyStringOptions).
* `less`: [选项](https://lesscss.org/usage/#less-options).
* `styl`/`stylus`: 仅支持 [`define`](https://stylus-lang.com/docs/js.html#define-name-node)，可以作为对象传递。

**示例：**

```js
export default defineConfig({
  css: {
    preprocessorOptions: {
      less: {
        math: 'parens-division',
      },
      styl: {
        define: {
          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),
        },
      },
      scss: {
        api: 'modern-compiler', // 或 "modern"，"legacy"
        importers: [
          // ...
        ],
      },
    },
  },
})
```

### css.preprocessorOptions\[extension].additionalData

* **类型：** `string | ((source: string, filename: string) => (string | { content: string; map?: SourceMap }))`

该选项可以用来为每一段样式内容添加额外的代码。但是要注意，如果你添加的是实际的样式而不仅仅是变量，那这些样式在最终的产物中会重复。

**示例：**

```js
export default defineConfig({
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `$injectedColor: orange;`,
      },
    },
  },
})
```

## css.preprocessorMaxWorkers

* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/15835)
* **类型：** `number | true`
* **默认：** `0`（不会创建任何 worker 线程，而是在主线程中运行）

如果启用了这个选项，那么 CSS 预处理器会尽可能在 worker 线程中运行。`true` 表示 CPU 数量减 1。

## css.devSourcemap {#css-devsourcemap}

* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/13845)
* **类型：** `boolean`
* **默认：** `false`

在开发过程中是否启用 sourcemap。

## css.transformer

* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/13835)
* **类型：** `'postcss' | 'lightningcss'`
* **默认：** `'postcss'`

该选项用于选择用于 CSS 处理的引擎。详细信息请查看 [Lightning CSS](../guide/features.md#lightning-css)。

::: info 重复的 `@import`
需要注意的是，postcss（postcss-import）处理重复 `@import` 的行为与浏览器是不同的。详情请参考 [postcss/postcss-import#462](https://github.com/postcss/postcss-import/issues/462)。
:::

## css.lightningcss

* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/13835)
* **类型：**

```js
import type {
  CSSModulesConfig,
  Drafts,
  Features,
  NonStandard,
  PseudoClasses,
  Targets,
} from 'lightningcss'
```

```js
{
  targets?: Targets
  include?: Features
  exclude?: Features
  drafts?: Drafts
  nonStandard?: NonStandard
  pseudoClasses?: PseudoClasses
  unusedSymbols?: string[]
  cssModules?: CSSModulesConfig,
  // ...
}
```

该选项用于配置 Lightning CSS。有关完整的转换选项，请参阅 [Lightning CSS 仓库](https://github.com/parcel-bundler/lightningcss/blob/master/node/index.d.ts)。

## json.namedExports {#json-namedexports}

* **类型：** `boolean`
* **默认：** `true`

是否支持从 `.json` 文件中进行按名导入。

## json.stringify {#json-stringify}

* **类型：** `boolean | 'auto'`
* **默认：** `'auto'`

若设置为 `true`，导入的 JSON 会被转换为 `export default JSON.parse("...")`，这样会比转译成对象字面量性能更好，尤其是当 JSON 文件较大的时候。

如果设置为 `'auto'`，只有当 [数据大于 10kB 时](https://v8.dev/blog/cost-of-javascript-2019#json:~:text=A%20good%20rule%20of%20thumb%20is%20to%20apply%20this%20technique%20for%20objects%20of%2010%20kB%20or%20larger)，才会对数据进行字符串化处理。

## esbuild {#esbuild}

* **类型：** `ESBuildOptions | false`

`ESBuildOptions` 继承自 [esbuild 转换选项](https://esbuild.github.io/api/#transform)。最常见的用例是自定义 JSX：

```js
export default defineConfig({
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment',
  },
})
```

默认情况下，esbuild 会被应用在 `ts`、`jsx`、`tsx` 文件。你可以通过 `esbuild.include` 和 `esbuild.exclude` 对要处理的文件类型进行配置，这两个配置的值可以是一个正则表达式、一个 [picomatch](https://github.com/micromatch/picomatch#globbing-features) 模式，或是一个值为这两种类型的数组。

此外，你还可以通过 `esbuild.jsxInject` 来自动为每一个被 esbuild 转换的文件注入 JSX helper。

```js
export default defineConfig({
  esbuild: {
    jsxInject: `import React from 'react'`,
  },
})
```

当 [`build.minify`](./build-options.md#build-minify) 为 `true` 时，所有最小化的优化过程都会被默认应用，要禁用它的 [某些特定方面](https://esbuild.github.io/api/#minify)，请设置 `esbuild.minifyIdentifiers`、`esbuild.minifySyntax` 或 `esbuild.minifyWhitespace` 三种选项其中任意一种为 `false`。注意 `esbuild.minify` 选项无法用于覆盖 `build.minify`。

设置为 `false` 来禁用 esbuild 转换。

## assetsInclude {#assetsinclude}

* **类型：** `string | RegExp | (string | RegExp)[]`
* **相关内容：** [静态资源处理](/guide/assets)

指定额外的 [picomatch 模式](https://github.com/micromatch/picomatch#globbing-features) 作为静态资源处理，因此：

* 当从 HTML 引用它们或直接通过 `fetch` 或 XHR 请求它们时，它们将被插件转换管道排除在外。

* 从 JavaScript 导入它们将返回解析后的 URL 字符串（如果你设置了 `enforce: 'pre'` 插件来处理不同的资产类型，这可能会被覆盖）。

内建支持的资源类型列表可以在 [这里](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts) 找到。

**示例：**

```js
export default defineConfig({
  assetsInclude: ['**/*.gltf'],
})
```

## logLevel {#loglevel}

* **类型：** `'info' | 'warn' | 'error' | 'silent'`

调整控制台输出的级别，默认为 `'info'`。

## customLogger {#customlogger}

* **类型：**
  ```ts
  interface Logger {
    info(msg: string, options?: LogOptions): void
    warn(msg: string, options?: LogOptions): void
    warnOnce(msg: string, options?: LogOptions): void
    error(msg: string, options?: LogErrorOptions): void
    clearScreen(type: LogType): void
    hasErrorLogged(error: Error | RollupError): boolean
    hasWarned: boolean
  }
  ```

使用自定义 logger 记录消息。可以使用 Vite 的 `createLogger` API 获取默认的 logger 并对其进行自定义，例如，更改消息或过滤掉某些警告。

```ts twoslash
import { createLogger, defineConfig } from 'vite'

const logger = createLogger()
const loggerWarn = logger.warn

logger.warn = (msg, options) => {
  // 忽略空 CSS 文件的警告
  if (msg.includes('vite:css') && msg.includes(' is empty')) return
  loggerWarn(msg, options)
}

export default defineConfig({
  customLogger: logger,
})
```

## clearScreen {#clearscreen}

* **类型：** `boolean`
* **默认：** `true`

设为 `false` 可以避免 Vite 清屏而错过在终端中打印某些关键信息。命令行模式下可以通过 `--clearScreen false` 设置。

## envDir {#envdir}

* **类型：** `string | false`
* **默认：** `root`

用于加载 `.env` 文件的目录。可以是一个绝对路径，也可以是相对于项目根的路径。设置为 `false` 将禁用 `.env` 文件的加载。

关于环境文件的更多信息，请参见 [这里](/guide/env-and-mode#env-files)。

## envPrefix {#envprefix}

* **类型：** `string | string[]`
* **默认：** `VITE_`

以 `envPrefix` 开头的环境变量会通过 import.meta.env 暴露在你的客户端源码中。

:::warning 安全注意事项
`envPrefix` 不应被设置为空字符串 `''`，这将暴露你所有的环境变量，导致敏感信息的意外泄漏。 检测到配置为 `''` 时 Vite 将会抛出错误.

如果你想暴露一个不含前缀的变量，可以使用 [define](#define) 选项：

```js
define: {
  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)
}
```

:::

## appType {#apptype}

* **类型：** `'spa' | 'mpa' | 'custom'`
* **默认：** `'spa'`

无论你的应用是一个单页应用（SPA）还是一个 [多页应用（MPA）](../guide/build#multi-page-app)，亦或是一个定制化应用（SSR 和自定义 HTML 处理的框架）：

* `'spa'`：包含 HTML 中间件以及使用 SPA 回退。在预览中将 [sirv](https://github.com/lukeed/sirv) 配置为 `single: true`
* `'mpa'`：包含 HTML 中间件
* `'custom'`：不包含 HTML 中间件

要了解更多，请查看 Vite 的 [SSR 指引](/guide/ssr#vite-cli)。相关内容：[`server.middlewareMode`](./server-options#server-middlewaremode)。

## future

* **类型：** `Record<string, 'warn' | undefined>`
* **默认：** [破坏性变更](/changes/)

启用未来的重大变更，为顺利迁移到 Vite 的下一个主要版本做好准备。随着新功能的开发，这个列表可能会随时进行更新、添加或移除。

请查看 [破坏性变更](/changes/) 页面，了解可能的选项详情。

---

---
url: /changes/this-environment-in-hooks.md
---
# 钩子函数中的 this.environment {#this-environment-in-hooks}

::: tip 反馈
可以在 [环境 API 讨论](https://github.com/vitejs/vite/discussions/16358) 中向我们提供反馈
:::

在 Vite 6 版本之前，只有两个环境是可用的：`client` 和 `ssr`。在 `resolveId`、`load` 和 `transform` 中的 `options.ssr` 插件钩子参数，允许插件的作者在处理插件钩子中的模块时区分这两个环境。在 Vite 6 版本中，一个 Vite 应用可以根据需要定义任意数量的命名环境。我们在插件的上下文中引入了 `this.environment`，以便在钩子中与当前模块的环境进行交互。

影响范围：`Vite 插件作者`

::: warning 即将废弃
`this.environment` 最初在 `v6.0` 版本中被引入。我们计划在 `v7.0` 版本中废弃 `options.ssr`。到那时，我们会开始建议你将你的插件迁移到新的 API。如果想识别你的使用情况，可以在你的 vite 配置文件中将 `future.removePluginHookSsrArgument` 设置为 `"warn"`。
:::

## 动机 {#motivation}

`this.environment` 不仅可以让插件钩子实现知道当前的环境名称，还可以让它访问到环境配置选项、模块图信息和转换管道（`environment.config`、`environment.moduleGraph`、`environment.transformRequest()`）。在上下文中可以使用环境实例，这让插件的作者可以避免依赖整个开发服务器（通常是在通过 `configureServer` 钩子启动时进行缓存）。

## 迁移指南 {#migration-guide}

对于现有的插件，如果想要快速迁移，可以在 `resolveId`、`load` 和 `transform` 钩子中，将 `options.ssr` 参数替换为 `this.environment.name !== 'client'`：

```ts
import { Plugin } from 'vite'

export function myPlugin(): Plugin {
  return {
    name: 'my-plugin',
    resolveId(id, importer, options) {
      const isSSR = options.ssr // [!code --]
      const isSSR = this.environment.name !== 'client' // [!code ++]

      if (isSSR) {
        // SSR 特有逻辑
      } else {
        // 客户端特有逻辑
      }
    },
  }
}
```

对于更稳定、长期的实现，插件钩子应该处理 [多个环境](/guide/api-environment.html#accessing-the-current-environment-in-hooks)，并使用细粒度的环境选项，而不是依赖于环境的名称。

---

---
url: /changes/shared-plugins-during-build.md
---
# 构建过程中的共享插件 {#shared-plugins-during-build}

::: tip 反馈
可以在 [环境 API 讨论](https://github.com/vitejs/vite/discussions/16358) 中向我们提供反馈
:::

查看 [构建过程中的共享插件](/guide/api-environment-plugins.md#shared-plugins-during-build).

影响范围：`Vite 插件作者`

::: warning 未来默认值更改
`builder.sharedConfigBuild` 最初在 `v6.0` 版本中被引入。你可以将它设置为 `true`，以此来检查你的插件与共享配置是如何配合工作的。一旦插件生态系统准备就绪，我们希望能得到关于在未来的主要版本中改变默认设置的反馈。
:::

## 动机 {#motivation}

调整开发和构建插件管道。

## 迁移指南 {#migration-guide}

为实现跨环境共享插件，插件状态必须以当前环境为关键。以下形式的插件将计算所有环境中已转换模块的数量。

```js
function CountTransformedModulesPlugin() {
  let transformedModules
  return {
    name: 'count-transformed-modules',
    buildStart() {
      transformedModules = 0
    },
    transform(id) {
      transformedModules++
    },
    buildEnd() {
      console.log(transformedModules)
    },
  }
}
```

如果我们想要计算每个环境中已转换模块的数量，我们需要维护一个映射表。

```js
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = new Map<Environment, { count: number }>()
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state.set(this.environment, { count: 0 })
    }
    transform(id) {
      state.get(this.environment).count++
    },
    buildEnd() {
      console.log(this.environment.name, state.get(this.environment).count)
    }
  }
}
```

为了简化这种模式，Vite 导出了一个 `perEnvironmentState` 助手：

```js
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = perEnvironmentState<{ count: number }>(() => ({ count: 0 }))
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state(this).count = 0
    }
    transform(id) {
      state(this).count++
    },
    buildEnd() {
      console.log(this.environment.name, state(this).count)
    }
  }
}
```

---

---
url: /guide/build.md
---
# 构建生产版本 {#building-for-production}

当需要将应用部署到生产环境时，只需运行 `vite build` 命令。默认情况下，它使用 `<root>/index.html` 作为其构建入口点，并生成能够静态部署的应用程序包。请查阅 [部署静态站点](./static-deploy) 获取常见服务的部署指引。

## 浏览器兼容性 {#browser-compatibility}

默认情况下，生产打包文件假设支持现代 JavaScript，包括原生 ES 模块[native ES Modules](https://caniuse.com/es6-module)、原生 ESM 动态导入 [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import)，以及 [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta)、[nullish coalescing](https://caniuse.com/mdn-javascript_operators_nullish_coalescing) 和 [BigInt](https://caniuse.com/bigint)。默认的浏览器支持范围是：

* Chrome >=87
* Firefox >=78
* Safari >=14
* Edge >=88

你也可以通过 [`build.target` 配置项](/config/build-options.md#build-target) 指定构建目标，最低支持 `es2015`。如果设置较低的目标值，Vite 仍然需要这些最低的浏览器支持范围，因为它依赖于[原生的 ESM 动态导入](https://caniuse.com/es6-module-dynamic-import)和 [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta)：

* Chrome >=64
* Firefox >=67
* Safari >=11.1
* Edge >=79

请注意，默认情况下 Vite 只处理语法转译，且 **不包含任何 polyfill**。你可以访问 https://cdnjs.cloudflare.com/polyfill/ ，这个网站可以根据用户的浏览器 UserAgent 字符串自动生成 polyfill 包。

传统浏览器可以通过插件 [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) 来支持，它将自动生成传统版本的 chunk 及与其相对应 ES 语言特性方面的 polyfill。兼容版的 chunk 只会在不支持原生 ESM 的浏览器中进行按需加载。

## 公共基础路径 {#public-base-path}

* 相关内容：[静态资源处理](./assets)

如果你需要在嵌套的公共路径下部署项目，只需指定 [`base` 配置项](/config/shared-options.md#base)，然后所有资源的路径都将据此配置重写。这个选项也可以通过命令行参数指定，例如 `vite build --base=/my/public/path/`。

由 JS 引入的资源 URL，CSS 中的 `url()` 引用以及 `.html` 文件中引用的资源在构建过程中都会自动调整，以适配此选项。

当然，情况也有例外，当访问过程中需要使用动态连接的 url 时，可以使用全局注入的 `import.meta.env.BASE_URL` 变量，它的值为公共基础路径。注意，这个变量在构建时会被静态替换，因此，它必须按 `import.meta.env.BASE_URL` 的原样出现（例如 `import.meta.env['BASE_URL']` 是无效的）

若想要进一步控制基础路径，请查看 [高级 base 选项](#advanced-base-options).

### 相对基础路径 {#relative-base}

如果无法提前确定基础路径，可以使用 `"base": "./"` 或 `"base": ""` 设置相对基础路径。这将使所有生成的 URL 相对于每个文件。

:::warning 使用相对基础路径时对旧浏览器的支持

使用相对基础路径需要 `import.meta` 的支持。如果你需要支持 [不支持 `import.meta` 的浏览器](https://caniuse.com/mdn-javascript_operators_import_meta)，可以使用 [`legacy` 插件](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)。

:::

## 自定义构建 {#customizing-the-build}

构建过程可以通过多种 [构建配置选项](/config/#build-options) 来自定义构建。具体来说，你可以通过 `build.rollupOptions` 直接调整底层的 [Rollup 选项](https://cn.rollupjs.org/configuration-options/)：

```js [vite.config.js]
export default defineConfig({
  build: {
    rollupOptions: {
      // https://cn.rollupjs.org/configuration-options/
    },
  },
})
```

例如，你可以使用仅在构建期间应用的插件来指定多个 Rollup 输出。

## 产物分块策略 {#chunking-strategy}

你可以通过配置 `build.rollupOptions.output.manualChunks` 来自定义 chunk 分割策略（查看 [Rollup 相应文档](https://cn.rollupjs.org/configuration-options/#output-manualchunks)）。如果你使用的是一个框架，那么请参考他们的文档来了解如何配置分割 chunk。

## 处理加载报错 {#load-error-handling}

当 Vite 加载动态导入失败时，会触发 `vite:preloadError` 事件。`event.payload` 包含原始的导入错误信息。如果调用 `event.preventDefault()`，则不会抛出错误。

```js twoslash
window.addEventListener('vite:preloadError', (event) => {
  window.location.reload() // 例如，刷新页面
})
```

当重新部署时，托管服务可能会删除之前部署的资源。因此，之前访问过您站点的用户可能会遇到导入错误。这种错误发生的原因是用户设备上运行的资源过时，并尝试导入相应的旧代码块，而这些代码块已经被删除。这个事件对于解决这种情况会很有帮助。

## 文件变化时重新构建 {#rebuild-on-files-changes}

你可以使用 `vite build --watch` 来启用 rollup 的监听器。或者，你可以直接通过 `build.watch` 调整底层的 [`WatcherOptions`](https://cn.rollupjs.org/configuration-options/#watch) 选项：

```js [vite.config.js]
export default defineConfig({
  build: {
    watch: {
      // https://cn.rollupjs.org/configuration-options/#watch
    },
  },
})
```

当启用 `--watch` 标志时，对 `vite.config.js` 的改动，以及任何要打包的文件，都将触发重新构建。

## 多页面应用模式 {#multi-page-app}

假设你有下面这样的项目文件结构

```
├── package.json
├── vite.config.js
├── index.html
├── main.js
└── nested
    ├── index.html
    └── nested.js
```

在开发过程中，简单地导航或链接到 `/nested/` - 将会按预期工作，与正常的静态文件服务器表现一致。

在构建过程中，你只需指定多个 `.html` 文件作为入口点即可：

```js twoslash [vite.config.js]
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        nested: resolve(__dirname, 'nested/index.html'),
      },
    },
  },
})
```

如果你指定了另一个根目录，请记住，在解析输入路径时，`__dirname` 的值将仍然是 vite.config.js 文件所在的目录。因此，你需要把对应入口文件的 `root` 的路径添加到 `resolve` 的参数中。

请注意，在 HTML 文件中，Vite 忽略了 `rollupOptions.input` 对象中给定的入口名称，而是在生成 dist 文件夹中的 HTML 资源文件时，使用了文件已解析的路径 ID。这确保了与开发服务器的工作方式保持一致的结构。

## 库模式 {#library-mode}

当你开发面向浏览器的库时，你可能会将大部分时间花在该库的测试/演示页面上。在 Vite 中你可以使用 `index.html` 获得如丝般顺滑的开发体验。

当这个库要进行发布构建时，请使用 [`build.lib` 配置项](/config/build-options.md#build-lib)，以确保将那些你不想打包进库的依赖进行外部化处理，例如 `vue` 或 `react`：

::: code-group

```js twoslash [vite.config.js (单入口)]
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    lib: {
      entry: resolve(__dirname, 'lib/main.js'),
      name: 'MyLib',
      // 将添加适当的扩展名后缀
      fileName: 'my-lib',
    },
    rollupOptions: {
      // 确保外部化处理那些
      // 你不想打包进库的依赖
      external: ['vue'],
      output: {
        // 在 UMD 构建模式下为这些外部化的依赖
        // 提供一个全局变量
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})
```

```js twoslash [vite.config.js (多入口)]
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    lib: {
      entry: {
        'my-lib': resolve(__dirname, 'lib/main.js'),
        secondary: resolve(__dirname, 'lib/secondary.js'),
      },
      name: 'MyLib',
    },
    rollupOptions: {
      // 确保外部化处理那些
      // 你不想打包进库的依赖
      external: ['vue'],
      output: {
        // 在 UMD 构建模式下为这些外部化的依赖
        // 提供一个全局变量
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})
```

:::

入口文件将包含可以被您的包的用户导入的导出内容：

```js [lib/main.js]
import Foo from './Foo.vue'
import Bar from './Bar.vue'
export { Foo, Bar }
```

使用如上配置运行 `vite build` 时，将会使用一套面向库的 Rollup 预设，并且将为该库提供两种构建格式：

* `es` 和 `umd` (单入口)
* `es` 和 `cjs` (多入口)

格式可通过 [`build.lib.format`](/config/build-options.md#build-lib)选项配置。

```
$ vite build
building for production...
dist/my-lib.js      0.08 kB / gzip: 0.07 kB
dist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB
```

推荐在库的 `package.json` 中使用如下格式：

::: code-group

```json [package.json (单入口)]
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.umd.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.umd.cjs"
    }
  }
}
```

```json [package.json (多入口)]
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.cjs"
    },
    "./secondary": {
      "import": "./dist/secondary.js",
      "require": "./dist/secondary.cjs"
    }
  }
}
```

:::

### CSS 支持 {#css-support}

如果您的库导入了 CSS，除了内置的 JS 文件外，它还将作为一个 CSS 文件打包在一起，例如 `dist/my-lib.css`。文件名默认为 `build.lib.fileName`，但也可以使用 [`build.lib.cssFileName`](/config/build-options.md#build-lib)进行更改。

您可以在 `package.json` 中导出 CSS 文件，以便用户导入：

```json {12}
{
  "name": "my-lib",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-lib.umd.cjs",
  "module": "./dist/my-lib.js",
  "exports": {
    ".": {
      "import": "./dist/my-lib.js",
      "require": "./dist/my-lib.umd.cjs"
    },
    "./style.css": "./dist/my-lib.css"
  }
}
```

::: tip 文件扩展名
如果 `package.json` 不包含 `"type": "module"`，Vite 会生成不同的文件后缀名以兼容 Node.js。`.js` 会变为 `.mjs` 而 `.cjs` 会变为 `.js` 。
:::

::: tip 环境变量
在库模式中，所有 [`import.meta.env.*`](./env-and-mode.md) 的使用都会在构建生产版本时被静态替换。但是，`process.env.*` 的使用不会，这样你的库的使用者就可以动态地改变它。如果这是不可取的，你可以使用 `define: { 'process.env.NODE_ENV': '"production"' }` 来静态替换它们，或者使用 [`esm-env`](https://github.com/benmccann/esm-env) 来更好地兼容打包工具和运行时。
:::

::: warning 进阶用法
库模式包括了一种简单而又有见地的配置，适用于面向浏览器和 JS 框架的库。如果你正在构建非面向浏览器的库，或需要高级构建流程，可以直接使用 [Rollup](https://cn.rollupjs.org) 或 [esbuild](https://esbuild.github.io)。
:::

## 进阶基础路径选项 {#advanced-base-options}

::: warning
该功能是实验性的，可以在这里 [提供反馈](https://github.com/vitejs/vite/discussions/13834)。
:::

对更高级的使用场景，被部署的资源和公共文件可能想要分为不同的路径，例如使用不同缓存策略的场景。
一个用户可能以三种不同的路径部署下列文件：

* 生成的入口 HTML 文件（可能会在 SSR 中被处理）
* 生成的带有 hash 值的文件（JS、CSS 以及其他文件类型，如图片）
* 拷贝的 [公共文件](assets.md#the-public-directory)

单个静态的 [基础路径](#public-base-path) 在这种场景中就不够用了。Vite 在构建时为更高级的基础路径选项提供了实验性支持，可以使用 `experimental.renderBuiltUrl`。

```ts twoslash
import type { UserConfig } from 'vite'
// prettier-ignore
const config: UserConfig = {
// ---cut-before---
experimental: {
  renderBuiltUrl(filename, { hostType }) {
    if (hostType === 'js') {
      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }
    } else {
      return { relative: true }
    }
  },
},
// ---cut-after---
}
```

如果 hash 后的资源和公共文件没有被部署在一起，可以根据该函数的第二个参数 `context` 上的字段 `type` 分别定义各个资源组的选项：

```ts twoslash
import type { UserConfig } from 'vite'
import path from 'node:path'
// prettier-ignore
const config: UserConfig = {
// ---cut-before---
experimental: {
  renderBuiltUrl(filename, { hostId, hostType, type }) {
    if (type === 'public') {
      return 'https://www.domain.com/' + filename
    } else if (path.extname(hostId) === '.js') {
      return {
        runtime: `window.__assetsPath(${JSON.stringify(filename)})`
      }
    } else {
      return 'https://cdn.domain.com/assets/' + filename
    }
  },
},
// ---cut-after---
}
```

请注意，传递的 `filename` 是一个已解码的 URL，如果函数返回了一个 URL 字符串，那么它也应该是已解码的。当 Vite 渲染 URL 时会自动处理编码。如果返回的是一个带有 `runtime` 的对象，就需要在必要的地方自行处理编码，因为运行时的代码将会按照原样呈现。

---

---
url: /config/build-options.md
---
# 构建选项 {#build-options}

除非另有说明，本节中的选项仅适用于构建。

## build.target

* **类型：** `string | string[]`
* **默认：** `'modules'`
* **相关内容：** [浏览器兼容性](/guide/build#browser-compatibility)

设置最终构建的浏览器兼容目标。默认值是一个 Vite 特有的值：`'modules'`，这是指 [支持原生 ES 模块](https://caniuse.com/es6-module)、[原生 ESM 动态导入](https://caniuse.com/es6-module-dynamic-import) 和 [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) 的浏览器。Vite 将替换 `modules` 为 `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`

另一个特殊值是 `'esnext'` —— 即假设有原生动态导入支持，并只执行最低限度的转译。

转换过程将会由 esbuild 执行，并且此值应该是一个合法的 [esbuild 目标选项](https://esbuild.github.io/api/#target)。自定义目标也可以是一个 ES 版本（例如：`es2015`）、一个浏览器版本（例如：`chrome58`）或是多个目标组成的一个数组。

注意：如果代码包含不能被 `esbuild` 安全地编译的特性，那么构建将会失败。查看 [esbuild 文档](https://esbuild.github.io/content-types/#javascript) 获取更多细节。

## build.modulePreload {#build-modulepreload}

* **类型：** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`
* **默认值：** `{ polyfill: true }`

默认情况下，一个 [模块预加载 polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) 会被自动注入。该 polyfill 会自动注入到每个 `index.html` 入口的的代理模块中。如果构建通过 `build.rollupOptions.input` 被配置为了使用非 HTML 入口的形式，那么必须要在你的自定义入口中手动引入该 polyfill：

```js
import 'vite/modulepreload-polyfill'
```

注意：此 polyfill **不适用于** [Library 模式](/guide/build#library-mode)。如果你需要支持不支持动态引入的浏览器，你应该避免在你的库中使用此选项。

此 polyfill 可以通过 `{ polyfill: false }` 来禁用。

每个动态导入要预加载的块列表将由 Vite 计算。默认情况下，在载入这些依赖时，会使用一个包含 `base` 的绝对路径。如果 `base` 是相对路径（`''` 或者 `'./'`），解析时则会使用 `import.meta.url`，以避免出现依赖于最终部署基路径的绝对路径。

目前有一个实验性功能支持使用 `resolveDependencies` 函数对依赖项列表及其路径进行细粒度控制。可以在这里 [提供反馈](https://github.com/vitejs/vite/discussions/13841)。它期望接收一个 `ResolveModulePreloadDependenciesFn` 类型的函数:

```ts
type ResolveModulePreloadDependenciesFn = (
  url: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]
```

`resolveDependencies` 函数会在每次动态导入时被调用，并包含其依赖的 chunk 列表。同时，它也会在入口 HTML 文件中导入每个 chunk 时被调用。你可以返回一个新的依赖数组，其中可以过滤掉或注入更多的依赖，或修改它们的路径。`deps` 路径是相对于 `build.outDir` 的。返回值应是对于 `build.outDir` 的相对路径。

```js twoslash
/** @type {import('vite').UserConfig} */
const config = {
  // prettier-ignore
  build: {
// ---cut-before---
modulePreload: {
  resolveDependencies: (filename, deps, { hostId, hostType }) => {
    return deps.filter(condition)
  },
},
// ---cut-after---
  },
}
```

解析得到的依赖路径可以再在之后使用 [`experimental.renderBuiltUrl`](../guide/build.md#advanced-base-options) 更改。

## build.polyfillModulePreload {#build-polyfillmodulepreload}

* **类型：** `boolean`
* **默认：** `true`
* **已废弃** 请使用 `build.modulePreload.polyfill` 替代

是否自动注入一个 [模块预加载 polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill)。

## build.outDir {#build-outdir}

* **类型：** `string`
* **默认：** `dist`

指定输出路径（相对于 [项目根目录](/guide/#index-html-and-project-root)).

## build.assetsDir {#build-assetsdir}

* **类型：** `string`
* **默认：** `assets`

指定生成静态资源的存放路径（相对于 `build.outDir`）。在 [库模式](/guide/build#library-mode) 下不能使用。

## build.assetsInlineLimit {#build-assetsinlinelimit}

* **类型：** `number` | `((filePath: string, content: Buffer) => boolean | undefined)`
* **默认：** `4096` (4 KiB)

小于此阈值的导入或引用资源将内联为 base64 编码，以避免额外的 http 请求。设置为 `0` 可以完全禁用此项。

如果传入了一个回调函数，可以通过返回一个布尔值来选择是否加入。如果没有返回任何内容，那么就会应用默认的逻辑。

Git LFS 占位符会自动排除在内联之外，因为它们不包含其所表示的文件的内容。

:::tip 注意
如果你指定了 `build.lib`，那么 `build.assetsInlineLimit` 将被忽略，无论文件大小或是否为 Git LFS 占位符，资源都会被内联。
:::

## build.cssCodeSplit {#build-csscodesplit}

* **类型：** `boolean`
* **默认：** `true`

启用/禁用 CSS 代码拆分。当启用时，在异步 chunk 中导入的 CSS 将内联到异步 chunk 本身，并在其被加载时一并获取。

如果禁用，整个项目中的所有 CSS 将被提取到一个 CSS 文件中。

::: tip 注意
如果指定了 `build.lib`，`build.cssCodeSplit` 会默认为 `false`。
:::

## build.cssTarget {#build-csstarget}

* **类型：** `string | string[]`
* **默认值：** 与 [`build.target`](/config/#build-target) 一致

此选项允许用户为 CSS 的压缩设置一个不同的浏览器 target，此处的 target 并非是用于 JavaScript 转写目标。

应只在针对非主流浏览器时使用。
最直观的示例是当你要兼容的场景是安卓微信中的 webview 时，它支持大多数现代的 JavaScript 功能，但并不支持 [CSS 中的 `#RGBA` 十六进制颜色符号](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors)。
这种情况下，你需要将 `build.cssTarget` 设置为 `chrome61`，以防止 vite 将 `rgba()` 颜色转化为 `#RGBA` 十六进制符号的形式。

## build.cssMinify {#build-cssminify}

* **类型：** `boolean | 'esbuild' | 'lightningcss'`
* **默认：** 对于客户端，与 [`build.minify`](#build-minify) 相同；对于 SSR，为 `'esbuild'`

此选项允许用户覆盖 CSS 最小化压缩的配置，而不是使用默认的 `build.minify`，这样你就可以单独配置 JS 和 CSS 的最小化压缩方式。Vite 默认使用 `esbuild` 来最小化 CSS。将此选项设置为 `'lightningcss'` 可以改用 [Lightning CSS](https://lightningcss.dev/minification.html) 进行压缩。设置为该项，便可以使用 [`css.lightningcss`](./shared-options.md#css-lightningcss) 选项来进行配置。

## build.sourcemap {#build-sourcemap}

* **类型：** `boolean | 'inline' | 'hidden'`
* **默认：** `false`

构建后是否生成 source map 文件。如果为 `true`，将会创建一个独立的 source map 文件。如果为 `'inline'`，source map 将作为一个 data URI 附加在输出文件中。`'hidden'` 的工作原理与 `true` 相似，只是 bundle 文件中相应的注释将不被保留。

## build.rollupOptions {#build-rollupoptions}

* **类型：** [`RollupOptions`](https://cn.rollupjs.org/configuration-options/)

自定义底层的 Rollup 打包配置。这与从 Rollup 配置文件导出的选项相同，并将与 Vite 的内部 Rollup 选项合并。查看 [Rollup 选项文档](https://cn.rollupjs.org/configuration-options/) 获取更多细节。

## build.commonjsOptions {#build-commonjsoptions}

* **类型：** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)

传递给 [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs) 插件的选项。

## build.dynamicImportVarsOptions {#build-dynamicimportvarsoptions}

* **类型：** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)
* **相关内容：** [动态导入](/guide/features#dynamic-import)

传递给 [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars) 的选项。

## build.lib {#build-lib}

* **类型：** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string), cssFileName?: string }`
* **相关内容：** [库模式](/guide/build#library-mode)

以库的形式构建。`entry` 是必需的，因为库不能使用 HTML 作为入口。`name` 是暴露的全局变量，当 `formats` 包括 `'umd'` 或 `'iife'` 时必须使用。默认的 `formats` 为 `['es'、'umd']`，如果使用多个入口，则为 `['es'、'cjs']`。

`fileName` 是软件包输出文件的名称，默认为 `package.json` 中的 `"name"`。它也可以定义为以 `format` 和 `entryName` 为参数的函数，并返回文件名。

如果软件包导入了 CSS，`cssFileName` 可用于指定 CSS 输出文件的名称。如果设置为字符串，则默认值与 `fileName` 相同，否则也会返回到 `package.json` 中的 `"name"`。

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: ['src/main.js'],
      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,
      cssFileName: 'my-lib-style',
    },
  },
})
```

## build.manifest {#build-manifest}

* **类型：** `boolean | string`
* **默认：** `false`
* **相关内容：** [后端集成](/guide/backend-integration)

是否生成一个 manifest 文件，包含了没有被 hash 过的资源文件名和 hash 后版本的映射，然后服务器框架可使用该映射来呈现正确的资源引入链接。

当值为字符串时，将用作相对于 `build.outDir` 的 manifest 文件路径。设置为 `true` 时，路径将是 `.vite/manifest.json`。

## build.ssrManifest {#build-ssrmanifest}

* **类型：** `boolean | string`
* **默认值：** `false`
* **相关链接：** [服务端渲染](/guide/ssr)

是否生成 SSR 的 manifest 文件，以确定生产中的样式链接与资源预加载指令。

当值为字符串时，将用作相对于 `build.outDir` 的 manifest 文件路径。设置为 `true` 时，路径将是 `.vite/ssr-manifest.json`。

## build.ssr {#build-ssr}

* **类型：** `boolean | string`
* **默认值：** `false`
* **相关链接：** [服务端渲染](/guide/ssr)

生成面向 SSR 的构建。此选项的值可以是字符串，用于直接定义 SSR 的入口，也可以为 `true`，但这需要通过设置 `rollupOptions.input` 来指定 SSR 的入口。

## build.emitAssets

* **类型：** `boolean`
* **默认：** `false`

在非客户端的构建过程中，静态资源并不会被输出，因为我们默认它们会作为客户端构建的一部分被输出。这个选项允许框架在其他环境的构建中强制输出这些资源。而将这些资源合并起来则是框架在构建后步骤中的责任。

## build.ssrEmitAssets

* **类型：** `boolean`
* **默认：** `false`

在 SSR 构建期间，静态资源不会被输出，因为它们通常被认为是客户端构建的一部分。这个选项允许框架强制在客户端和 SSR 构建中都输出它们。将静态资源在构建后合并是框架的责任。一旦环境 API 稳定，这个选项将被 `build.emitAssets` 替代。

## build.minify {#build-minify}

* **类型：** `boolean | 'terser' | 'esbuild'`
* **默认：** 客户端构建默认为`'esbuild'`，SSR构建默认为 `false`

设置为 `false` 可以禁用最小化混淆，或是用来指定使用哪种混淆器。默认为 [Esbuild](https://github.com/evanw/esbuild)，它比 terser 快 20-40 倍，压缩率只差 1%-2%。[Benchmarks](https://github.com/privatenumber/minification-benchmarks)

注意，在 lib 模式下使用 `'es'` 时，`build.minify` 选项不会缩减空格，因为会移除掉 pure 标注，导致破坏 tree-shaking。

当设置为 `'terser'` 时必须先安装 Terser。

```sh
npm add -D terser
```

## build.terserOptions {#build-terseroptions}

* **类型：** `TerserOptions`

传递给 Terser 的更多 [minify 选项](https://terser.org/docs/api-reference#minify-options)。

此外，你还可以传递一个 `maxWorkers: number` 选项来指定最大的工作线程数。默认为 CPU 核心数减 1。

## build.write {#build-write}

* **类型：** `boolean`
* **默认：** `true`

设置为 `false` 来禁用将构建后的文件写入磁盘。这常用于 [编程式地调用 `build()`](/guide/api-javascript#build) 在写入磁盘之前，需要对构建后的文件进行进一步处理。

## build.emptyOutDir {#build-emptyoutdir}

* **类型：** `boolean`
* **默认：** 若 `outDir` 在 `root` 目录下，则为 `true`

默认情况下，若 `outDir` 在 `root` 目录下，则 Vite 会在构建时清空该目录。若 `outDir` 在根目录之外则会抛出一个警告避免意外删除掉重要的文件。可以设置该选项来关闭这个警告。该功能也可以通过命令行参数 `--emptyOutDir` 来使用。

## build.copyPublicDir {#build-copypublicdir}

* **类型：** `boolean`
* **默认：** `true`

默认情况下，Vite 会在构建阶段将 `publicDir` 目录中的所有文件复制到 `outDir` 目录中。可以通过设置该选项为 `false` 来禁用该行为。

## build.reportCompressedSize {#build-reportcompressedsize}

* **类型：** `boolean`
* **默认：** `true`

启用/禁用 gzip 压缩大小报告。压缩大型输出文件可能会很慢，因此禁用该功能可能会提高大型项目的构建性能。

## build.chunkSizeWarningLimit {#build-chunksizewarninglimit}

* **类型：** `number`
* **默认：** `500`

规定触发警告的 chunk 大小。（以 kB 为单位）。它将与未压缩的 chunk 大小进行比较，因为 [JavaScript 大小本身与执行时间相关](https://v8.dev/blog/cost-of-javascript-2019)。

## build.watch {#build-watch}

* **类型：** [`WatcherOptions`](https://cn.rollupjs.org/configuration-options/#watch)`| null`
* **默认：** `null`

设置为 `{}` 则会启用 rollup 的监听器。对于只在构建阶段或者集成流程使用的插件很常用。

::: warning 在 Windows Linux 子系统（WSL）上使用 Vite

某些情况下 WSL2 的文件系统监听可能无法正常工作。
查看 [`server.watch`](./server-options.md#server-watch) 了解更多细节。

:::

---

---
url: /guide/backend-integration.md
---
# 后端集成 {#backend-integration}

:::tip Note
如果你想使用传统的后端（如 Rails, Laravel）来服务 HTML，但使用 Vite 来服务其他资源，可以查看在 [Awesome Vite](https://github.com/vitejs/awesome-vite#integrations-with-backends) 上的已有的后端集成列表。

如果你需要自定义集成，你可以按照本指南的步骤配置它：
:::

1. 在你的 Vite 配置中配置入口文件和启用创建 `manifest`：

   ```js twoslash [vite.config.js]
   import { defineConfig } from 'vite'
   // ---cut---
   export default defineConfig({
     server: {
       cors: {
         // 通过浏览器访问的源
         origin: 'http://my-backend.example.com',
       },
     },
     build: {
       // 在 outDir 中生成 .vite/manifest.json
       manifest: true,
       rollupOptions: {
         // 覆盖默认的 .html 入口
         input: '/path/to/main.js'
       }
     }
   })
   ```

   如果你没有禁用 [module preload 的 polyfill](/config/build-options.md#build-polyfillmodulepreload)，你还需在你的入口处添加此 polyfill：

   ```js
   // 在你应用的入口起始处添加此 polyfill
   import 'vite/modulepreload-polyfill'
   ```

2. 在开发环境中，在服务器的 HTML 模板中注入以下内容（用正在运行的本地 URL 替换 `http://localhost:5173`）：

   ```html
   <!-- 如果是在开发环境中 -->
   <script type="module" src="http://localhost:5173/@vite/client"></script>
   <script type="module" src="http://localhost:5173/main.js"></script>
   ```

   为了正确地提供资源，你有两种选项：

   * 确保服务器被配置过，将会拦截代理资源请求给到 Vite 服务器
   * 设置 [`server.origin`](/config/server-options.md#server-origin) 以求生成的资源链接将以服务器 URL 形式被解析而非一个相对路径

   这对于图片等资源的正确加载是必需的。

   如果你正使用 `@vitejs/plugin-react` 配合 React，你还需要在上述脚本前添加下面这个，因为插件不能修改你正在服务的 HTML（请将 `http://localhost:5173` 替换为 Vite 正在运行的本地 URL）：

   ```html
   <script type="module">
     import RefreshRuntime from 'http://localhost:5173/@react-refresh'
     RefreshRuntime.injectIntoGlobalHook(window)
     window.$RefreshReg$ = () => {}
     window.$RefreshSig$ = () => (type) => type
     window.__vite_plugin_react_preamble_installed__ = true
   </script>
   ```

3. 在生产环境中：在运行 `vite build` 之后，一个 `.vite/manifest.json` 文件将与静态资源文件一同生成。一个示例清单文件会像下面这样：

   ```json [.vite/manifest.json]
   {
     "_shared-B7PI925R.js": {
       "file": "assets/shared-B7PI925R.js",
       "name": "shared",
       "css": ["assets/shared-ChJ_j-JJ.css"]
     },
     "_shared-ChJ_j-JJ.css": {
       "file": "assets/shared-ChJ_j-JJ.css",
       "src": "_shared-ChJ_j-JJ.css"
     },
     "baz.js": {
       "file": "assets/baz-B2H3sXNv.js",
       "name": "baz",
       "src": "baz.js",
       "isDynamicEntry": true
     },
     "views/bar.js": {
       "file": "assets/bar-gkvgaI9m.js",
       "name": "bar",
       "src": "views/bar.js",
       "isEntry": true,
       "imports": ["_shared-B7PI925R.js"],
       "dynamicImports": ["baz.js"]
     },
     "views/foo.js": {
       "file": "assets/foo-BRBmoGS9.js",
       "name": "foo",
       "src": "views/foo.js",
       "isEntry": true,
       "imports": ["_shared-B7PI925R.js"],
       "css": ["assets/foo-5UjPuW-k.css"]
     }
   }
   ```

   * 清单是一个 `Record<name, chunk>` 结构的对象。
   * 对于 入口 或动态入口 chunk，键是相对于项目根目录的资源路径。
   * 对于非入口 chunk，键是生成文件的名称并加上前缀 `_`。
   * 当 [`build.cssCodeSplit`](/config/build-options.md#build-csscodesplit) 为 `false` 时生成的 CSS 文件，键为 `style.css`。
   * Chunk 将信息包含在其静态和动态导入上（两者都是映射到清单中相应 chunk 的键），以及任何与之相关的 CSS 和资源文件。

4. 你可以利用这个文件来渲染带有哈希文件名的链接或预加载指令。

   这是一个用来渲染正确链接的 HTML 模板示例。这里的语法仅用于解释，
   你需要用你的服务器模板语言来替换。`importedChunks` 函数只是
   用来说明，并不是 Vite 提供的。

   ```html
   <!-- 如果是生产环境 -->

   <!-- 对于 manifest[name].css 中的 cssFile -->
   <link rel="stylesheet" href="/{{ cssFile }}" />

   <!-- 对于 importedChunks(manifest, name) 中的 chunk  -->
   <!-- 对于 chunk.css 中的 cssFile -->
   <link rel="stylesheet" href="/{{ cssFile }}" />

   <script type="module" src="/{{ manifest[name].file }}"></script>

   <!-- 对于 importedChunks(manifest, name) 中的 chunk  -->
   <link rel="modulepreload" href="/{{ chunk.file }}" />
   ```

   具体来说，一个生成 HTML 的后端在给定 manifest 文件和一个入口文件的情况下，
   应该包含以下标签：

   * 对于入口文件 chunk 的 `css` 列表中的每个文件，都应包含一个 `<link rel="stylesheet">` 标签。
   * 递归追踪入口文件的 `imports` 列表中的所有 chunk，并为每个导入的 chunk 的每个 CSS 文件
     包含一个 `<link rel="stylesheet">` 标签。
   * 对于入口文件 chunk 的 `file` 键的标签（对于 JavaScript 是
     `<script type="module">`，对于 CSS 是 `<link rel="stylesheet">`）
   * 可选项，对于每个导入的 JavaScript chunk 的 `file` 键的 `<link rel="modulepreload">` 标签，
     同样从入口文件 chunk 开始递归追踪导入。

   按照上面的示例 manifest，对于入口文件 `views/foo.js`，在生产环境中应包含以下标签：

   ```html
   <link rel="stylesheet" href="assets/foo-5UjPuW-k.css" />
   <link rel="stylesheet" href="assets/shared-ChJ_j-JJ.css" />
   <script type="module" src="assets/foo-BRBmoGS9.js"></script>
   <!-- 可选 -->
   <link rel="modulepreload" href="assets/shared-B7PI925R.js" />
   ```

   而对于入口文件 `views/bar.js`，应该包含以下标签：

   ```html
   <link rel="stylesheet" href="assets/shared-ChJ_j-JJ.css" />
   <script type="module" src="assets/bar-gkvgaI9m.js"></script>
   <!-- 可选 -->
   <link rel="modulepreload" href="assets/shared-B7PI925R.js" />
   ```

   ::: details `importedChunks` 的伪代码实现
   `importedChunks` 在 TypeScript 中的一个伪实现示例
   （这需要根据您的编程语言和模板语言进行调整）：

   ```ts
   import type { Manifest, ManifestChunk } from 'vite'

   export default function importedChunks(
     manifest: Manifest,
     name: string,
   ): ManifestChunk[] {
     const seen = new Set<string>()

     function getImportedChunks(chunk: ManifestChunk): ManifestChunk[] {
       const chunks: ManifestChunk[] = []
       for (const file of chunk.imports ?? []) {
         const importee = manifest[file]
         if (seen.has(file)) {
           continue
         }
         seen.add(file)

         chunks.push(...getImportedChunks(importee))
         chunks.push(importee)
       }

       return chunks
     }

     return getImportedChunks(manifest[name])
   }
   ```

   :::

---

---
url: /guide/api-environment.md
---
# 环境 API {#environment-api}

:::warning 实验性
环境 API 是实验性的。在 Vite 6 期间，我们将保持这些 API 的稳定，以便生态系统可以在其基础上进行实验和构建。我们计划在 Vite 7 中稳定这些新 API，并可能进行一些重大更改。

资料：

* [反馈讨论](https://github.com/vitejs/vite/discussions/16358) 我们在此处收集新 API 的反馈。
* [环境 API PR](https://github.com/vitejs/vite/pull/16471) 新 API 在此处被实现并进行了审查。

请与我们分享您的反馈。
:::

## 引入环境概念 {#formalizing-environments}

Vite 6 正式引入了环境（Environments）的概念。在 Vite 5 之前，有两个隐式环境（`client`，以及可选的 `ssr`）。新的环境 API 允许用户和框架作者根据他们的应用在生产环境中的工作方式创建尽可能多的环境。这些新的功能需要大规模的内部重构，而我们也已经在保持向后兼容性上做出了很大的努力。Vite 6 的初始目标是尽可能平滑地将整个生态系统迁移到新的主要版本，直到有足够的用户已经迁移，并且框架和插件作者已经验证了新的设计后，再采用这些新的实验性 API。

## 缩小构建和开发模式间的差距 {#closing-the-gap-between-build-and-dev}

对于简单的 SPA/MPA，配置中不会暴露任何与环境有关的新 API。在内部，Vite 会将选项应用于 `client` 环境，但在配置 Vite 时无需了解这一概念。Vite 5 中的配置和行为应能在此无缝运行。

当我们移动到一个典型的服务器端渲染（SSR）应用程序时，我们将有两个环境：

* `client`: 在浏览器中运行应用程序。
* `server`: 在 node（或其他服务器运行时）中运行应用程序，渲染页面后再发送到浏览器。

在开发过程中，Vite 会在与 Vite 开发服务器相同的 Node 进程中执行服务器代码，从而接近生产环境。不过，服务器也有可能在其他 JS 运行时中运行，如 [Cloudflare 的 workerd](https://github.com/cloudflare/workerd)，它们有不同的限制。现代应用程序也可能在两个以上的环境中运行，例如浏览器、节点服务器和边缘服务器。Vite 5 无法正确表示这些环境。

Vite 6 允许用户在构建和开发过程中配置应用程序，以映射其所有环境。在开发期间，一个 Vite 开发服务器现在可用于在多个不同环境中同时运行代码。应用程序源代码仍由 Vite 开发服务器进行转换。在共享 HTTP 服务器、中间件、解析配置和插件管道的基础上，Vite 开发服务器现在拥有一组独立的开发环境。每个开发环境的配置都尽可能与生产环境相匹配，并连接到执行代码的开发运行时（对于 Workerd，服务器代码现在可以在本地 miniflare 中运行）。在客户端，浏览器导入并执行代码。在其他环境中，模块运行程序会获取并评估转换后的代码。

![Vite Environments](../images/vite-environments.svg)

## 环境配置 {#environments-configuration}

对于 SPA/MPA，配置与 Vite 5 类似。在内部，这些选项用于配置 `client` 环境。

```js
export default defineConfig({
  build: {
    sourcemap: false,
  },
  optimizeDeps: {
    include: ['lib'],
  },
})
```

这一点很重要，因为我们希望 Vite 保持平易近人，避免在需要时才公开新概念。

如果应用程序由多个环境组成，则可以使用 `environments` 配置选项显式配置这些环境。

```js
export default {
  build: {
    sourcemap: false,
  },
  optimizeDeps: {
    include: ['lib'],
  },
  environments: {
    server: {},
    edge: {
      resolve: {
        noExternal: true,
      },
    },
  },
}
```

如果没有明确说明，环境将继承已配置的顶级配置选项（例如，新的 `server` 和 `edge` 环境将继承 `build.sourcemap: false` 选项）。少数顶级选项（如 `optimizeDeps`）仅适用于 `client` 环境，因为它们在默认应用于服务器环境时效果不佳。也可以通过 `environments.client` 明确配置 `client` 环境，但我们建议使用顶级选项进行配置，以便在添加新环境时客户端配置保持不变。

`EnvironmentOptions` 接口公开所有每个环境选项。有些环境选项适用于 `build` 和 `dev`，如 `resolve`。还有 `DevEnvironmentOptions` 和 `BuildEnvironmentOptions` 用于开发和构建特定选项（如 `dev.warmup` 或 `build.outDir`）。一些选项（例如`optimizeDeps`）仅适用于 dev，但为了向后兼容，它保留为顶层而不是嵌套在`dev`中。

```ts
interface EnvironmentOptions {
  define?: Record<string, any>
  resolve?: EnvironmentResolveOptions
  optimizeDeps: DepOptimizationOptions
  consumer?: 'client' | 'server'
  dev: DevOptions
  build: BuildOptions
}
```

`UserConfig` 接口从 `EnvironmentOptions` 接口扩展而来，允许通过 `environments` 选项配置客户端和其他环境的默认值。在开发过程中，名为 `ssr` 的 `client` 和服务器环境始终存在。这允许与 `server.ssrLoadModule(url)` 和 `server.moduleGraph` 向后兼容。在构建期间，`client` 环境始终存在，而 `ssr` 环境仅在明确配置时才存在（使用 `environments.ssr` 或为了向后兼容而使用 `build.ssr`）。应用程序不需要为其 SSR 环境使用 `ssr` 名称，例如，它可以将其命名为 `server`。

```ts
interface UserConfig extends EnvironmentOptions {
  environments: Record<string, EnvironmentOptions>
  // 其他选项
}
```

请注意，一旦环境 API 稳定， `ssr` 顶级属性将被废弃。该选项的作用与 `environments` 相同，但针对的是默认的 `ssr` 环境，而且只允许配置一小部分选项。

## 自定义环境实例 {#custom-environment-instances}

底层 API 配置已可用，因此可以支持为运行时提供环境。这些环境还可以生成其他进程或线程，以便在更接近生产环境的运行时间内运行开发模块。

```js
import { customEnvironment } from 'vite-environment-provider'

export default {
  build: {
    outDir: '/dist/client',
  },
  environments: {
    ssr: customEnvironment({
      build: {
        outDir: '/dist/ssr',
      },
    }),
  },
}
```

## 向后兼容性 {#backward-compatibility}

当前的 Vite 服务器 API 尚未被弃用，并且与 Vite 5 向后兼容。新的环境 API 是实验性的。

`server.moduleGraph` 返回客户端和服务器端渲染（ssr）模块图的混合视图。所有其方法都将返回向后兼容的混合模块节点。对于传递给 `handleHotUpdate` 的模块节点，也使用相同的方案。

我们不建议现在就切换到环境 API。我们的目标是在插件不需要维护两个版本之前，让大部分用户基础采用 Vite 6。查看未来破坏性更改部分以获取未来弃用和升级路径的信息：

* [钩子函数中的 `this.environment`](/changes/this-environment-in-hooks)
* [HMR `hotUpdate` 插件钩子](/changes/hotupdate-hook)
* [迁移到基于环境的API](/changes/per-environment-apis)
* [使用 `ModuleRunner` API 进行服务端渲染](/changes/ssr-using-modulerunner)
* [构建过程中的共享插件](/changes/shared-plugins-during-build)

## 目标用户 {#target-users}

本指南为终端用户提供了关于环境的基本概念。

插件作者可以使用更一致的 API 与当前环境配置进行交互。如果你正在基于 Vite 进行开发，[环境 API 插件指南](./api-environment-plugins.md) 描述了扩展插件 API 如何支持多个自定义环境。

框架可以自行决定在不同层次上暴露环境。如果你是框架作者，请继续阅读 [环境 API 框架指南](./api-environment-frameworks.md)，以了解环境 API 编程方面的内容。

对于运行时提供者，[环境 API 运行时指南](./api-environment-runtimes.md) 解释了如何提供自定义环境供框架和用户使用。

---

---
url: /guide/env-and-mode.md
---
# 环境变量和模式 {#env-variables-and-modes}

Vite 在特殊的 `import.meta.env` 对象下暴露了一些常量。这些常量在开发阶段被定义为全局变量，并在构建阶段被静态替换，以使树摇（tree-shaking）更有效。

## 内置常量 {#built-in-constants}

一些内置常量在所有情况下都可用：

* **`import.meta.env.MODE`**: {string} 应用运行的[模式](#modes)。

* **`import.meta.env.BASE_URL`**: {string} 部署应用时的基本 URL。他由[`base` 配置项](/config/shared-options.md#base)决定。

* **`import.meta.env.PROD`**: {boolean} 应用是否运行在生产环境（使用 `NODE_ENV='production'` 运行开发服务器或构建应用时使用 `NODE_ENV='production'` ）。

* **`import.meta.env.DEV`**: {boolean} 应用是否运行在开发环境 (永远与 `import.meta.env.PROD`相反)。

* **`import.meta.env.SSR`**: {boolean} 应用是否运行在 [server](./ssr.md#conditional-logic) 上。

## 环境变量 {#env-variables}

Vite 自动将环境变量暴露在 `import.meta.env` 对象下，作为字符串。

为了防止意外地将一些环境变量泄漏到客户端，只有以 `VITE_` 为前缀的变量才会暴露给经过 vite 处理的代码。例如下面这些环境变量：

```[.env]
VITE_SOME_KEY=123
DB_PASSWORD=foobar
```

只有 `VITE_SOME_KEY` 会被暴露为 `import.meta.env.VITE_SOME_KEY` 提供给客户端源码，而 `DB_PASSWORD` 则不会。

```js
console.log(import.meta.env.VITE_SOME_KEY) // "123"
console.log(import.meta.env.DB_PASSWORD) // undefined
```

如果你想要自定义环境变量的前缀，请参阅 [envPrefix](/config/shared-options.html#envprefix) 选项。

:::tip 环境变量解析
如上所示，`VITE_SOME_KEY` 是一个数字，但在解析时会返回一个字符串。布尔类型的环境变量也会发生同样的情况。在代码中使用时，请确保转换为所需的类型。
:::

### `.env` 文件 {#env-files}

Vite 使用 [dotenv](https://github.com/motdotla/dotenv) 从你的 [环境目录](/config/shared-options.md#envdir) 中的下列文件加载额外的环境变量：

```
.env                # 所有情况下都会加载
.env.local          # 所有情况下都会加载，但会被 git 忽略
.env.[mode]         # 只在指定模式下加载
.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略
```

:::tip 环境加载优先级

一份用于指定模式的文件（例如 `.env.production`）会比通用文件的优先级更高（例如 `.env`）。

Vite 总是会加载 `.env` 和 `.env.local` 文件，除此之外还会加载模式特定的 `.env.[mode]` 文件。在模式特定文件中声明的变量优先级高于通用文件中的变量，但仅在 `.env` 或 `.env.local` 中定义的变量仍然可以在环境中使用。

另外，Vite 执行时已经存在的环境变量有最高的优先级，不会被 `.env` 类文件覆盖。例如当运行 `VITE_SOME_KEY=123 vite build` 的时候。

`.env` 类文件会在 Vite 启动一开始时被加载，而改动会在重启服务器后生效。

:::

此外，Vite 使用 [dotenv-expand](https://github.com/motdotla/dotenv-expand) 来扩展在 env 文件中编写的变量。想要了解更多相关语法，请查看 [它们的文档](https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow)。

请注意，如果想要在环境变量中使用 `$` 符号，则必须使用 `\` 对其进行转义。

```[.env]
KEY=123
NEW_KEY1=test$foo   # test
NEW_KEY2=test\$foo  # test$foo
NEW_KEY3=test$KEY   # test123
```

:::warning 安全注意事项

* `.env.*.local` 文件应是本地的，可以包含敏感变量。你应该将 `*.local` 添加到你的 `.gitignore` 中，以避免它们被 git 检入。

* 由于任何暴露给 Vite 源码的变量最终都将出现在客户端包中，`VITE_*` 变量应该不包含任何敏感信息。

:::

::: details 反向扩展变量

Vite 支持以相反的顺序扩展变量。
例如，下面的 `.env` 将被评估为 `VITE_FOO=foobar`, `VITE_BAR=bar`。

```[.env]
VITE_FOO=foo${VITE_BAR}
VITE_BAR=bar
```

这在 shell 脚本和其他工具（如 `docker-compose`）中不起作用。
不过，Vite 支持这种行为，因为 `dotenv-expand` 已经支持这种行为很长时间了，JavaScript 生态系统中的其他工具也使用支持这种行为的旧版本。

为避免出现互操作问题，建议避免依赖这种行为。今后，Vite 可能会对这种行为发出警告。

:::

## TypeScript 的智能提示 {#intellisense}

默认情况下，Vite 在 [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts) 中为 `import.meta.env` 提供了类型定义。随着在 `.env[mode]` 文件中自定义了越来越多的环境变量，你可能想要在代码中获取这些以 `VITE_` 为前缀的用户自定义环境变量的 TypeScript 智能提示。

要想做到这一点，你可以在 `src` 目录下创建一个 `vite-env.d.ts` 文件，接着按下面这样增加 `ImportMetaEnv` 的定义：

```typescript [vite-env.d.ts]
/// <reference types="vite/client" />

interface ViteTypeOptions {
  // 添加这行代码，你就可以将 ImportMetaEnv 的类型设为严格模式，
  // 这样就不允许有未知的键值了。
  // strictImportMetaEnv: unknown
}

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string
  // 更多环境变量...
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

如果你的代码依赖于浏览器环境的类型，比如 [DOM](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts) 和 [WebWorker](https://github.com/microsoft/TypeScript/blob/main/src/lib/webworker.generated.d.ts)，你可以在 `tsconfig.json` 中修改 [lib](https://www.typescriptlang.org/tsconfig#lib) 字段来获取类型支持。

```json [tsconfig.json]
{
  "lib": ["WebWorker"]
}
```

:::warning 导入语句会破坏类型增强

如果 `ImportMetaEnv` 增强不起作用，请确保在 `vite-env.d.ts` 中没有任何 `import` 语句。更多信息请参阅 [TypeScript 文档](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined)。

:::

## HTML 环境变量替换 {#html-constant-replacement}

Vite 还支持在 HTML 文件中替换环境变量。`import.meta.env` 中的任何属性都可以通过特殊的 `%CONST_NAME%` 语法在 HTML 文件中使用：

```html
<h1>Vite is running in %MODE%</h1>
<p>Using data from %VITE_API_URL%</p>
```

如果环境变量在 `import.meta.env` 中不存在，比如不存在的 `%NON_EXISTENT%`，则会将被忽略而不被替换，这与 JS 中的 `import.meta.env.NON_EXISTENT` 不同，JS 中会被替换为 `undefined`。

正因为 Vite 被许多框架使用，它在复杂的替换（如条件替换）上故意不持任何意见。Vite 可以使用 [现有的用户插件](https://github.com/vitejs/awesome-vite#transformers) 或者一个实现了 [`transformIndexHtml` 钩子](./api-plugin#transformindexhtml) 的自定义插件来扩展。

## 模式 {#modes}

默认情况下，开发服务器 (`dev` 命令) 运行在 `development` (开发) 模式，而 `build` 命令则运行在 `production` (生产) 模式。

这意味着当执行 `vite build` 时，它会自动加载 `.env.production` 中可能存在的环境变量：

```[.env.production]
VITE_APP_TITLE=My App
```

在你的应用中，你可以使用 `import.meta.env.VITE_APP_TITLE` 渲染标题。

在某些情况下，若想在 `vite build` 时运行不同的模式来渲染不同的标题，你可以通过传递 `--mode` 选项标志来覆盖命令使用的默认模式。例如，如果你想在 staging （预发布）模式下构建应用：

```bash
vite build --mode staging
```

还需要新建一个 `.env.staging` 文件：

```[.env.staging]
VITE_APP_TITLE=My App (staging)
```

由于 `vite build` 默认运行生产模式构建，你也可以通过使用不同的模式和对应的 `.env` 文件配置来改变它，用以运行开发模式的构建：

```[.env.testing]
NODE_ENV=development
```

### NODE\_ENV 和 模式 {#node-env-and-modes}

需要注意的是，`NODE_ENV`（`process.env.NODE_ENV`）和模式是两个不同的概念。以下是不同命令如何影响 `NODE_ENV` 和模式：

| Command                                              | NODE\_ENV        | Mode            |
| ---------------------------------------------------- | --------------- | --------------- |
| `vite build`                                         | `"production"`  | `"production"`  |
| `vite build --mode development`                      | `"production"`  | `"development"` |
| `NODE_ENV=development vite build`                    | `"development"` | `"production"`  |
| `NODE_ENV=development vite build --mode development` | `"development"` | `"development"` |

`NODE_ENV` 和模式的不同值也会反映在相应的 `import.meta.env` 属性上：

| Command                | `import.meta.env.PROD` | `import.meta.env.DEV` |
| ---------------------- | ---------------------- | --------------------- |
| `NODE_ENV=production`  | `true`                 | `false`               |
| `NODE_ENV=development` | `false`                | `true`                |
| `NODE_ENV=other`       | `false`                | `true`                |

| Command              | `import.meta.env.MODE` |
| -------------------- | ---------------------- |
| `--mode production`  | `"production"`         |
| `--mode development` | `"development"`        |
| `--mode staging`     | `"staging"`            |

:::tip `.env` 文件中的 `NODE_ENV`

`NODE_ENV=...` 可以在命令中设置，也可以在 `.env` 文件中设置。如果在 `.env.[mode]` 文件中指定了 `NODE_ENV`，则可以使用模式来控制其值。不过，`NODE_ENV` 和模式仍然是两个不同的概念。

命令中使用 `NODE_ENV=...` 的主要好处是，它允许 Vite 提前检测到该值。这也使你能够在 Vite 配置中读取 `process.env.NODE_ENV`，因为 Vite 只有在解析配置之后才能加载环境变量文件。
:::

---

---
url: /guide/assets.md
---
# 静态资源处理 {#static-asset-handling}

* 相关: [公共基础路径](./build#public-base-path)
* 相关: [`assetsInclude` 配置项](/config/shared-options.md#assetsinclude)

## 将资源引入为 URL {#importing-asset-as-url}

服务时引入一个静态资源会返回解析后的公共路径：

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl
```

例如，`imgUrl` 在开发时会是 `/src/img.png`，在生产构建后会是 `/assets/img.2d8efhg.png`。

行为类似于 Webpack 的 `file-loader`。区别在于导入既可以使用绝对公共路径（基于开发期间的项目根路径），也可以使用相对路径。

* `url()` 在 CSS 中的引用也以同样的方式处理。

* 如果 Vite 使用了 Vue 插件，Vue SFC 模板中的资源引用都将自动转换为导入。

* 常见的图像、媒体和字体文件类型被自动检测为资源。你可以使用 [`assetsInclude` 选项](/config/shared-options.md#assetsinclude) 扩展内部列表。

* 引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可以由插件进行处理以进行优化。

* 较小的资源体积小于 [`assetsInlineLimit` 选项值](/config/build-options.md#build-assetsinlinelimit) 则会被内联为 base64 data URL。

* Git LFS 占位符会自动排除在内联之外，因为它们不包含它们所表示的文件的内容。要获得内联，请确保在构建之前通过 Git LFS 下载文件内容。

* 默认情况下，TypeScript 不会将静态资源导入视为有效的模块。要解决这个问题，需要添加 [`vite/client`](./features#client-types)。

::: tip 通过 `url()` 内联 SVG
当在 JS 中手动构造 `url()` 并传入一个 SVG 的 URL 时，应该用双引号将变量包裹起来。

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl from './img.svg'
document.getElementById('hero-img').style.background = `url("${imgUrl}")`
```

:::

### 显式 URL 引入 {#explicit-url-imports}

未被包含在内部列表或 `assetsInclude` 中的资源，可以使用 `?url` 后缀显式导入为一个 URL。这十分有用，例如，要导入 [Houdini Paint Worklets](https://developer.mozilla.org/en-US/docs/Web/API/CSS/paintWorklet_static) 时：

```js twoslash
import 'vite/client'
// ---cut---
import workletURL from 'extra-scalloped-border/worklet.js?url'
CSS.paintWorklet.addModule(workletURL)
```

### 显式内联处理 {#explicit-inline-handling}

可以分别使用`?inline`或`?no-inline`后缀，明确导入带内联或不带内联的静态资源。

```js twoslash
import 'vite/client'
// ---cut---
import imgUrl1 from './img.svg?no-inline'
import imgUrl2 from './img.png?inline'
```

### 将资源引入为字符串 {#importing-asset-as-string}

资源可以使用 `?raw` 后缀声明作为字符串引入。

```js twoslash
import 'vite/client'
// ---cut---
import shaderString from './shader.glsl?raw'
```

### 导入脚本作为 Worker {#importing-script-as-a-worker}

脚本可以通过 `?worker` 或 `?sharedworker` 后缀导入为 web worker。

```js twoslash
import 'vite/client'
// ---cut---
// 在生产构建中将会分离出 chunk
import Worker from './shader.js?worker'
const worker = new Worker()
```

```js twoslash
import 'vite/client'
// ---cut---
// sharedworker
import SharedWorker from './shader.js?sharedworker'
const sharedWorker = new SharedWorker()
```

```js twoslash
import 'vite/client'
// ---cut---
// 内联为 base64 字符串
import InlineWorker from './shader.js?worker&inline'
```

查看 [Web Worker 小节](./features.md#web-workers) 获取更多细节。

### `public` 目录 {#the-public-directory}

如果你有下列这些资源：

* 不会被源码引用（例如 `robots.txt`）
* 必须保持原有文件名（没有经过 hash）
* ...或者你压根不想引入该资源，只是想得到其 URL。

那么你可以将该资源放在指定的 `public` 目录中，它应位于你的项目根目录。该目录中的资源在开发时能直接通过 `/` 根路径访问到，并且打包时会被完整复制到目标目录的根目录下。

目录默认是 `<root>/public`，但可以通过 [`publicDir` 选项](/config/shared-options.md#publicdir) 来配置。

请注意，应该始终使用根绝对路径来引入 `public` 中的资源 —— 举个例子，`public/icon.png` 应该在源码中被引用为 `/icon.png`。

## new URL(url, import.meta.url)

[import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) 是一个 ESM 的原生功能，会暴露当前模块的 URL。将它与原生的 [URL 构造器](https://developer.mozilla.org/en-US/docs/Web/API/URL) 组合使用，在一个 JavaScript 模块中，通过相对路径我们就能得到一个被完整解析的静态资源 URL：

```js
const imgUrl = new URL('./img.png', import.meta.url).href

document.getElementById('hero-img').src = imgUrl
```

这在现代浏览器中能够原生使用 - 实际上，Vite 并不需要在开发阶段处理这些代码！

这个模式同样还可以通过字符串模板支持动态 URL：

```js
function getImageUrl(name) {
  // 请注意，这不包括子目录中的文件
  return new URL(`./dir/${name}.png`, import.meta.url).href
}
```

在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址。然而，这个 URL 字符串必须是静态的，这样才好分析。否则代码将被原样保留、因而在 `build.target` 不支持 `import.meta.url` 时会导致运行时错误。

```js
// Vite 不会转换这个
const imgUrl = new URL(imagePath, import.meta.url).href
```

::: details 工作原理

Vite 会将 `getImageUrl` 函数改造为：

```js
import __img0png from './dir/img0.png'
import __img1png from './dir/img1.png'

function getImageUrl(name) {
  const modules = {
    './dir/img0.png': __img0png,
    './dir/img1.png': __img1png,
  }
  return new URL(modules[`./dir/${name}.png`], import.meta.url).href
}
```

:::

::: warning 注意：无法在 SSR 中使用
如果你正在以服务端渲染模式使用 Vite 则此模式不支持，因为 `import.meta.url` 在浏览器和 Node.js 中有不同的语义。服务端的产物也无法预先确定客户端主机 URL。
:::

---

---
url: /config/server-options.md
---
# 开发服务器选项 {#server-options}

除非另有说明，本节中的选项仅适用于开发环境。

## server.host

* **类型：** `string | boolean`
* **默认：** `'localhost'`

指定服务器应该监听哪个 IP 地址。
如果将此设置为 `0.0.0.0` 或者 `true` 将监听所有地址，包括局域网和公网地址。

也可以通过 CLI 使用 `--host 0.0.0.0` 或 `--host` 来设置。

::: tip NOTE

在某些情况下，可能响应的是其他服务器而不是 Vite。

第一种情况是 `localhost` 被使用了。Node.js 在 v17 以下版本中默认会对 DNS 解析地址的结果进行重新排序。当访问 `localhost` 时，浏览器使用 DNS 来解析地址，这个地址可能与 Vite 正在监听的地址不同。当地址不一致时，Vite 会打印出来。

你可以设置 [`dns.setDefaultResultOrder('verbatim')`](https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order) 来禁用这个重新排序的行为。Vite 会将地址打印为 `localhost`。

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'
import dns from 'node:dns'

dns.setDefaultResultOrder('verbatim')

export default defineConfig({
  // omit
})
```

第二种情况是使用了通配主机地址（例如 `0.0.0.0`）。这是因为侦听非通配符主机的服务器优先于侦听通配符主机的服务器。

:::

::: tip 在 WSL2 中通过 LAN 访问开发服务器

当你在 WSL2 运行 Vite 时，仅设置 `host: true` 来从局域网访问服务器是不够的。
请看 [WSL 相关文档](https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan) 了解更多细节。

:::

## server.allowedHosts

* **类型：** `string[] | true`
* **默认：** `[]`

Vite允许响应的主机名。
默认情况下，允许 `localhost` 及其下的所有 `.localhost` 域名和所有 IP 地址。
使用 HTTPS 时，将跳过此检查。

如果设置的字符串以 `.` 开头，则允许该主机名本身（不带 `.`）以及该主机名下的所有子域名。例如，`.example.com` 将允许 `example.com`、`foo.example.com` 和 `foo.bar.example.com`。如果设置为 `true`，服务器将被允许响应任何主机的请求。

::: details 哪些主机可以安全添加？

你控制其解析 IP 地址的主机可以安全地添加到允许的主机列表中。

例如，如果你拥有域名 `vite.dev`，你可以将 `vite.dev` 和 `.vite.dev` 添加到列表中。如果你不拥有该域名且无法信任该域名的所有者，则不应添加它。

特别是，你绝不能将顶级域名（如 `.com`）添加到列表中。这是因为任何人都可以购买域名 `example.com` 并控制其解析的 IP 地址。

:::

::: danger

将 `server.allowedHosts` 设置为 `true` 允许任何网站通过 DNS 重绑定攻击向你的开发服务器发送请求，从而使它们能够下载你的源代码和内容。我们建议始终使用显式的允许主机列表。有关更多详细信息，请参阅 [GHSA-vg6x-rcgg-rjx6](https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6)。

:::

::: details 通过环境变量配置
你可以设置环境变量 `__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS` 来添加额外允许的服务器端口。
:::

## server.port

* **类型：** `number`
* **默认值：** `5173`

指定开发服务器端口。注意：如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。

## server.strictPort {#server-strictport}

* **类型：** `boolean`

设为 `true` 时若端口已被占用则会直接退出，而不是尝试下一个可用端口。

## server.https {#server-https}

* **类型：** `https.ServerOptions`

启用 TLS + HTTP/2。该值是传递给 `https.createServer()` 的 [options 对象](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener)。

请注意，仅当同时使用 [`server.proxy` 选项](#server-proxy) 时，才会降级为 TLS。

需要一个合法可用的证书。对基本使用的配置需求来说，你可以添加 [@vitejs/plugin-basic-ssl](https://github.com/vitejs/vite-plugin-basic-ssl) 到项目插件中，它会自动创建和缓存一个自签名的证书。但我们推荐你创建和使用你自己的证书。

## server.open {#server-open}

* **类型：** `boolean | string`

开发服务器启动时，自动在浏览器中打开应用程序。当该值为字符串时，它将被用作 URL 的路径名。如果你想在你喜欢的某个浏览器打开该开发服务器，你可以设置环境变量 `process.env.BROWSER` （例如 `firefox`）。你还可以设置 `process.env.BROWSER_ARGS` 来传递额外的参数（例如 `--incognito`）。

`BROWSER` 和 `BROWSER_ARGS` 都是特殊的环境变量，你可以将它们放在 `.env` 文件中进行设置，欲了解更多打开浏览器的更多内部细节，请参阅 [`open` 包的源码](https://github.com/sindresorhus/open#app)。

**示例：**

```js
export default defineConfig({
  server: {
    open: '/docs/index.html',
  },
})
```

## server.proxy {#server-proxy}

* **类型：** `Record<string, string | ProxyOptions>`

为开发服务器配置自定义代理规则。期望接收一个 `{ key: options }` 对象。任何请求路径以 key 值开头的请求将被代理到对应的目标。如果 key 值以 `^` 开头，将被识别为 `RegExp`。`configure` 选项可用于访问 proxy 实例。如果请求匹配任何配置的代理规则，该请求将不会被 Vite 转换。

请注意，如果使用了非相对的 [基础路径 `base`](/config/shared-options.md#base)，则必须在每个 key 值前加上该 `base`。

继承自 [`http-proxy`](https://github.com/http-party/node-http-proxy#options)。完整选项详见 [此处](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/middlewares/proxy.ts#L13)。

在某些情况下，你可能也想要配置底层的开发服务器。（例如添加自定义的中间件到内部的 [connect](https://github.com/senchalabs/connect) 应用中）为了实现这一点，你需要编写你自己的 [插件](/guide/using-plugins.html) 并使用 [configureServer](/guide/api-plugin.html#configureserver) 函数。

**示例：**

```js
export default defineConfig({
  server: {
    proxy: {
      // 字符串简写写法：
      // http://localhost:5173/foo 
      // -> http://localhost:4567/foo
      '/foo': 'http://localhost:4567',
      // 带选项写法：
      // http://localhost:5173/api/bar 
      // -> http://jsonplaceholder.typicode.com/bar
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
      // 正则表达式写法：
      // http://localhost:5173/fallback/ 
      // -> http://jsonplaceholder.typicode.com/
      '^/fallback/.*': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/fallback/, ''),
      },
      // 使用 proxy 实例
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        configure: (proxy, options) => {
          // proxy 是 'http-proxy' 的实例
        }
      },
      // 代理 websockets 或 socket.io 写法：
      // ws://localhost:5173/socket.io 
      // -> ws://localhost:5174/socket.io
      // 在使用 `rewriteWsOrigin` 时要特别谨慎，因为这可能会让
      // 代理服务器暴露在 CSRF 攻击之下
      '/socket.io': {
        target: 'ws://localhost:5174',
        ws: true,
        rewriteWsOrigin: true,
      },
    },
  },
})
```

## server.cors {#server-cors}

* **类型：** `boolean | CorsOptions`
* **默认：** `{ origin: /^https?:\/\/(?:(?:[^:]+\.)?localhost|127\.0\.0\.1|\[::1\])(?::\d+)?$/ }` （允许 localhost、`127.0.0.1` 和 `::1`）

为开发服务器配置 CORS。传递一个 [选项对象](https://github.com/expressjs/cors#configuration-options) 来调整行为，或设置为 `true` 来允许任何源。

::: danger

将 `server.cors` 设置为 `true` 允许任何网站向你的开发服务器发送请求并下载你的源代码和内容。我们建议始终使用显式的允许来源列表。

:::

## server.headers {#server-headers}

* **类型：** `OutgoingHttpHeaders`

指定服务器响应的 header。

## server.hmr {#server-hmr}

* **类型：** `boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }`

禁用或配置 HMR 连接（用于 HMR websocket 必须使用不同的 http 服务器地址的情况）。

设置 `server.hmr.overlay` 为 `false` 可以禁用开发服务器错误的屏蔽。

`protocol` 是用于设置 HMR 连接使用的 WebSocket 协议的选项，可以是 `ws`（WebSocket）或者 `wss`（WebSocket Secure）。

`clientPort` 是一个高级选项，只在客户端的情况下覆盖端口，这允许你为 websocket 提供不同的端口，而并非在客户端代码中查找。如果需要在 dev-server 情况下使用 SSL 代理，这非常有用。

当 `server.hmr.server` 被定义后，Vite 将会通过所提供的的服务器来处理 HMR 连接。如果不是在中间件模式下，Vite 将尝试通过已有服务器处理 HMR 连接。这在使用自签证书或想通过网络在某端口暴露 Vite 的情况下，非常有用。

查看 [`vite-setup-catalogue`](https://github.com/sapphi-red/vite-setup-catalogue) 一节获取更多实例。

::: tip NOTE

在默认配置下, 在 Vite 之前的反向代理应该支持代理 WebSocket。如果 Vite HMR 客户端连接 WebSocket 失败，该客户端将兜底为绕过反向代理、直接连接 WebSocket 到 Vite HMR 服务器：

```
Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.
```

当该兜底策略偶然地可以被忽略时，这条报错将会出现在浏览器中。若要通过直接绕过反向代理来避免此错误，你可以:

* 将反向代理配置为代理 WebSocket
* 设置 [`server.strictPort = true`](#server-strictport) 并设置 `server.hmr.clientPort` 的值与 `server.port` 相同
* 设置 `server.hmr.port` 为一个与 [`server.port`](#server-port) 不同的值

:::

## server.warmup

* **类型：** `{ clientFiles?: string[], ssrFiles?: string[] }`
* **相关：** [预热常用文件](/guide/performance.html#warm-up-frequently-used-files)

提前转换和缓存文件以进行预热。可以在服务器启动时提高初始页面加载速度，并防止转换瀑布。

`clientFiles` 是仅在客户端使用的文件，而 `ssrFiles` 是仅在服务端渲染中使用的文件。它们接受相对于 `root` 的文件路径数组或 [`tinyglobby`](https://github.com/SuperchupuDev/tinyglobby) 模式。

请确保只添加经常使用的文件，以免在启动时过载 Vite 开发服务器。

```js
export default defineConfig({
  server: {
    warmup: {
      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],
      ssrFiles: ['./src/server/modules/*.js'],
    },
  },
})
```

## server.watch {#server-watch}

* **类型：** `object | null`

文件系统监视器选项传递给 [chokidar](https://github.com/paulmillr/chokidar/tree/3.6.0#api)。

Vite 服务器的文件监听器默认会监听 `root` 目录，同时会跳过 `.git/`、`node_modules/`，以及 Vite 的 `cacheDir` 和 `build.outDir` 这些目录。当监听到文件更新时，Vite 会应用 HMR 并且只在需要时更新页面。

如果设置为 `null`，则不会监视任何文件。`server.watcher` 将提供兼容的事件发射器，但调用 `add` 或 `unwatch` 将不起作用。

::: warning 监听 `node_modules` 中的文件

目前没有可行的方式来监听 `node_modules` 中的文件。若要了解更多详情和可能的临时替代方案，你可以关注 [issue #8619](https://github.com/vitejs/vite/issues/8619)。

:::

::: warning 在 Windows Linux 子系统（WSL）上使用 Vite

当需要在 Windows Subsystem for Linux (WSL) 2 上运行 Vite 时，如果项目文件夹位于 Windows 文件系统中，你需要将此选项设置为 `{ usePolling: true }`。这是由于 Windows 文件系统的 [WSL2 限制](https://github.com/microsoft/WSL/issues/4739) 造成的。

要解决这一问题，你可以采取以下两种办法之一：

* **推荐**：使用 WSL2 应用来编辑你的文件
  * 同时我们推荐将你的项目移出 Windows 文件系统，从 WSL2 访问 Windows 文件系统非常慢。移除这一开销将大大提升性能表现。
* 设置 `{ usePolling: true }`
  * 注意 [`usePolling` 会导致高 CPU 占用率](https://github.com/paulmillr/chokidar/tree/3.6.0#performance)

:::

## server.middlewareMode {#server-middlewaremode}

* **类型：** `boolean`
* **默认值：** `false`

以中间件模式创建 Vite 服务器。

* **相关：** [appType](./shared-options#apptype)，[SSR - 设置开发服务器](/guide/ssr#setting-up-the-dev-server)

* **示例：**

```js twoslash
import express from 'express'
import { createServer as createViteServer } from 'vite'

async function createServer() {
  const app = express()

  // 以中间件模式创建 Vite 服务器
  const vite = await createViteServer({
    server: { middlewareMode: true },
    appType: 'custom',
    // 不引入 Vite 默认的 HTML 处理中间件
  })
  // 将 vite 的 connect 实例作中间件使用
  app.use(vite.middlewares)

  app.use('*', async (req, res) => {
    // 由于 `appType` 的值是 `'custom'`，因此应在此处提供响应。
    // 请注意：如果 `appType` 值为 `'spa'` 或 `'mpa'`，Vite 会包含
    // 处理 HTML 请求和 404 的中间件，因此用户中间件应该在
    // Vite 的中间件之前添加，以确保其生效。
  })
}

createServer()
```

## server.fs.strict {#server-fs-strict}

* **类型：** `boolean`
* **默认：** `true` (自 Vite 2.7 起默认启用)

限制为工作区 root 路径以外的文件的访问。

## server.fs.allow {#server-fs-allow}

* **类型：** `string[]`

限制哪些文件可以通过 `/@fs/` 路径提供服务。当 `server.fs.strict` 设置为 true 时，访问这个目录列表外的文件将会返回 403 结果。

可以提供目录和文件。

Vite 将会搜索此根目录下潜在工作空间并作默认使用。一个有效的工作空间应符合以下几个条件，否则会默认以 [项目 root 目录](/guide/#index-html-and-project-root) 作备选方案。

* 在 `package.json` 中包含 `workspaces` 字段
* 包含以下几种文件之一
  * `lerna.json`
  * `pnpm-workspace.yaml`

接受一个路径作为自定义工作区的 root 目录。可以是绝对路径或是相对于 [项目 root 目录](/guide/#index-html-and-project-root) 的相对路径。示例如下：

```js
export default defineConfig({
  server: {
    fs: {
      // 允许为项目根目录的上一级提供服务
      allow: ['..']
    }
  }
})
```

当 `server.fs.allow` 被设置时，工作区根目录的自动检索将被禁用。当需要扩展默认的行为时，你可以使用暴露出来的工具函数 `searchForWorkspaceRoot`：

```js
import { defineConfig, searchForWorkspaceRoot } from 'vite'

export default defineConfig({
  server: {
    fs: {
      allow: [
        // 搜索工作区的根目录
        searchForWorkspaceRoot(process.cwd()),
        // 自定义规则
        '/path/to/custom/allow_directory',
        '/path/to/custom/allow_file.demo',
      ],
    },
  },
})
```

## server.fs.deny {#server-fs-deny}

* **类型：** `string[]`
* **默认：** `['.env', '.env.*', '*.{crt,pem}', '**/.git/**']`

用于限制 Vite 开发服务器提供敏感文件的黑名单。这会比 [`server.fs.allow`](#server-fs-allow) 选项的优先级更高。同时还支持 [picomatch 模式](https://github.com/micromatch/picomatch#globbing-features)。

::: tip NOTE

此黑名单不适用于[公共目录](/guide/assets.md#the-public-directory)。公共目录中的所有文件均未经任何过滤，因为它们会在构建过程中直接复制到输出目录。

:::

## server.origin {#server-origin}

* **类型：** `string`

用于定义开发调试阶段生成资源的 origin。

```js
export default defineConfig({
  server: {
    origin: 'http://127.0.0.1:8080',
  },
})
```

## server.sourcemapIgnoreList {#server-sourcemapignorelist}

* **类型：** `false | (sourcePath: string, sourcemapPath: string) => boolean`
* **默认：** `(sourcePath) => sourcePath.includes('node_modules')`

是否忽略服务器 sourcemap 中的源文件，用于填充 [`x_google_ignoreList` source map 扩展](https://developer.chrome.com/articles/x-google-ignore-list/)。

对开发服务器来说 `server.sourcemapIgnoreList` 等价于 [`build.rollupOptions.output.sourcemapIgnoreList`](https://cn.rollupjs.org/configuration-options/#output-sourcemapignorelist)。两个配置选项之间的区别在于，rollup 函数使用相对路径调用 `sourcePath`，而 `server.sourcemapIgnoreList` 使用绝对路径调用。在开发过程中，大多数模块的映射和源文件位于同一个文件夹中，因此 `sourcePath` 的相对路径就是文件名本身。在这些情况下，使用绝对路径更加方便。

默认情况下，它会排除所有包含 `node_modules` 的路径。你可以传递 `false` 来禁用此行为，或者为了获得完全的控制，可以传递一个函数，该函数接受源路径和 sourcemap 的路径，并返回是否忽略源路径。

```js
export default defineConfig({
  server: {
    // 这是默认值，它将把所有路径中含有 node_modules 的文件
    // 添加到忽略列表中。
    sourcemapIgnoreList(sourcePath, sourcemapPath) {
      return sourcePath.includes('node_modules')
    },
  },
})
```

::: tip 注意
需要单独设置 [`server.sourcemapIgnoreList`](#server-sourcemapignorelist) 和 [`build.rollupOptions.output.sourcemapIgnoreList`](https://cn.rollupjs.org/configuration-options/#output-sourcemapignorelist)。`server.sourcemapIgnoreList` 是一个仅适用于服务端的配置，并不从定义好的 rollup 选项中获得其默认值。
:::

---

---
url: /deploy.md
---
# 开始 {#getting-started}

## 总览 {#overview}

|           名称           | 访问地址                                                                                                                                             | 备注                                   |
|:----------------------:|--------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|
|    无代码平台测试环境     | 内网：https://192.168.181.101:8081 域名：https://sieaio.xueying.site:7081外网ip：https://218.13.91.107:7081                                     | adminSie@admin123                   |
|    无代码平台正式环境     | 内网：https://192.168.181.101:81 域名：https://sieaio.xueying.site:8182外网ip：https://218.13.91.107:8182                                       | adminSie@admin123                   |
|           谷神           | 内网：https://192.168.181.101:8080 域名：https://sieaio.xueying.site:7080外网ip：https://218.13.91.107:7080                                     |                                      |
|         mysql          | 域名：sieaio.xueying.site:6083外网ip：218.13.91.107:6083                                                               |                                      |
|           -            |                                                                                                                                                  |                                      |
|       portainer        | http://192.168.184.124:9000                                                                                                                      | adminSie@admin123                   |
|           -            |                                                                                                                                                  |                                      |
|        jenkins         | http://192.168.181.101:1011/                                                                                                                     | jenkins/Jenkins@0224aucma/aucma |
|           -            |                                                                                                                                                  |                                      |
|         aucma          | 内网：http://192.168.181.101:2067 内网：https://192.168.184.124:6081 域名：https://sieaio.xueying.site:6081外网ip：https://218.13.91.107:6081 |                                      |
|           -            |                                                                                                                                                  |                                      |
|          Dify          | 内网：http://192.168.184.124 内网：https://192.168.184.124:6082 域名：https://sieaio.xueying.site:6082外网ip：https://218.13.91.107:6082      | shenpeiheng@chinasie.comSie123456   |
|           -            |                                                                                                                                                  |                                      |

## Old {#old}

|           名称           | 访问地址                                                                                                                                             | 备注                                   |
|:----------------------:|--------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|
| ~~Odoo社区版广东品度能源~~ | ~~内网：http://192.168.181.101域名：https://sieaio.xueying.site:8181外网：http://218.13.91.107:8181~~                                           | ~~admin/admin@2024!~~                |
|  ~~Odoo社区版SIE~~   | ~~内网：http://192.168.181.101:81外网：http://218.13.91.107:8182~~                                                                                | ~~admin/admin@2024!~~                |
|    ~~ERPNext 8080~~    | ~~内网：https://192.168.181.101:8080域名：https://sieaio.xueying.site:7080外网：https://218.13.91.107:7080~~                                    | ~~administrator/admin~~              |
|                        | ~~vscode：http://192.168.181.101:7891/~~                                                                                                          | ~~123456~~                           |
|    ~~ERPNext 8081~~    | ~~内网：https://192.168.181.101:8081域名：https://sieaio.xueying.site:7081外网：https://218.13.91.107:7081~~                                    | ~~administrator/admin~~              |
|                        | ~~vscode：http://192.168.181.101:7890/~~                                                                                                          | ~~123456~~                           |
|     ~~ERPNext 81~~     | ~~内网：https://192.168.181.101:81外网：https://218.13.91.107:8182~~                                                                              | ~~administrator/admin~~              |
|                        | ~~vscode：http://192.168.181.101:7892/~~                                                                                                          | ~~sie123456~~                        |
|     ~~Prometheus~~     | ~~http://192.168.181.101:9090/~~                                                                                                                 |                                      |
|      ~~Grafana~~       | ~~http://192.168.181.101:3000/~~                                                                                                                 | ~~admin/admin123~~                   |
|           -            |                                                                                                                                                  |                                      |
|   Odoo社区版SIE测试    | 内网：http://192.168.174.122:8069外网：http://218.13.91.107:3380/web/                                                                             | shenpeiheng@chinasie.com123456      |
|   Odoo企业版SIE测试    | 内网：http://192.168.174.122:18069外网：http://218.13.91.107:3080/web/                                                                            | admin/admin                          |
|           -            |                                                                                                                                                  |                                      |
|       在线Pycharm        | pycharm：http://192.168.174.122:8887 預覽：http://192.168.174.122:8886                                                                          |                                      |
|           -            |                                                                                                                                                  |                                      |
|         星云erp          | 内网：http://192.168.174.122:8070/外网：http://218.13.91.107:3080/xyerp/                                                                          |                                      |
|       AutoMeter        | 内网：http://192.168.174.122:48084/                                                                                                                 | admin/admin123                       |
|           -            |                                                                                                                                                  |                                      |
|         Ollama         | 内网：http://192.168.174.122:2375                                                                                                                   |                                      |
|       Open WebUI       | 内网：http://192.168.174.122:8000/                                                                                                                  | shenpeiheng@chinasie.com123456      |
|        Lobehub         | 内网：http://192.168.174.122:3210/chat                                                                                                              |                                      |
|      Anythingllm       | 内网：http://192.168.174.122:3001/                                                                                                                  |                                      |
|        FastGPT         | 内网：http://192.168.174.122:3000/                                                                                                                  | root/1234                            |
|          Dify          | 内网：http://192.168.184.124                                                                                                                        | shenpeiheng@chinasie.comSie123456   |
|         Gradio         | 内网：http://192.168.174.122:8100                                                                                                                   |                                      |
|           -            |                                                                                                                                                  |                                      |
|       Excalidraw       | 内网：http://192.168.174.122:51001                                                                                                                  |                                      |
|        Mermaid         | 内网：http://192.168.174.122:51002                                                                                                                  |                                      |
|        PlantUML        | 内网：http://192.168.174.122:51003                                                                                                                  |                                      |
|         Drawio         | 内网：http://192.168.174.122:51004                                                                                                                  |                                      |

---

---
url: /guide.md
---
# 开始 {#getting-started}

## 总览 {#overview}

Vite（法语意为 "快速的"，发音 `/vit/`，发音同 "veet"）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：

* 一个开发服务器，它基于 [原生 ES 模块](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 提供了 [丰富的内建功能](./features)，如速度快到惊人的 [模块热替换（HMR）](./features#hot-module-replacement)。

* 一套构建指令，它使用 [Rollup](https://cn.rollupjs.org) 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。

Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 [功能指南](./features) 中了解 Vite 的各种可能性。通过 [插件](./using-plugins)，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 [配置部分](../config/) 自定义适应你的项目。

Vite 还提供了强大的扩展性，可通过其 [插件 API](./api-plugin) 和 [JavaScript API](./api-javascript) 进行扩展，并提供完整的类型支持。

你可以在 [为什么选 Vite](./why) 部分深入了解该项目的设计理念。

## 浏览器支持 {#browser-support}

在开发阶段，Vite 将 [`esnext` 作为转换目标](https://esbuild.github.io/api/#target)，因为我们假设使用的是现代浏览器，它支持所有最新的 JavaScript 和 CSS 特性。这样可以防止语法降级，让 Vite 尽可能地接近原始源代码。

对于生产构建，默认情况下 Vite 的目标浏览器支持 [原生 ES 模块](https://caniuse.com/es6-module)、[原生 ESM 动态导入](https://caniuse.com/es6-module-dynamic-import)、[`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta)、[nullish coalescing](https://caniuse.com/mdn-javascript_operators_nullish_coalescing) 和 [BigInt](https://caniuse.com/bigint)。旧版浏览器可以通过官方的 [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)。查看 [构建生产环境](./build) 了解更多细节。

## 在线试用 Vite {#trying-vite-online}

你可以通过 [StackBlitz](https://vite.new/) 在线试用 vite。它直接在浏览器中运行基于 Vite 的构建，因此它与本地开发几乎无差别，同时无需在你的机器上安装任何东西。你可以浏览 `vite.new/{template}` 来选择你要使用的框架。

目前支持的模板预设如下：

|             JavaScript              |                TypeScript                 |
| :---------------------------------: | :---------------------------------------: |
| [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |
|     [vue](https://vite.new/vue)     |     [vue-ts](https://vite.new/vue-ts)     |
|   [react](https://vite.new/react)   |   [react-ts](https://vite.new/react-ts)   |
|  [preact](https://vite.new/preact)  |  [preact-ts](https://vite.new/preact-ts)  |
|     [lit](https://vite.new/lit)     |     [lit-ts](https://vite.new/lit-ts)     |
|  [svelte](https://vite.new/svelte)  |  [svelte-ts](https://vite.new/svelte-ts)  |
|   [solid](https://vite.new/solid)   |   [solid-ts](https://vite.new/solid-ts)   |
|    [qwik](https://vite.new/qwik)    |    [qwik-ts](https://vite.new/qwik-ts)    |

## 搭建第一个 Vite 项目 {#scaffolding-your-first-vite-project}

::: tip 兼容性注意
Vite 需要 [Node.js](https://nodejs.org/en/) 版本 18+ 或 20+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。
:::

::: code-group

```bash [npm]
$ npm create vite@latest
```

```bash [Yarn]
$ yarn create vite
```

```bash [pnpm]
$ pnpm create vite
```

```bash [Bun]
$ bun create vite
```

```bash [Deno]
$ deno init --npm vite
```

:::

然后按照提示操作即可！

你还可以通过附加的命令行选项直接指定项目名称和你想要使用的模板。例如，要构建一个 Vite + Vue 项目，运行:

::: code-group

```bash [npm]
# npm 7+，需要添加额外的 --：
$ npm create vite@latest my-vue-app -- --template vue
```

```bash [Yarn]
$ yarn create vite my-vue-app --template vue
```

```bash [pnpm]
$ pnpm create vite my-vue-app --template vue
```

```bash [Bun]
$ bun create vite my-vue-app --template vue
```

```bash [Deno]
$ deno init --npm vite my-vue-app --template vue
```

:::

查看 [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) 以获取每个模板的更多细节：`vanilla`，`vanilla-ts`，`vue`，`vue-ts`，`react`，`react-ts`，`react-swc`，`react-swc-ts`，`preact`，`preact-ts`，`lit`，`lit-ts`，`svelte`，`svelte-ts`，`solid`，`solid-ts`，`qwik`，`qwik-ts`。

你可以使用 `.` 作为项目名称，在当前目录中创建项目脚手架。

## 社区模板 {#community-templates}

create-vite 是一个快速生成主流框架基础模板的工具。查看 Awesome Vite 仓库的 [社区维护模板](https://github.com/vitejs/awesome-vite#templates)，里面包含各种工具和不同框架的模板。

对于一个 `https://github.com/user/project` 中的模板，可以尝试使用 `https://github.stackblitz.com/user/project`（即在项目 URL 的 `github` 后添加 `.stackblitz`）。

你也可以用如 [degit](https://github.com/Rich-Harris/degit) 之类的工具，使用社区模版来搭建项目。假设项目在 GitHub 上并使用 `main` 作为默认分支，可以使用以下命令创建本地副本：

```bash
npx degit user/project#main my-project
cd my-project

npm install
npm run dev
```

## 手动安装 {#manual-installation}

在你的项目中，可以用以下方法来安装 `vite` 命令行工具：

::: code-group

```bash [npm]
$ npm install -D vite
```

```bash [Yarn]
$ yarn add -D vite
```

```bash [pnpm]
$ pnpm add -D vite
```

```bash [Bun]
$ bun add -D vite
```

```bash [Deno]
$ deno add -D npm:vite
```

:::

并创建一个像这样的 `index.html` 文件：

```html
<p>Hello Vite!</p>
```

然后在终端上运行相应的命令:

::: code-group

```bash [npm]
$ npx vite
```

```bash [Yarn]
$ yarn vite
```

```bash [pnpm]
$ pnpm vite
```

```bash [Bun]
$ bunx vite
```

```bash [Deno]
$ deno run -A npm:vite
```

:::

之后就可以在 `http://localhost:5173` 上访问 `index.html`。

## `index.html` 与项目根目录 {#index-html-and-project-root}

你可能已经注意到，在一个 Vite 项目中，`index.html` 在项目最外层而不是在 `public` 文件夹内。这是有意而为之的：在开发期间 Vite 是一个服务器，而 `index.html` 是该 Vite 项目的入口文件。

Vite 将 `index.html` 视为源码和模块图的一部分。Vite 解析 `<script type="module" src="...">` ，这个标签指向你的 JavaScript 源码。甚至内联引入 JavaScript 的 `<script type="module">` 和引用 CSS 的 `<link href>` 也能利用 Vite 特有的功能被解析。另外，`index.html` 中的 URL 将被自动转换，因此不再需要 `%PUBLIC_URL%` 占位符了。

与静态 HTTP 服务器类似，Vite 也有 “根目录” 的概念，即服务文件的位置，在接下来的文档中你将看到它会以 `<root>` 代称。源码中的绝对 URL 路径将以项目的 “根” 作为基础来解析，因此你可以像在普通的静态文件服务器上一样编写代码（并且功能更强大！）。Vite 还能够处理依赖关系，解析处于根目录外的文件位置，这使得它即使在基于 monorepo 的方案中也十分有用。

Vite 也支持多个 `.html` 作入口点的 [多页面应用模式](./build#multi-page-app)。

#### 指定替代根目录 {#specifying-alternative-root}

执行 `vite` 命令会以当前工作目录作为根目录启动开发服务器。你也可以通过 `vite serve some/sub/dir` 来指定一个不同的根目录。
需要注意的是，Vite 也会在项目的根目录中寻找 [它的配置文件（即 `vite.config.js`）](/config/#configuring-vite)，所以如果更改了根目录，你需要将配置文件一起移动过去。

## 命令行接口 {#command-line-interface}

在安装了 Vite 的项目中，可以在 npm scripts 中使用 `vite` 可执行文件，或者直接使用 `npx vite` 运行它。下面是通过脚手架创建的 Vite 项目中默认的 npm scripts：

```json [package.json]
{
  "scripts": {
    "dev": "vite", // 启动开发服务器，别名：`vite dev`，`vite serve`
    "build": "vite build", // 为生产环境构建产物
    "preview": "vite preview" // 本地预览生产构建产物
  }
}
```

可以指定额外的命令行选项，如 `--port` 或 `--open`。运行 `npx vite --help` 获得完整的命令行选项列表。

查看 [命令行接口](./cli.md) 了解更多细节。

## 使用未发布的功能 {#using-unreleased-commits}

如果你迫不及待想要体验最新的功能，可以使用 https://pkg.pr.new 安装特定的 Vite 提交：

::: code-group

```bash [npm]
$ npm install -D https://pkg.pr.new/vite@SHA
```

```bash [Yarn]
$ yarn add -D https://pkg.pr.new/vite@SHA
```

```bash [pnpm]
$ pnpm add -D https://pkg.pr.new/vite@SHA
```

```bash [Bun]
$ bun add -D https://pkg.pr.new/vite@SHA
```

:::

将 `SHA` 替换为 [Vite 的提交 SHA](https://github.com/vitejs/vite/commits/main/)。请注意，仅最近一个月的提交有效，旧版本提交的构建产物会被清除。

或者，你可以克隆 [Vite 代码仓库](https://github.com/vitejs/vite) 到本地，自行构建并建立软链接（需安装 [pnpm](https://pnpm.io/)）：

```bash
git clone https://github.com/vitejs/vite.git
cd vite
pnpm install
cd packages/vite
pnpm run build
pnpm link --global # 在这一步中可使用你喜欢的包管理器
```

然后，回到你的 Vite 项目并运行 `pnpm link --global vite`（或者使用你的其他包管理工具来全局链接 `vite`）。重新启动开发服务器来体验新功能吧！

::: tip 处理依赖中的 Vite 版本
若需替换依赖链中传递使用的 Vite 版本（Transitive Dependencies），应使用 [npm overrides](https://docs.npmjs.com/cli/v11/configuring-npm/package-json#overrides) 或 [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides)。
:::

## 社区 {#community}

如果你有疑问或者需要帮助，可以到 [Discord](https://chat.vite.dev) 和 [GitHub Discussions](https://github.com/vitejs/vite/discussions) 社区来寻求帮助。

---

---
url: /guide/cli.md
---
# 命令行接口 {#command-line-interface}

## 开发服务器 {#dev-server}

### `vite` {#vite}

在当前目录下启动 Vite 开发服务器。`vite dev` 和 `vite serve` 是 `vite` 的别名。

#### 使用 {#usage}

```bash
vite [root]
```

#### 选项 {#options}

| 选项                      |                                                                                               |
| ------------------------- | --------------------------------------------------------------------------------------------- |
| `--host [host]`           | 指定主机名称 (`string`)                                                                       |
| `--port <port>`           | 指定端口 (`number`)                                                                           |
| `--open [path]`           | 启动时打开浏览器 (`boolean \| string`)                                                        |
| `--cors`                  | 启用 CORS (`boolean`)                                                                         |
| `--strictPort`            | 如果指定的端口已在使用中，则退出 (`boolean`)                                                  |
| `--force`                 | 强制优化器忽略缓存并重新构建 (`boolean`)                                                      |
| `-c, --config <file>`     | 使用指定的配置文件 (`string`)                                                                 |
| `--base <path>`           | 公共基础路径（默认为：`/`）(`string`)                                                         |
| `-l, --logLevel <level>`  | info | warn | error | silent (`string`)                                                    |
| `--clearScreen`           | 允许或禁用打印日志时清除屏幕 (`boolean`)                                                      |
| `--configLoader <loader>` | 使用 `bundle` 来采用 esbuild 打包配置，或是 `runner`（实验性）来在运行时处理，默认是 `bundle` |
| `--profile`               | 启动内置的 Node.js 调试器（查看 [性能瓶颈](/guide/troubleshooting#performance-bottlenecks)）  |
| `-d, --debug [feat]`      | 显示调试日志 (`string \| boolean`)                                                            |
| `-f, --filter <filter>`   | 过滤调试日志 (`string`)                                                                       |
| `-m, --mode <mode>`       | 设置环境模式 (`string`)                                                                       |
| `-h, --help`              | 显示可用的 CLI 选项                                                                           |
| `-v, --version`           | 显示版本号                                                                                    |

## 构建 {#build}

### `vite build` {#vite-build}

构建生产版本。

#### 使用 {#usage-1}

```bash
vite build [root]
```

#### 选项 {#options-1}

| 选项                           |                                                                                                                                          |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `--target <target>`            | 编译目标（默认为：`"modules"`）(`string`)                                                                                                |
| `--outDir <dir>`               | 输出目录（默认为：`dist`）(`string`)                                                                                                     |
| `--assetsDir <dir>`            | 在输出目录下放置资源的目录（默认为：`"assets"`）(`string`)                                                                               |
| `--assetsInlineLimit <number>` | 静态资源内联为 base64 编码的阈值，以字节为单位（默认为：`4096`）(`number`)                                                               |
| `--ssr [entry]`                | 为服务端渲染配置指定入口文件 (`string`)                                                                                                  |
| `--sourcemap [output]`         | 构建后输出 source map 文件（默认为：`false`）(`boolean \| "inline" \| "hidden"`)                                                         |
| `--minify [minifier]`          | 允许或禁用最小化混淆，或指定使用哪种混淆器（默认为：`"esbuild"`）(`boolean \| "terser" \| "esbuild"`)                                    |
| `--manifest [name]`            | 构建后生成 manifest.json 文件 (`boolean \| string`)                                                                                      |
| `--ssrManifest [name]`         | 构建后生成 SSR manifest.json 文件 (`boolean \| string`)                                                                                  |
| `--emptyOutDir`                | 若输出目录在根目录外，强制清空输出目录 (`boolean`)                                                                                       |
| `-w, --watch`                  | 在磁盘中模块发生变化时，重新构建 (`boolean`)                                                                                             |
| `-c, --config <file>`          | 使用指定的配置文件 (`string`)                                                                                                            |
| `--base <path>`                | 公共基础路径（默认为：`/`）(`string`)                                                                                                    |
| `-l, --logLevel <level>`       | Info | warn | error | silent (`string`)                                                                                               |
| `--clearScreen`                | 允许或禁用打印日志时清除屏幕 (`boolean`)                                                                                                 |
| `--configLoader <loader>`      | 使用 `bundle` 来采用 esbuild 打包配置，或是 `runner`（实验性）来在运行时处理，或者使用原生运行时加载 `native`（实验性），默认是 `bundle` |
| `--profile`                    | 启动内置的 Node.js 调试器（查看 [性能瓶颈](/guide/troubleshooting#performance-bottlenecks)）                                             |
| `-d, --debug [feat]`           | 显示调试日志 (`string \| boolean`)                                                                                                       |
| `-f, --filter <filter>`        | 过滤调试日志 (`string`)                                                                                                                  |
| `-m, --mode <mode>`            | 设置环境模式 (`string`)                                                                                                                  |
| `-h, --help`                   | 显示可用的 CLI 选项                                                                                                                      |
| `--app`                        | 构建所有环境，这与 `builder: {}` 是一样的（`boolean`，实验性）                                                                           |

## 其他 {#others}

### `vite optimize` {#vite-optimize}

预构建依赖。

**Deprecated**: 预构建过程自动运行，不需要调用。

#### 使用 {#usage-2}

```bash
vite optimize [root]
```

#### 选项 {#options-2}

| 选项                      |                                                                                               |
| ------------------------- | --------------------------------------------------------------------------------------------- |
| `--force`                 | 强制优化器忽略缓存并重新构建 (`boolean`)                                                      |
| `-c, --config <file>`     | 使用指定的配置文件 (`string`)                                                                 |
| `--base <path>`           | 公共基础路径（默认为：`/`）(`string`)                                                         |
| `-l, --logLevel <level>`  | Info | warn | error | silent (`string`)                                                    |
| `--clearScreen`           | 允许或禁用打印日志时清除屏幕 (`boolean`)                                                      |
| `--configLoader <loader>` | 使用 `bundle` 来采用 esbuild 打包配置，或是 `runner`（实验性）来在运行时处理，默认是 `bundle` |
| `-d, --debug [feat]`      | 显示调试日志 (`string \| boolean`)                                                            |
| `-f, --filter <filter>`   | 过滤调试日志 (`string`)                                                                       |
| `-m, --mode <mode>`       | 设置环境模式 (`string`)                                                                       |
| `-h, --help`              | 显示可用的 CLI 选项                                                                           |

### `vite preview` {#vite-preview}

本地预览构建产物。不要将其用作生产服务器，因为它不是为此而设计的。

#### 使用 {#usage-3}

```bash
vite preview [root]
```

#### 选项 {#options-3}

| 选项                      |                                                                                               |
| ------------------------- | --------------------------------------------------------------------------------------------- |
| `--host [host]`           | 指定主机名称 (`string`)                                                                       |
| `--port <port>`           | 指定端口 (`number`)                                                                           |
| `--strictPort`            | 如果指定的端口已在使用中，则退出 (`boolean`)                                                  |
| `--open [path]`           | 启动时打开浏览器 (`boolean \| string`)                                                        |
| `--outDir <dir>`          | 输出目录（默认为：`dist`)(`string`)                                                           |
| `-c, --config <file>`     | 使用指定的配置文件 (`string`)                                                                 |
| `--base <path>`           | 公共基础路径（默认为：`/`）(`string`)                                                         |
| `-l, --logLevel <level>`  | Info | warn | error | silent (`string`)                                                    |
| `--clearScreen`           | 允许或禁用打印日志时清除屏幕 (`boolean`)                                                      |
| `--configLoader <loader>` | 使用 `bundle` 来采用 esbuild 打包配置，或是 `runner`（实验性）来在运行时处理，默认是 `bundle` |
| `-d, --debug [feat]`      | 显示调试日志 (`string \| boolean`)                                                            |
| `-f, --filter <filter>`   | 过滤调试日志 (`string`)                                                                       |
| `-m, --mode <mode>`       | 设置环境模式 (`string`)                                                                       |
| `-h, --help`              | 显示可用的 CLI 选项                                                                           |

---

---
url: /guide/troubleshooting.md
---
# 排错指南 {#troubleshooting}

> 你还可以查看 [Rollup 的故障排除指南](https://cn.rollupjs.org/troubleshooting/) 了解更多。

如果这里的建议并未帮助到你，请将你的问题发送到 [GitHub 讨论区](https://github.com/vitejs/vite/discussions) 或 [Vite Land Discord](https://chat.vite.dev) 的 `#help` 频道。

## CJS

### Vite CJS Node API deprecated {#vite-cjs-node-api-deprecated}

Vite 的 CJS Node API 构建已经被废弃，并将在 Vite 6 中移除。查看 [GitHub 讨论区](https://github.com/vitejs/vite/discussions/13928) 了解更多背景信息。你应该更新你的文件或框架来导入 Vite 的 ESM 构建。

在一个基础的 Vite 项目中，请确保：

1. `vite.config.js` 配置文件的内容使用 ESM 语法。
2. 最近的 `package.json` 文件中有 `"type": "module"`，或者使用 `.mjs`/`.mts` 扩展名，例如 `vite.config.mjs` 或者 `vite.config.mts`。

对于其他项目，有几种常见的方法：

* **配置 ESM 为默认，如果需要则选择 CJS：** 在项目 `package.json` 中添加 `"type": "module"`。所有 `*.js` 文件现在都被解释为 ESM，并且需要使用 ESM 语法。你可以将一个文件重命名为 `.cjs` 扩展名来继续使用 CJS。
* **保持 CJS 为默认，如果需要则选择 ESM：** 如果项目 `package.json` 没有 `"type": "module"`，所有 `*.js` 文件都被解释为 CJS。你可以将一个文件重命名为 `.mjs` 扩展名来使用 ESM。
* **动态导入 Vite：** 如果你需要继续使用 CJS，你可以使用 `import('vite')` 动态导入 Vite。这要求你的代码必须在一个 `async` 上下文中编写，但是由于 Vite 的 API 大多是异步的，所以应该还是可以管理的。

如果你不确定警告来自哪里，你可以通过 `VITE_CJS_TRACE=true` 标志运行你的脚本来记录堆栈跟踪：

```bash
VITE_CJS_TRACE=true vite dev
```

如果你想暂时忽略警告，你可以通过 `VITE_CJS_IGNORE_WARNING=true` 标志运行你的脚本：

```bash
VITE_CJS_IGNORE_WARNING=true vite dev
```

请注意，postcss 配置文件还不支持 ESM + TypeScript（`"type": "module"` 中的 `.mts` 或 `.ts`）。如果你有带 `.ts` 的 postcss 配置，并在 package.json 中添加了 `"type": "module"`，你还需要将 postcss 配置重命名为 `.cts`。

## CLI {#cli}

### `Error: Cannot find module 'C:\foo\bar&baz\vite\bin\vite.js'` {#error-cannot-find-module-cfoobarbazvitebinvitejs}

你的项目文件夹路径中可能包含了符号 `&`，这在 Windows 上无法与 `npm` 配合正常工作 ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45))。

你可以选择以下两种修改方式：

* 切换另一种包管理工具（例如 `pnpm` 或 `yarn`）
* 从你的项目路径中移除符号 `&`

## 配置 {#config}

### 该包仅支持 ESM {#this-package-is-esm-only}

当使用 `require` 导入一个仅支持 ESM 的包时，会出现以下错误。

> Failed to resolve "foo". This package is ESM only but it was tried to load by `require`.

> Error \[ERR\_REQUIRE\_ESM]: require() of ES Module /path/to/dependency.js from /path/to/vite.config.js not supported.
> Instead change the require of index.js in /path/to/vite.config.js to a dynamic import() which is available in all CommonJS modules.

在 Node.js <=22 中，ESM 文件默认情况下无法通过 [`require`](https://nodejs.org/docs/latest-v22.x/api/esm.html#require) 加载。

虽然使用 [`--experimental-require-module`](https://nodejs.org/docs/latest-v22.x/api/modules.html#loading-ecmascript-modules-using-require)、Node.js >22 或其他运行时也可能有效，但我们仍建议通过这两种方式之一将配置转换为 ESM：

* 在邻近的 `package.json` 中添加 `"type": "module"`
* 将 `vite.config.js`/`vite.config.ts` 重命名为 `vite.config.mjs`/`vite.config.mts`

## 开发服务器 {#dev-server}

### 请求始终停滞 {#requests-are-stalled-forever}

如果你使用的是 Linux，文件描述符限制和 inotify 限制可能会导致这个问题。由于 Vite 不会打包大多数文件，浏览器可能会请求许多文件，而相应地需要许多文件描述符，因此超过了限制。

要解决这个问题：

* 使用 `ulimit` 增加文件描述符的限制

  ```shell
  # 查看当前限制值
  $ ulimit -Sn
  # （暂时）更改限制值
  $ ulimit -Sn 10000 # 你可能也需要更改硬性限制值
  # 重启你的浏览器
  ```

* 通过 `sysctl` 提升下列 inotify 相关的限制

  ```shell
  # 查看当前限制值
  $ sysctl fs.inotify
  # （暂时）更改限制值
  $ sudo sysctl fs.inotify.max_queued_events=16384
  $ sudo sysctl fs.inotify.max_user_instances=8192
  $ sudo sysctl fs.inotify.max_user_watches=524288
  ```

如果通过以上步骤仍不起作用，可以尝试在以下文件中添加 `DefaultLimitNOFILE=65536` 配置。

* /etc/systemd/system.conf
* /etc/systemd/user.conf

对于 Ubuntu Linux 操作系统，你可能需要添加一行 `* - nofile 65536` 到文件 `/etc/security/limits.conf` 之中，而不是更新 systemd 配置文件。

请注意，这些配置会持久作用，但需要 **重新启动**。

或者，如果服务器在 VS Code devcontainer 中运行，请求可能会出现停滞。要修复此问题，请参阅
[Dev Containers / VS Code Port Forwarding](#dev-containers-vs-code-port-forwarding)。

### 网络请求停止加载 {#network-requests-stop-loading}

使用自签名SSL证书时，Chrome 会忽略所有缓存指令并重新加载内容。而 Vite 依赖于这些缓存指令。

要解决此问题，请使用受信任的SSL证书。

请查看：[缓存问题](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html) 和相关的 [Chrome issue](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)

#### macOS

您可以使用以下命令通过 CLI 安装受信任的证书：

```
security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer
```

或者，通过将其导入 Keychain Access 应用程序并将您的证书的信任更新为“始终信任”。

### 431 Request Header Fields Too Large {#\_431-request-header-fields-too-large}

当服务器或 WebSocket 服务收到一个较大的 HTTP 头，该请求可能会被遗落并且会显示下面这样的警告。

> Server responded with status code 431. See https://vite.dev/guide/troubleshooting.html#\_431-request-header-fields-too-large.

这是由于 Node.js 限制请求头大小，以减轻 [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121) 的影响。

要避免这个问题，请尝试减小请求头大小。举个例子，如果 cookie 太长，请删除它。或者你可以使用 [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize) 来更改最大请求头大小。

### 开发容器 / VS Code 端口转发

如果你正在使用开发容器或 VS Code 的端口转发功能，可能需要在配置中将 [`server.host`](/config/server-options.md#server-host) 选项设置为 `127.0.0.1` 才能使其正常工作。

这是因为 [VS Code 的端口转发功能不支持 IPv6](https://github.com/microsoft/vscode-remote-release/issues/7029)。

更多详情请参阅 [#16522](https://github.com/vitejs/vite/issues/16522)。

## HMR

### Vite 检测到文件变化，但 HMR 不工作 {#vite-detects-a-file-change-but-the-hmr-is-not-working}

你可能导入了一个拥有不同大小写的文件，例如，存在 `src/foo.js` 文件而 `src/bar.js` 导入了它：

```js
import './Foo.js' // 应该为 './foo.js'
```

相关 issue：[#964](https://github.com/vitejs/vite/issues/964)

### Vite 没有检测到文件变化 {#vite-does-not-detect-a-file-change}

如果你正在 WSL2 中运行 Vite，Vite 无法在某些场景下监听文件变化。请查看 [`server.watch` 选项](/config/server-options.md#server-watch) 的描述。

### 完全重新加载了，而不是 HMR {#a-full-reload-happens-instead-of-hmr}

如果 HMR 不是由 Vite 或一个插件处理的，那么将进行完全的重新加载，因为这是唯一刷新状态的方式。

如果 HMR 被处理了，但是在循环依赖中，那么也会发生完全的重新加载，以恢复执行顺序。要解决这个问题，请尝试打破循环。你可以运行 `vite --debug hmr` 来记录循环依赖路径，如果文件变化触发了它。

## 构建 {#build}

### 构建产物因为 CORS 错误无法工作 {#built-file-does-not-work-because-of-cors-error}

如果导出的 HTML 文件是通过 `file` 协议打开的，那么其中的 script 将不会运行，且报告下列错误。

> Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

> Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).

请查看 [释因：CORS 请求不是 HTTP 请求 - HTTP | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) 了解为什么会发生这种情况的更多信息。

你需要通过 `http` 协议访问该文件。最简单的办法就是使用 `npx vite preview`。

## 优化依赖 {#optimize-dependencies}

### 链接本地包时过期预构建依赖项 {#outdated-pre-bundled-deps-when-linking-to-a-local-package}

在 Vite 中通过一个哈希值来决定优化后的依赖项是否有效，这个值取决于包锁定的内容、应用于依赖项的补丁以及 Vite 配置文件中影响 node\_modules 打包的选项。这意味着，当使用像 [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides) 这样的功能覆盖依赖项时，Vite 将检测到，并在下一次服务器启动时重新打包您的依赖项。当您使用像 [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link) 这样的功能时，Vite 不会使依赖项无效。如果您链接或取消链接一个依赖项，那么您需要使用 `vite --force` 在下一次服务器启动时强制重新预构建。我们建议使用 overrides，它们现在被每个包管理器所支持（还可以参见 [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides) 和 [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)）。

## 性能瓶颈 {#performance-bottlenecks}

如果你遇到应用程序性能瓶颈导致加载缓慢，可以在启动 Vite 开发服务器或在构建应用程序时使用内置的 Node.js 调试器来创建 CPU 性能分析文件：

::: code-group

```bash [dev server]
vite --profile --open
```

```bash [build]
vite build --profile
```

:::

::: tip Vite 开发服务器
一旦应用程序在浏览器中打开，请等待其完成加载，然后返回终端并按下 `p` 键（将停止 Node.js 调试器），然后按下 `q` 键停止开发服务器。
:::

Node.js 调试器将在根文件夹中生成 `vite-profile-0.cpuprofile` 文件，前往 https://www.speedscope.app/ ，点击 `BROWSE` 按钮上传 CPU 性能分析文件以检查结果。

可以安装 [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) 插件，它可以让你检查 Vite 插件转换时的中间态，并帮助你确定哪些插件或中间件是你应用的瓶颈。该插件可以在开发和构建模式下使用。请查看其 readme 以获取更多详细信息。

## 其他 {#others}

### 为了浏览器兼容性而模块外部化 {#module-externalized-for-browser-compatibility}

当你在浏览器中使用一个 Node.js 模块时，Vite 会输出以下警告：

> Module "fs" has been externalized for browser compatibility. Cannot access "fs.readFile" in client code.

这是因为 Vite 不会自动 polyfill Node.js 的内建模块。

我们推荐你不要在浏览器中使用 Node.js 模块以减小包体积，尽管你可以为其手动添加 polyfill。如果该模块是被某个第三方库（这里意为某个在浏览器中使用的库）导入的，则建议向对应库提交一个 issue。

### 出现 Syntax Error 或 Type Error {#syntax-error-type-error-happens}

Vite 无法处理、也不支持仅可在非严格模式（sloppy mode）下运行的代码。这是因为 Vite 使用了 ESM 并且始终在 ESM 中使用 [严格模式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。

例如，你可能会看到以下错误。

> \[ERROR] With statements cannot be used with the "esm" output format due to strict mode

> TypeError: Cannot create property 'foo' on boolean 'false'

如果这些代码是在依赖中被使用的，你应该使用 [`patch-package`](https://github.com/ds300/patch-package)（或者 [`yarn patch`](https://yarnpkg.com/cli/patch)、[`pnpm patch`](https://pnpm.io/cli/patch) 工具）来做短期补丁处理。

### 浏览器扩展程序 {#browser-extensions}

一些浏览器扩展程序（例如 ad-blockers 广告拦截器），可能会阻止 Vite 客户端向 Vite 开发服务器发送请求。在这种情况下，你可能会看到一个空白屏且没有错误日志。如果遇到这类问题，请尝试禁用扩展程序。

### Windows 上的跨驱动器链接 {#cross-drive-links-on-windows}

如果你的项目中存在跨驱动器链接，Vite 可能无法工作。

跨驱动器链接的一个例子是：

* 通过 `subst` 命令将虚拟驱动器链接到一个文件夹
* 通过 `mklink` 命令将符号链接/联接到另一个驱动器（例如 Yarn 全局缓存）

相关 issue：[#10802](https://github.com/vitejs/vite/issues/10802)

---

---
url: /config.md
---

# 配置 Vite {#configuring-vite}

当以命令行方式运行 `vite` 时，Vite 会自动解析 [项目根目录](/guide/#index-html-and-project-root) 下名为 `vite.config.js` 的配置文件（也支持其他 JS 和 TS 扩展名）。

最基础的配置文件是这样的：

```js [vite.config.js]
export default {
  // 配置选项
}
```

注意：即使项目没有在 `package.json` 中开启 `type: "module"`，Vite 也支持在配置文件中使用 ESM 语法。这种情况下，配置文件会在被加载前自动进行预处理。

你可以显式地通过 `--config` 命令行选项指定一个配置文件（相对于 `cwd` 路径进行解析）

```bash
vite --config my-config.js
```

::: tip 加载配置文件
默认情况下，Vite 使用 `esbuild` 将配置文件打包到临时文件中并加载它。这可能会在 monorepo 中导入 TypeScript 文件时引发问题。如果你遇到了这种方法问题，可以通过指定 `--configLoader runner` 以改用 [module runner](/guide/api-environment-runtimes.html#modulerunner)，它不会创建临时配置并将动态转换任何文件。请注意，module runner 不支持配置文件中的 CJS，但外部 CJS 包应该可以正常工作。

另外，如果你正在使用支持TypeScript的环境（例如 `node --experimental-strip-types`），或者只编写纯 JavaScript 代码，你可以指定 `--configLoader native` 以使用环境的本机运行时加载配置文件。请注意，配置文件导入的模块的更新不会被检测到，因此不会自动重启 Vite 服务器。
:::

## 配置智能提示 {#config-intellisense}

因为 Vite 本身附带 TypeScript 类型，所以你可以通过 IDE 和 jsdoc 的配合来实现智能提示：

```js
/** @type {import('vite').UserConfig} */
export default {
  // ...
}
```

另外你可以使用 `defineConfig` 工具函数，这样不用 jsdoc 注解也可以获取类型提示：

```js
import { defineConfig } from 'vite'

export default defineConfig({
  // ...
})
```

Vite 也直接支持 TypeScript 配置文件。你可以在 `vite.config.ts` 中使用上述的 `defineConfig` 工具函数，或者 `satisfies` 运算符：

```ts
import type { UserConfig } from 'vite'

export default {
  // ...
} satisfies UserConfig
```

## 情景配置 {#conditional-config}

如果配置文件需要基于（`serve` 或 `build`）命令或者不同的 [模式](/guide/env-and-mode#modes) 来决定选项，亦或者是一个 SSR 构建（`isSsrBuild`）、一个正在预览的构建产物（`isPreview`），则可以选择导出这样一个函数：

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {
  if (command === 'serve') {
    return {
      // dev 独有配置
    }
  } else {
    // command === 'build'
    return {
      // build 独有配置
    }
  }
})
```

需要注意的是，在 Vite 的 API 中，在开发环境下 `command` 的值为 `serve`（在 CLI 中， `vite dev` 和 `vite serve` 是 [`vite`](/guide/cli#vite) 的别名），而在生产环境下为 `build`（[`vite build`](/guide/cli#vite-build)）。

`isSsrBuild` 和 `isPreview` 是额外的可选标志，用于区分 `build` 和 `serve` 命令的类型。一些加载 Vite 配置的工具可能不支持这些标志，而会传递 `undefined`。因此，建议使用 `true` 和 `false` 的显式比较。

## 异步配置 {#async-config}

如果配置需要调用一个异步函数，也可以转而导出一个异步函数。这个异步函数也可以通过 `defineConfig` 传递，以便获得更好的智能提示：

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig(async ({ command, mode }) => {
  const data = await asyncFunction()
  return {
    // vite 配置
  }
})
```

## 在配置中使用环境变量 {#using-environment-variables-in-config}

环境变量通常可以从 `process.env` 获得。

注意 Vite 默认是不加载 `.env` 文件的，因为这些文件需要在执行完 Vite 配置后才能确定加载哪一个，举个例子，`root` 和 `envDir` 选项会影响加载行为。不过当你的确需要时，你可以使用 Vite 导出的 `loadEnv` 函数来加载指定的 `.env` 文件。

```js twoslash
import { defineConfig, loadEnv } from 'vite'

export default defineConfig(({ mode }) => {
  // 根据当前工作目录中的 `mode` 加载 .env 文件
  // 设置第三个参数为 '' 来加载所有环境变量，而不管是否有
  // `VITE_` 前缀。
  const env = loadEnv(mode, process.cwd(), '')
  return {
    // vite 配置
    define: {
      __APP_ENV__: JSON.stringify(env.APP_ENV),
    },
  }
})
```

## 在 VS Code 上调试配置文件 {#debugging-the-config-file-on-vs-code}

在默认的 `--configLoader bundle` 行为下，Vite 会将生成的临时配置文件写入 `node_modules/.vite-temp` 文件夹，在 Vite 配置文件中设置断点调试时会出现文件未找到的错误。要修复该问题，请在 `.vscode/settings.json` 中添加以下配置：

```json
{
  "debug.javascript.terminalOptions": {
    "resolveSourceMapLocations": [
      "${workspaceFolder}/**",
      "!**/node_modules/**",
      "**/node_modules/.vite-temp/**"
    ]
  }
}
```

---

---
url: /changes.md
---
# 破坏性变更 {#breaking-changes}

Vite 中的破坏性变更列表，包括 API 废弃、移除和变更。在你的 Vite 配置中，大多数下面的变更可以使用 [`future` 选项](/config/shared-options.html#future) 进行选择。

## 计划中 {#planned}

这些变更计划在 Vite 的下一个主要版本中进行。我们会通过废弃或使用警告来尽可能地引导你，同时我们也正在联系框架、插件的作者以及用户来实施这些变更。

* *目前还没有计划中的变更*

## 考虑中 {#considering}

这些变更正在考虑中，通常是希望改进当前使用模式的实验性 API。由于这里并未列出所有的变更，所以请访问 [Vite GitHub Discussions 中的 Experimental 标签](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=label%3Aexperimental+category%3AFeedback) 来查看完整的列表。

我们目前还不建议你切换到这些 API。我们将它们包含在 Vite 中是为了帮助我们收集反馈。请查看这些提案，并在每个提案相关联的 GitHub Discussions 中告诉我们它们在你的使用场景中的表现如何。

* [钩子函数中的 `this.environment`](/changes/this-environment-in-hooks)
* [HMR `hotUpdate` 插件钩子](/changes/hotupdate-hook)
* [迁移到基于环境的API](/changes/per-environment-apis)
* [使用 `ModuleRunner` API 进行服务端渲染](/changes/ssr-using-modulerunner)
* [构建过程中的共享插件](/changes/shared-plugins-during-build)

## 历史 {#past}

以下的变更已经被实施或者撤销。在当前的主要版本中，它们已经不再相关。

* *目前还没有历史的变更*

---

---
url: /changes/per-environment-apis.md
---
# 迁移到基于环境的API {#move-to-per-environment-apis}

::: tip 反馈
可以在 [环境 API 讨论](https://github.com/vitejs/vite/discussions/16358) 中向我们提供反馈
:::

`ViteDevServer` 中与 module graph 和 modules transforms 相关的多个 API 已移至 `DevEnvironment` 实例。

影响范围：`Vite 插件作者`

::: warning 即将废弃
`环境`实例首次在 `v6.0` 中引入。计划在 `v7.0` 中废弃现在的 `server.moduleGraph` 和其他方法。我们不建议你现在就放弃 server 方法。要识别你的使用情况，请在你的 vite 配置中设置以下。

```ts
future: {
  removeServerModuleGraph: 'warn',
  removeServerTransformRequest: 'warn',
}
```

:::

## 动机 {#motivation}

在 Vite v5 及之前的版本中，一个 Vite 开发服务器总是有两个环境（`client` 和 `ssr`）。`server.moduleGraph` 混合了来自这两个环境的模块。节点通过 `clientImportedModules` 和 `ssrImportedModules` 列表连接（但每种环境只维护一个 `importers` 列表）。转换后的模块由一个 `id` 和一个 `ssr` 布尔值表示。该布尔值需要传递给 API，例如 `server.moduleGraph.getModuleByUrl(url, ssr)` 和 `server.transformRequest(url, { ssr })`。

在 Vite v6 中，现在可以创建任意数量的自定义环境（`client`, `ssr`, `edge`等）。单一的 `ssr` 布尔值已经不够用了。我们没有将 API 改为 `server.transformRequest(url, { environment })`，而是将这些方法移到了环境实例中，这样就可以在没有 Vite dev 服务器的情况下调用这些方法。

## 迁移指南 {#migration-guide}

* `server.moduleGraph` -> [`environment.moduleGraph`](/guide/api-environment#separate-module-graphs)
* `server.transformRequest(url, ssr)` -> `environment.transformRequest(url)`
* `server.warmupRequest(url, ssr)` -> `environment.warmupRequest(url)`

---

---
url: /guide/api-environment-instances.md
---
# 使用 `Environment` 实例 {#using-environment-instances}

:::warning 实验性
环境 API 是实验性的。在 Vite 6 期间，我们将保持这些 API 的稳定，以便生态系统可以在其基础上进行实验和构建。我们计划在 Vite 7 中稳定这些新 API，并可能进行一些重大更改。

资料：

* [反馈讨论](https://github.com/vitejs/vite/discussions/16358) 我们在此处收集新 API 的反馈。
* [环境 API PR](https://github.com/vitejs/vite/pull/16471) 新 API 在此处被实现并进行了审查。

请与我们分享您的反馈。
:::

## 访问环境 {#accessing-the-environments}

在开发阶段，可以使用 `server.environments` 来访问开发服务器中的可用环境：

```js
// 创建服务器，或通过 configureServer 钩子来获取
const server = await createServer(/* 选项 */)

const environment = server.environments.client
environment.transformRequest(url)
console.log(server.environments.ssr.moduleGraph)
```

你也可以从插件中访问当前环境。更多详情请参见 [针对插件的环境 API](./api-environment-plugins.md#accessing-the-current-environment-in-hooks)。

## `DevEnvironment` 类 {#devenvironment-class}

在开发阶段，每个环境都是 `DevEnvironment` 类的一个实例：

```ts
class DevEnvironment {
  /**
   * 环境在 Vite 服务器中的唯一标识符。
   * 默认情况下，Vite 暴露 'client' 和 'ssr' 环境。
   */
  name: string
  /**
   * 用于在目标运行时的关联模块运行器中
   * 发送和接收消息的通信通道。
   */
  hot: NormalizedHotChannel
  /**
   * 模块节点的图，包含处理过的模块之间的
   * 导入关系和处理代码的缓存结果。
   */
  moduleGraph: EnvironmentModuleGraph
  /**
   * 为此环境解析的插件，包括使用按环境的
   * `create` 钩子创建的插件。
   */
  plugins: Plugin[]
  /**
   * 允许通过环境插件管道解析、加载
   * 和转换代码。
   */
  pluginContainer: EnvironmentPluginContainer
  /**
   * 为此环境解析的配置选项。服务器全局范围内的选项
   * 作为所有环境的默认值，并可以被覆盖（解析条件、
   * 外部依赖、优化的依赖）。
   */
  config: ResolvedConfig & ResolvedDevEnvironmentOptions

  constructor(
    name: string,
    config: ResolvedConfig,
    context: DevEnvironmentContext,
  )

  /**
   * 解析 URL 到一个 id，加载它，并使用插件管道
   * 处理代码。模块图也会被更新。
   */
  async transformRequest(url: string): Promise<TransformResult | null>

  /**
   * 注册一个低优先级处理的请求。这对于避免瀑布效应
   * 非常有用。Vite 服务器有关于其他请求导入模块的
   * 信息，因此它可以预热模块图，使得当模块被请求时
   * 已经处理完毕。
   */
  async warmupRequest(url: string): Promise<void>
}
```

其中 `DevEnvironmentContext`是：

```ts
interface DevEnvironmentContext {
  hot: boolean
  transport?: HotChannel | WebSocketServer
  options?: EnvironmentOptions
  remoteRunner?: {
    inlineSourceMap?: boolean
  }
  depsOptimizer?: DepsOptimizer
}
```

`TransformResult` 是：

```ts
interface TransformResult {
  code: string
  map: SourceMap | { mappings: '' } | null
  etag?: string
  deps?: string[]
  dynamicDeps?: string[]
}
```

Vite 服务器中的环境实例允许你使用 `environment.transformRequest(url)` 方法处理一个 URL。这个函数将使用插件管道将 `url` 解析为模块 `id`，加载它（从文件系统读取文件或通过实现虚拟模块的插件），然后转换代码。在转换模块时，将通过创建或更新相应的模块节点，在环境模块图中记录导入和其他元数据。处理完成后，转换结果也存储在模块中。

:::info transformRequest 命名
在这个提议的当前版本中，我们使用 `transformRequest(url)` 和 `warmupRequest(url)`，这样对于习惯于 Vite 当前 API 的用户来说，会更容易讨论和理解。在发布之前，我们也可以借此机会审查这些命名。例如，可以命名为 `environment.processModule(url)` 或 `environment.loadModule(url)`，借鉴于 Rollup 的插件钩子中的 `context.load(id)`。目前，我们认为保留当前的名称并推迟这个讨论是更好的选择。
:::

## 独立的模块图 {#separate-module-graphs}

每个环境都有一个独立的模块图。所有模块图都有相同的签名，因此可以实现通用算法来爬取或查询图，而无需依赖环境。`hotUpdate` 是一个很好的例子。当一个文件被修改时，将使用每个环境的模块图来发现受影响的模块，并为每个环境独立执行 HMR。

::: info
Vite v5 有一个混合的客户端和 SSR 模块图。给定一个未处理的或无效的节点，无法知道它对应的是客户端、SSR 还是两者都有的环境。模块节点有一些带有前缀的属性，如 `clientImportedModules` 和 `ssrImportedModules`（以及 `importedModules`，返回两者的并集）。`importers` 包含了每个模块节点的客户端和 SSR 环境的所有导入者。模块节点还有 `transformResult` 和 `ssrTransformResult`。存在一个向后兼容层允许生态系统从已弃用的 `server.moduleGraph` 迁移过来。
:::

每个模块都由一个 `EnvironmentModuleNode` 实例表示。模块可能在图中被注册，但尚未被处理（在这种情况下，`transformResult` 将为 `null`）。在模块处理后，`importers` 和 `importedModules` 也会被更新。

```ts
class EnvironmentModuleNode {
  environment: string

  url: string
  id: string | null = null
  file: string | null = null

  type: 'js' | 'css'

  importers = new Set<EnvironmentModuleNode>()
  importedModules = new Set<EnvironmentModuleNode>()
  importedBindings: Map<string, Set<string>> | null = null

  info?: ModuleInfo
  meta?: Record<string, any>
  transformResult: TransformResult | null = null

  acceptedHmrDeps = new Set<EnvironmentModuleNode>()
  acceptedHmrExports: Set<string> | null = null
  isSelfAccepting?: boolean
  lastHMRTimestamp = 0
  lastInvalidationTimestamp = 0
}
```

`environment.moduleGraph` 是 `EnvironmentModuleGraph` 的一个实例：

```ts
export class EnvironmentModuleGraph {
  environment: string

  urlToModuleMap = new Map<string, EnvironmentModuleNode>()
  idToModuleMap = new Map<string, EnvironmentModuleNode>()
  etagToModuleMap = new Map<string, EnvironmentModuleNode>()
  fileToModulesMap = new Map<string, Set<EnvironmentModuleNode>>()

  constructor(
    environment: string,
    resolveId: (url: string) => Promise<PartialResolvedId | null>,
  )

  async getModuleByUrl(
    rawUrl: string,
  ): Promise<EnvironmentModuleNode | undefined>

  getModuleById(id: string): EnvironmentModuleNode | undefined

  getModulesByFile(file: string): Set<EnvironmentModuleNode> | undefined

  onFileChange(file: string): void

  onFileDelete(file: string): void

  invalidateModule(
    mod: EnvironmentModuleNode,
    seen: Set<EnvironmentModuleNode> = new Set(),
    timestamp: number = Date.now(),
    isHmr: boolean = false,
  ): void

  invalidateAll(): void

  async ensureEntryFromUrl(
    rawUrl: string,
    setIsSelfAccepting = true,
  ): Promise<EnvironmentModuleNode>

  createFileOnlyEntry(file: string): EnvironmentModuleNode

  async resolveUrl(url: string): Promise<ResolvedUrl>

  updateModuleTransformResult(
    mod: EnvironmentModuleNode,
    result: TransformResult | null,
  ): void

  getModuleByEtag(etag: string): EnvironmentModuleNode | undefined
}
```

---

---
url: /changes/ssr-using-modulerunner.md
---
# 使用 ModuleRunner API 进行服务端渲染 {#ssr-using-modulerunner-api}

::: tip 反馈
可以在 [环境 API 讨论](https://github.com/vitejs/vite/discussions/16358) 中向我们提供反馈
:::

`server.ssrLoadModule` 已被从 [Module Runner](/guide/api-environment#modulerunner) 导入所取代。

影响范围：`Vite 插件作者`

::: warning 即将废弃
`ModuleRunner` 最初在 `v6.0` 版本中被引入。我们计划在未来的主要版本中废弃 `server.ssrLoadModule`。如果想识别你的使用情况，可以在你的 vite 配置文件中将 `future.removeSsrLoadModule` 设置为 `"warn"`。
:::

## 动机 {#motivation}

`server.ssrLoadModule(url)` 仅允许在 `ssr` 环境中导入模块，并且只能在与 Vite 开发服务器相同的进程中执行这些模块。对于具有自定义环境的应用程序，每个环境都关联一个 `ModuleRunner`，该模块可能在单独的线程或进程中运行。为了导入模块，我们现在使用 `moduleRunner.import(url)`。

## 迁移指南 {#migration-guide}

请查看 [用于框架的环境 API 指南](../guide/api-environment-frameworks.md)。

---

---
url: /guide/using-plugins.md
---
# 使用插件 {#using-plugins}

Vite 可以使用插件进行扩展，这得益于 Rollup 优秀的插件接口设计和一部分 Vite 独有的额外选项。这意味着 Vite 用户可以利用 Rollup 插件的强大生态系统，同时根据需要也能够扩展开发服务器和 SSR 功能。

## 添加一个插件 {#adding-a-plugin}

若要使用一个插件，需要将它添加到项目的 `devDependencies` 并在 `vite.config.js` 配置文件中的 `plugins` 数组中引入它。例如，要想为传统浏览器提供支持，可以按下面这样使用官方插件 [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy)：

```
$ npm add -D @vitejs/plugin-legacy
```

```js twoslash [vite.config.js]
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11'],
    }),
  ],
})
```

`plugins` 也可以接受包含多个插件作为单个元素的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化。

Falsy 虚值的插件将被忽略，可以用来轻松地启用或停用插件。

## 查找插件 {#finding-plugins}

:::tip 注意
Vite 旨在为常见的 Web 开发范式提供开箱即用的支持。在寻找一个 Vite 或兼容的 Rollup 插件之前，请先查看 [功能指引](../guide/features.md)。大量在 Rollup 项目中需要使用插件的用例在 Vite 中已经覆盖到了。
:::

查看 [Plugins 章节](../plugins/) 获取官方插件信息。社区插件列表请参见 [awesome-vite](https://github.com/vitejs/awesome-vite#plugins)。

你也可以使用此 [npm Vite 插件搜索链接](https://www.npmjs.com/search?q=vite-plugin\&ranking=popularity) 来找到一些遵循了 [推荐约定](./api-plugin.md#conventions) 的 Vite 插件，或者通过 [npm Rollup 插件搜索链接](https://www.npmjs.com/search?q=rollup-plugin\&ranking=popularity) 获取 Rollup 插件。

## 强制插件排序 {#enforcing-plugin-ordering}

为了与某些 Rollup 插件兼容，可能需要强制修改插件的执行顺序，或者只在构建时使用。这应该是 Vite 插件的实现细节。可以使用 `enforce` 修饰符来强制插件的位置:

* `pre`：在 Vite 核心插件之前调用该插件
* 默认：在 Vite 核心插件之后调用该插件
* `post`：在 Vite 构建插件之后调用该插件

```js twoslash [vite.config.js]
import image from '@rollup/plugin-image'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...image(),
      enforce: 'pre',
    },
  ],
})
```

查看 [插件 API](./api-plugin.md#plugin-ordering) 获取细节信息

## 按需应用 {#conditional-application}

默认情况下插件在开发 (serve) 和生产 (build) 模式中都会调用。如果插件在服务或构建期间按需使用，请使用 `apply` 属性指明它们仅在 `'build'` 或 `'serve'` 模式时调用：

```js twoslash [vite.config.js]
import typescript2 from 'rollup-plugin-typescript2'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...typescript2(),
      apply: 'build',
    },
  ],
})
```

## 创建插件 {#building-plugins}

阅读 [插件 API 指引](./api-plugin.md) 文档了解如何创建插件。

---

---
url: /guide/why.md
---
# 为什么选 Vite {#why-vite}

## 现实问题 {#the-problems}

在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。

时过境迁，我们见证了诸如 [webpack](https://webpack.js.org/)、[Rollup](https://cn.rollupjs.org) 和 [Parcel](https://parceljs.org/) 等工具的变迁，它们极大地改善了前端开发者的开发体验。

然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。

Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。

### 缓慢的服务器启动 {#slow-server-start}

当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。

Vite 通过在一开始将应用中的模块区分为 **依赖** 和 **源码** 两类，改进了开发服务器启动时间。

* **依赖** 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。

  Vite 将会使用 [esbuild](https://esbuild.github.io/) [预构建依赖](./dep-pre-bundling.md)。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

* **源码** 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。

  Vite 以 [原生 ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。

### 缓慢的更新 {#slow-updates}

基于打包启动时，当源文件被修改后，重新构建整个包是低效的，原因显而易见：更新速度会随着应用体积的增加而线性下降。

一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[\[1\]](#footnote-1)，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热替换（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。

在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活[\[1\]](#footnote-1)（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。

Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 `304 Not Modified` 进行协商缓存，而依赖模块请求则会通过 `Cache-Control: max-age=31536000,immutable` 进行强缓存，因此一旦被缓存它们将不需要再次请求。

一旦你体验到 Vite 的神速，你可能再也不想回到曾经的打包开发方式了。

## 为什么生产环境仍需打包 {#why-bundle-for-production}

尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。

要确保开发服务器和生产环境构建之间的最优输出和行为一致并不容易。所以 Vite 附带了一套 [构建优化](./features.md#build-optimizations) 的 [构建命令](./build.md)，开箱即用。

### 为何不用 ESBuild 打包？ {#why-not-bundle-with-esbuild}

虽然 Vite 利用 esbuild [在开发中预打包一些依赖](./dep-pre-bundling.md)，但 Vite 不会在生产构建中使用 esbuild 作为打包工具。

Vite 目前的插件 API 与使用 `esbuild` 作为打包器并不兼容。尽管 `esbuild` 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。

Rollup 已经开始着手改进性能，[在 v4 中将其解析器切换到 SWC](https://github.com/rollup/rollup/pull/5073)。同时还有一个正在进行中的工作，即构建一个名为 Rolldown 的 Rust 版本的 Rollup。一旦 Rolldown 准备就绪，它就可以在 Vite 中取代 Rollup 和 esbuild，显著提高构建性能，并消除开发和构建之间的不一致性。你可以观看 [Evan You 在 ViteConf 2023 的主题演讲](https://youtu.be/hrdwQHoAp0M) 了解更多细节。

## Vite 与其他免打包构建工具的关系是什么？{##how-vite-relates-to-other-unbundled-build-tools}

Preact 团队的 [WMR](https://github.com/preactjs/wmr) 旨在提供类似的功能集。Vite 用于开发和构建的通用 Rollup 插件 API 就是受其启发。WMR 已经不再维护。Preact 团队现在推荐使用 Vite 和 [@preactjs/preset-vite](https://github.com/preactjs/preset-vite)。

[Snowpack](https://www.snowpack.dev/) 也是一个免打包的原生 ESM 开发服务器，与 Vite 的职责非常相似。Vite 的依赖预打包也受到了 Snowpack v1（现在是 [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)）的启发。Snowpack 已经不再维护。Snowpack 团队现在正在研究由 Vite 驱动的静态网站构建器 [Astro](https://astro.build/)。

[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/)（以前是 `es-dev-server`）是一个伟大的项目，Vite 1.0 的基于 Koa 的服务器设置就是受其启发。`@web` 这个项目正在积极维护，并包含许多其他优秀的工具，这些工具也可能对 Vite 用户有所帮助。

---

---
url: /guide/philosophy.md
---
# 项目理念 {#project-philosophy}

## 精简且可扩展的核心 {#lean-extendable-core}

Vite 的目标不在于满足所有用户的每一个使用场景。Vite 旨在开箱即用地支持构建 Web 应用的最常见的模式，但 [Vite 核心包](https://github.com/vitejs/vite) 必须保持精简并拥有较小的 API 接口，以保证项目长期维护的可行性。这一目标之所以可能实现，得益于 [Vite 基于 Rollup 的插件系统](./api-plugin.md) 。可以作为外部插件实现的功能通常不会添加到 Vite 核心中。 [vite-plugin-pwa](https://vite-pwa-org.netlify.app/) 是一个很好的示例，展示了 Vite 核心之外能实现的强大功能，并且有许多 [维护良好的插件](https://github.com/vitejs/awesome-vite#plugins) 来满足您的需求。Vite 与 Rollup 项目紧密合作，确保插件在尽可能多的情况下既可用于纯 Rollup 项目，也可用于 Vite 项目，并努力将必要的扩展推送到上游 Plugin API 中。

## 推动现代 Web 开发 {#pushing-the-modern-web}

Vite 提供了一系列推动编写现代代码的特定功能。例如：

* 源代码必须采用 ESM 形式编写；对于非 ESM 的依赖项，为了使其正常工作，需要 [预先将其打包为 ESM](./dep-pre-bundling)。
* 建议使用 [`new Worker` 语法](./features#web-workers) 来编写 Web Workers，以遵循现代标准。
* 在浏览器环境下，不能直接使用 Node.js 模块。

在新增特性时，会遵循这些模式来构建一个具备前瞻性的 API，但请注意，这样的API可能并不总是与其它构建工具兼容。

## 旨在高性能的实用解决方案 {#a-pragmatic-approach-to-performance}

Vite 自其诞生之初（详见：[为什么选 Vite](./why.md)）就一直致力于性能优化。其开发服务器架构设计确保了随着项目规模扩大，模块热替换（HMR）仍能保持高速运行。Vite 采用类似 [esbuild](https://esbuild.github.io/) 和 [SWC](https://github.com/vitejs/vite-plugin-react-swc) 这样的原生工具处理复杂的任务，同时将其他部分代码保留在 JavaScript 中，以实现速度与灵活性之间的平衡。在需要时，框架插件会利用 [Babel](https://babeljs.io/) 来编译用户代码。构建阶段，Vite 当前使用的是 [Rollup](https://cn.rollupjs.org/) ，此时包体积大小以及能够接入广泛生态系统的插件比原始速度更重要。Vite 将持续内部改进和发展，在新库出现时适时采用以提升开发者体验（DX），同时保持 API 的稳定性。

## 基于 Vite 构建框架 {#building-frameworks-on-top-of-vite}

尽管 Vite 可以直接供用户使用，但它尤其适合作为创建框架的工具。Vite 核心本身不特定于任何框架，但针对每个 UI 框架都提供了完善的插件支持。其 [JS API](./api-javascript.md) 允许应用框架作者利用 Vite 特性为他们的用户提供定制化的体验。Vite 包含了对 [SSR 基础功能](./ssr.md) 的支持，这些功能通常在更高级别的工具中出现，但对于构建现代 Web 框架至关重要。Vite 插件通过提供一种跨框架共享的方式，使整体方案更为完备。此外，当与诸如 [Ruby](https://vite-ruby.netlify.app/) 和 [Laravel](https://laravel.com/docs/10.x/vite) 等 [后端框架](./backend-integration.md) 结合使用时，Vite 也是一个绝佳选择。

## 活跃的生态系统 {#an-active-ecosystem}

Vite 的发展是一个由框架和插件维护者、用户以及 Vite 团队共同协作的过程。我们鼓励当项目采用 Vite 时，也可以积极参与 Vite 核心开发。我们借助如 [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci) 等工具与生态中的主要项目紧密合作，在每次发布时尽量减少回归问题。该工具允许我们在选定的 PR 上运行使用 Vite 的主要项目的 CI，并让我们清晰了解生态系统对新版本发布的反应情况。我们力求在问题影响到用户之前修复回归问题，确保项目能够尽快更新至最新版本。如果您正在使用 Vite，我们诚邀您加入 [Vite Discord 频道](https://chat.vite.dev) ，一同参与项目的发展。

---

---
url: /guide/performance.md
---
# 性能 {#performance}

虽然 Vite 默认运行速度很快，但随着项目需求的增长，性能问题可能会悄然出现。本指南旨在帮助您识别并修复常见的性能问题，例如：

* 服务器启动慢
* 页面加载慢
* 构建慢

## 检查浏览器设置 {#review-your-browser-setup}

有些浏览器插件可能会干涉请求，对于大型应用，特别是在使用浏览器开发工具时，可能会拖慢启动和刷新速度。我们建议在这种情况下，使用 Vite 的开发服务器时，创建一个专门用于开发且不含插件的配置，或者切换到无痕模式。无痕模式的速度也应该比没有插件的常规模式更快。

Vite 开发服务器对预打包的依赖项进行了强缓存，同时对源代码实现快速的 304 响应。如果在浏览器的开发者工具打开的情况下关闭缓存，可能会大幅影响启动速度和全页刷新的时间。因此，在使用 Vite 服务器的时候，请确保没有启用 "禁用缓存" 功能。

## 审核配置的 Vite 插件 {#audit-configured-vite-plugins}

Vite 的内部和官方插件已经优化，以在提供与更广泛的生态系统兼容性的同时做尽可能少的工作。例如，代码转换在开发中使用正则表达式，但在构建中进行完整解析以确保正确性。

然而，社区插件的性能是 Vite 无法控制的，这可能会影响开发者的体验。在使用额外的 Vite 插件时，有一些事情可以注意：

1. 只在特定情况下，大型依赖项应动态导入，以减少Node.js的启动时间。重构示例：[vite-plugin-react#212](https://github.com/vitejs/vite-plugin-react/pull/212) 和 [vite-plugin-pwa#224](https://github.com/vite-pwa/vite-plugin-pwa/pull/244)。

2. `buildStart`，`config`，和 `configResolved` 钩子不应运行过长的时间和进行大量的操作。这些钩子会在开发服务器启动期间等待，这会延迟可以在浏览器中访问站点的时间。

3. `resolveId`，`load`，和 `transform` 钩子可能会导致一些文件加载速度比其他文件慢。虽然有时无法避免，但仍值得检查可能的优化区域。例如，检查 `code` 是否包含特定关键字，或 `id` 是否匹配特定扩展名，然后再进行完整的转换。

   转换文件所需的时间越长，加载站点时在浏览器中的请求瀑布图就会越明显。

   你可以使用 `vite --debug plugin-transform` 或 [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) 检查转换文件所需的时间。请注意，由于异步操作往往提供不准确的时间，应将这些数字视为粗略的估计，但它仍应揭示消耗很大的操作。

::: tip 性能分析
可以运行 `vite --profile`，访问站点，并在终端中按 `p + enter` 来记录一个 `.cpuprofile`。然后可以使用像 [speedscope](https://www.speedscope.app) 这样的工具来检查配置文件并识别瓶颈。也可以 [分享配置文件](https://chat.vite.dev) 给 Vite 团队，帮助我们识别性能问题。
:::

## 减少解析操作 {#reduce-resolve-operations}

当经常遇到最糟糕的情况时，解析导入路径可能是一项昂贵的操作。例如，Vite 支持通过 [`resolve.extensions`](/config/shared-options.md#resolve-extensions) 选项“猜测”导入路径，该选项默认为 `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`。

当您尝试使用 `import './Component'` 导入 `./Component.jsx` 时，Vite 将运行以下步骤来解析它：

1. 检查 `./Component` 是否存在，不存在。
2. 检查 `./Component.mjs` 是否存在，不存在。
3. 检查 `./Component.js` 是否存在，不存在。
4. 检查 `./Component.mts` 是否存在，不存在。
5. 检查 `./Component.ts` 是否存在，不存在。
6. 检查 `./Component.jsx` 是否存在，存在！

如上所示，解析一个导入路径需要进行 6 次文件系统检查。您的隐式导入越多，解析路径所需的时间就越多。

因此，通常最好明确您的导入路径，例如 `import './Component.jsx'`。也可以缩小 `resolve.extensions` 的列表以减少一般的文件系统检查，但必须确保它也适用于 `node_modules` 中的文件。

如果你是插件作者，请确保只在需要时调用 [`this.resolve`](https://cn.rollupjs.org/plugin-development/#this-resolve) 以减少上述检查的次数。

::: tip TypeScript
如果你正在使用 TypeScript，启用 `tsconfig.json` 中的 `compilerOptions` 的 `"moduleResolution": "bundler"` 和 `"allowImportingTsExtensions": true` 以直接在代码中使用 `.ts` 和 `.tsx` 扩展名。
:::

## 避免使用桶文件 {#avoid-barrel-files}

桶文件（barrel files）是重新导出同一目录下其他文件 API 的文件。例如：

```js [src/utils/index.js]
export * from './color.js'
export * from './dom.js'
export * from './slash.js'
```

当你只导入一个单独的 API，例如 `import { slash } from './utils'`，需要获取和转换桶文件中的所有文件，因为它们可能包含 `slash` API，也可能包含在初始化时运行的其他副作用。这意味着在初始页面加载时，你加载的文件比所需的要更多，导致页面加载速度变慢。

如果可能的话，你应该尽量避免使用桶文件（barrel files），直接导入单独的 API，例如 `import { slash } from './utils/slash.js'`。你可以阅读 [issue #8237](https://github.com/vitejs/vite/issues/8237) 了解更多信息。

## 预热常用文件 {#warm-up-frequently-used-files}

Vite 开发服务器只转换浏览器请求的文件，这使得它能够快速启动，并且只对使用的文件执行转换。如果预计某些文件将被短时间内请求，也可以预先转换。然而，如果某些文件的转换时间比其他文件长，仍然可能发生请求瀑布。例如：

给定一个导入图，左边的文件导入右边的文件：

```
main.js -> BigComponent.vue -> big-utils.js -> large-data.json
```

导入关系只有在文件转换后才能知道。如果 `BigComponent.vue` 需要一些时间来转换，`big-utils.js` 就必须等待它的轮次，依此类推。即使内置了预先转换，这也会导致内部瀑布。

Vite 允许预热你确定频繁使用的文件，例如 `big-utils.js`，可以使用 [`server.warmup`](/config/server-options.md#server-warmup) 选项。这样，当请求时，`big-utils.js` 将准备好并被缓存，以便立即提供服务。

你可以通过运行 `vite --debug transform` 并检查日志来找到频繁使用的文件：

```bash
vite:transform 28.72ms /@vite/client +1ms
vite:transform 62.95ms /src/components/BigComponent.vue +1ms
vite:transform 102.54ms /src/utils/big-utils.js +1ms
```

```js [vite.config.js]
export default defineConfig({
  server: {
    warmup: {
      clientFiles: [
        './src/components/BigComponent.vue',
        './src/utils/big-utils.js',
      ],
    },
  },
})
```

请注意，只应该预热频繁使用的文件，以免在启动时过载 Vite 开发服务器。查看 [`server.warmup`](/config/server-options.md#server-warmup) 选项以获取更多信息。

使用 [`--open` 或 `server.open`](/config/server-options.html#server-open) 也可以提供性能提升，因为 Vite 将自动预热你的应用的入口起点或被提供的要打开的 URL。

## 使用更少或更原生化的工具链 {#use-lesser-or-native-tooling}

保持 Vite 如此之快的关键在于减少源文件（JS/TS/CSS）的工作量。

精简工作的例子：

* 使用 CSS 而不是 Sass/Less/Stylus（可以由 PostCSS 处理嵌套）
* 不要使用 `@vitejs/plugin-react-refresh`，而是使用 React Fast Refresh 的原生支持。
* 当使用 `@vitejs/plugin-react` 时，避免配置 Babel 选项，这样它就会在构建期间跳过转换（只使用 esbuild）。

使用更原生化工具链的例子：

使用更原生化的工具链往往会带来更大的安装大小，因此在启动新的 Vite 项目时不是默认的。但对于较大的应用程序来说，这可能是值得的。

* 使用 [Rolldown 而不是 Rollup 和 esbuild](./rolldown) 以获得更快的构建速度和在开发和构建之间更一致的体验。
* 尝试实验性的 [LightningCSS](https://github.com/vitejs/vite/discussions/13835)
* 使用 [`@vitejs/plugin-react-swc`](https://github.com/vitejs/vite-plugin-react-swc) 代替 `@vitejs/plugin-react`。

---

---
url: /config/dep-optimization-options.md
---
# 依赖优化选项 {#dep-optimization-options}

* **相关内容：** [依赖预构建](/guide/dep-pre-bundling)

除非另有说明，本节中的选项仅适用于依赖优化器，该优化器仅在开发环境中使用。

## optimizeDeps.entries

* **类型：** `string | string[]`

默认情况下，Vite 会抓取你的 `index.html` 来检测需要预构建的依赖项（忽略了`node_modules`、`build.outDir`、`__tests__` 和 `coverage`）。如果指定了 `build.rollupOptions.input`，Vite 将转而去抓取这些入口点。

如果这两者都不合你意，则可以使用此选项指定自定义条目——该值需要遵循 [tinyglobby 模式](https://github.com/SuperchupuDev/tinyglobby) ，或者是相对于 Vite 项目根目录的匹配模式数组。当显式声明了 `optimizeDeps.entries` 时默认只有 `node_modules` 和 `build.outDir` 文件夹会被忽略。如果还需忽略其他文件夹，你可以在模式列表中使用以 `!` 为前缀的、用来匹配忽略项的模式。如果你不想忽略 `node_modules` 和 `build.outDir`，你可以选择直接使用字符串路径（不使用 tinyglobby 模式）。

## optimizeDeps.exclude {#optimizedeps-exclude}

* **类型：** `string[]`

在预构建中强制排除的依赖项。

:::warning CommonJS
CommonJS 的依赖不应该排除在优化外。如果一个 ESM 依赖被排除在优化外，但是却有一个嵌套的 CommonJS 依赖，则应该为该 CommonJS 依赖添加 `optimizeDeps.include`。例如：

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig({
  optimizeDeps: {
    include: ['esm-dep > cjs-dep'],
  },
})
```

:::

## optimizeDeps.include {#optimizedeps-include}

* **类型：** `string[]`

默认情况下，不在 `node_modules` 中的，链接的包不会被预构建。使用此选项可强制预构建链接的包。

**实验性：** 如果你使用的是一个有很多深层导入的库，你也可以指定一个尾部的 glob 模式来一次性地预构建所有深层导入。这将避免在使用新的深层导入时不断地预构建。可以在此 [提供反馈](https://github.com/vitejs/vite/discussions/15833)。例如：

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig({
  optimizeDeps: {
    include: ['my-lib/components/**/*.vue'],
  },
})
```

## optimizeDeps.esbuildOptions {#optimizedeps-esbuild-options}

* **类型：** [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)`<`[`EsbuildBuildOptions`](https://esbuild.github.io/api/#general-options)`,
  | 'bundle'
  | 'entryPoints'
  | 'external'
  | 'write'
  | 'watch'
  | 'outdir'
  | 'outfile'
  | 'outbase'
  | 'outExtension'
  | 'metafile'>`

在依赖扫描和优化过程中传递给 esbuild 的选项。

某些选项进行了省略，因为修改它们与 Vite 的优化方案并不兼容。

* 忽略了 `external` 选项，请使用 Vite 的 `optimizeDeps.exclude` 选项
* `plugins` 与 Vite 的 dep 插件合并

## optimizeDeps.force {#optimizedeps-force}

* **类型：** `boolean`

设置为 `true` 可以强制依赖预构建，而忽略之前已经缓存过的、已经优化过的依赖。

## optimizeDeps.holdUntilCrawlEnd

* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/15834)
* **类型：** `boolean`
* **默认：** `true`

当该功能被启用时，系统会在冷启动时保持第一个优化的依赖结果，直到所有的静态导入都被检索完毕。这样可以避免因为发现新的依赖项而触发新的公共 chunk 生成，从而需要刷新整个页面。如果通过扫描和在 `include` 中明确定义的方式能找到所有的依赖项，那么最好关闭这个功能，这样浏览器可以并行处理更多的请求。

## optimizeDeps.disabled {#optimizedeps-disabled}

* **已废弃**
* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/13839)
* **类型：** `boolean | 'build' | 'dev'`
* **默认：** `'build'`

此选项已被弃用。从 Vite 5.1 版本开始，构建过程中对依赖项的预打包已经被移除。将 `optimizeDeps.disabled` 设置为 `true` 或 `'dev'` 将会禁用优化器，配置为 `false` 或 `'build'` 将会在开发模式下启用优化器。

如果你想完全禁用优化器，可以设置 `optimizeDeps.noDiscovery: true` 来禁止自动发现依赖项，并保持 `optimizeDeps.include` 未定义或为空。

:::warning
在构建过程中优化依赖项是一个 **实验性** 的功能。尝试这种策略的项目也会使用 `build.commonjsOptions: { include: [] }` 来移除 `@rollup/plugin-commonjs`。如果你这样做，将会有一个警告提示你在打包时需要重新启用它，以支持仅使用 CJS 的包。
:::

## optimizeDeps.needsInterop

* **实验性**
* **类型:** `string[]`

当导入这些依赖项时，会强制 ESM 转换。Vite 能够正确检测到依赖项是否需要转换处理（interop），因此通常不需要使用此选项。然而，不同的依赖项组合可能导致其中一些包以不同方式预构建。将这些包添加到 `needsInterop` 中可以通过避免重新加载整个页面来加快冷启动速度。如果某个依赖项符合此情况，Vite 将抛出警告，建议你在配置中添加该包名。

---

---
url: /guide/dep-pre-bundling.md
---
# 依赖预构建 {#dependency-pre-bundling}

当你首次启动 `vite` 时，Vite 在本地加载你的站点之前预构建了项目依赖。默认情况下，它是自动且透明地完成的。

## 原因 {#the-why}

这就是 Vite 执行时所做的“依赖预构建”。这个过程有两个目的:

1. **CommonJS 和 UMD 兼容性：** 在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。

   在转换 CommonJS 依赖项时，Vite 会进行智能导入分析，这样即使模块的导出是动态分配的（例如 React），具名导入（named imports）也能正常工作：

   ```js
   // 符合预期
   import React, { useState } from 'react'
   ```

2. **性能：** 为了提高后续页面的加载性能，Vite 将那些具有许多内部模块的 ESM 依赖项转换为单个模块。

   有些包将它们的 ES 模块构建为许多单独的文件，彼此导入。例如，[`lodash-es` 有超过 600 个内置模块](https://unpkg.com/browse/lodash-es/)！当我们执行 `import { debounce } from 'lodash-es'` 时，浏览器同时发出 600 多个 HTTP 请求！即使服务器能够轻松处理它们，但大量请求会导致浏览器端的网络拥塞，使页面加载变得明显缓慢。

   通过将 `lodash-es` 预构建成单个模块，现在我们只需要一个HTTP请求！

::: tip 注意
依赖预构建仅适用于开发模式，并使用 `esbuild` 将依赖项转换为 ES 模块。在生产构建中，将使用 `@rollup/plugin-commonjs`。
:::

## 自动依赖搜寻 {#automatic-dependency-discovery}

如果没有找到现有的缓存，Vite 会扫描您的源代码，并自动寻找引入的依赖项（即 "bare import"，表示期望从 `node_modules` 中解析），并将这些依赖项作为预构建的入口点。预打包使用 `esbuild` 执行，因此通常速度非常快。

在服务器已经启动后，如果遇到尚未在缓存中的新依赖项导入，则 Vite 将重新运行依赖项构建过程，并在需要时重新加载页面。

## Monorepo 和链接依赖 {#monorepos-and-linked-dependencies}

在一个 monorepo 启动中，该仓库中的某个包可能会成为另一个包的依赖。Vite 会自动侦测没有从 `node_modules` 解析的依赖项，并将链接的依赖视为源码。它不会尝试打包被链接的依赖，而是会分析被链接依赖的依赖列表。

然而，这需要被链接的依赖被导出为 ESM 格式。如果不是，那么你可以在配置里将此依赖添加到 [`optimizeDeps.include`](/config/dep-optimization-options.md#optimizedeps-include) 和 [`build.commonjsOptions.include`](/config/build-options.md#build-commonjsoptions) 这两项中。

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig({
  optimizeDeps: {
    include: ['linked-dep'],
  },
  build: {
    commonjsOptions: {
      include: [/linked-dep/, /node_modules/],
    },
  },
})
```

当对链接的依赖进行更改时，请使用 `--force` 命令行选项重新启动开发服务器，以使更改生效。

## 自定义行为 {#customizing-the-behavior}

有时候默认的依赖启发式算法（discovery heuristics）可能并不总是理想的。如果您想要明确地包含或排除依赖项，可以使用 [`optimizeDeps` 配置项](/config/dep-optimization-options.md) 来进行设置。

`optimizeDeps.include` 或 `optimizeDeps.exclude` 的一个典型使用场景，是当 Vite 在源码中无法直接发现 import 的时候。例如，import 可能是插件转换的结果。这意味着 Vite 无法在初始扫描时发现 import —— 只能在文件被浏览器请求并转换后才能发现。这将导致服务器在启动后立即重新打包。

`include` 和 `exclude` 都可以用来处理这个问题。如果依赖项很大（包含很多内部模块）或者是 CommonJS，那么你应该包含它；如果依赖项很小，并且已经是有效的 ESM，则可以排除它，让浏览器直接加载它。

你可以通过 [`optimizeDeps.esbuildOptions` 选项](/config/dep-optimization-options.md#optimizedeps-esbuildoptions) 进一步自定义 esbuild。例如，添加一个 esbuild 插件来处理依赖项中的特殊文件，或者更改 [build `target`](https://esbuild.github.io/api/#target)。

## 缓存 {#caching}

### 文件系统缓存 {#file-system-cache}

Vite 将预构建的依赖项缓存到 `node_modules/.vite` 中。它会基于以下几个来源来决定是否需要重新运行预构建步骤：

* 包管理器的锁文件内容，例如 `package-lock.json`，`yarn.lock`，`pnpm-lock.yaml`，或者 `bun.lockb`；
* 补丁文件夹的修改时间；
* `vite.config.js` 中的相关字段；
* `NODE_ENV` 的值。

只有在上述其中一项发生更改时，才需要重新运行预构建。

如果出于某些原因你想要强制 Vite 重新构建依赖项，你可以在启动开发服务器时指定 `--force` 选项，或手动删除 `node_modules/.vite` 缓存目录。

### 浏览器缓存 {#browser-cache}

已预构建的依赖请求使用 HTTP 头 `max-age=31536000, immutable` 进行强缓存，以提高开发期间页面重新加载的性能。一旦被缓存，这些请求将永远不会再次访问开发服务器。如果安装了不同版本的依赖项（这反映在包管理器的 lockfile 中），则会通过附加版本查询自动失效。如果你想通过本地编辑来调试依赖项，您可以：

1. 通过浏览器开发工具的 Network 选项卡暂时禁用缓存；
2. 重启 Vite 开发服务器指定 `--force` 选项，来重新构建依赖项;
3. 重新载入页面。

---

---
url: /guide/api-environment-plugins.md
---
# 用于插件的环境 API {#environment-api-for-plugins}

:::warning 实验性
环境 API 是实验性的。在 Vite 6 期间，我们将保持这些 API 的稳定，以便生态系统可以在其基础上进行实验和构建。我们计划在 Vite 7 中稳定这些新 API，并可能进行一些重大更改。

资料：

* [反馈讨论](https://github.com/vitejs/vite/discussions/16358) 我们在此处收集新 API 的反馈。
* [环境 API PR](https://github.com/vitejs/vite/pull/16471) 新 API 在此处被实现并进行了审查。

请与我们分享您的反馈。
:::

## 在钩子中访问当前环境 {#accessing-the-current-environment-in-hooks}

在 Vite 6之前，由于只有两个环境（`client` 和 `ssr`），一个 `ssr` 布尔值足以在 Vite API 中识别当前环境。插件钩子在最后的选项参数中接收一个 `ssr` 布尔值，多个 API 也期望通过一个可选的 `ssr` 参数来正确地将模块关联到对应的环境（例如 `server.moduleGraph.getModuleByUrl(url, { ssr })`）。

随着可配置的环境出现，我们现在有了一种统一的方法来在插件中访问它们的选项和实例。插件钩子现在在其上下文中暴露 `this.environment`，以前期望 `ssr` 布尔值的 API 现在被限定到正确的环境（例如 `environment.moduleGraph.getModuleByUrl(url)`）。

Vite 服务器有一个共享的插件管道，但在处理模块时，它总是在给定环境的上下文中进行。`environment` 实例在插件上下文中可用。

插件可以使用 `environment` 实例根据环境的配置（可通过 `environment.config` 访问）来改变模块的处理方式。

```ts
  transform(code, id) {
    console.log(this.environment.config.resolve.conditions)
  }
```

## 使用钩子注册新环境 {#registering-new-environments-using-hooks}

插件可以在 `config` 钩子中添加新环境（例如，为了有一个专门用于 [RSC](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components) 的模块图）：

```ts
  config(config: UserConfig) {
    config.environments.rsc ??= {}
  }
```

一个空对象就足以注册环境，默认值则来自于根级别的环境配置。

## 使用钩子配置环境 {#configuring-environment-using-hooks}

当 `config` 钩子正在运行时，我们还不知道完整的环境列表，而且环境可以受到来自根级别环境配置的默认值或通过 `config.environments` 记录明确影响。
插件应使用 `config` 钩子设置默认值。要配置每个环境，可以使用新的 `configEnvironment` 钩子。此钩子会为每个环境调用，并传入其部分解析的配置，包括最终默认值的解析。

```ts
  configEnvironment(name: string, options: EnvironmentOptions) {
    if (name === 'rsc') {
      options.resolve.conditions = // ...
```

## `hotUpdate` 钩子 {#the-hotupdate-hook}

* **类型：** `(this: { environment: DevEnvironment }, options: HotUpdateOptions) => Array<EnvironmentModuleNode> | void | Promise<Array<EnvironmentModuleNode> | void>`
* **查看：** [HMR API](./api-hmr)

`hotUpdate` 钩子允许插件为特定环境执行自定义的 HMR 更新处理。当一个文件发生变化时，会按照 `server.environments` 中的顺序为每个环境依次运行 HMR 算法，因此 `hotUpdate` 钩子会被多次调用。这个钩子会接收一个带有以下签名的上下文对象：

```ts
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

* `this.environment` 是当前正在处理文件更新的模块执行环境。

* `modules` 是由于文件更改而受影响的此环境中的模块的数组。它是一个数组，因为一个文件可能映射到多个服务的模块（例如 Vue SFCs）。

* `read` 是一个异步读取函数，返回文件的内容。这是因为，在某些系统上，文件更改回调可能在编辑器完成文件更新之前触发得太快，直接的 `fs.readFile` 将返回空内容。传入的读取函数规范化了这种行为。

可以选择钩子用于：

* 过滤和缩小受影响的模块列表，使 HMR 更准确。

* 返回一个空数组并执行完全重载：

  ```js
  hotUpdate({ modules, timestamp }) {
    if (this.environment.name !== 'client')
      return

    // 手动使模块失效
    const invalidatedModules = new Set()
    for (const mod of modules) {
      this.environment.moduleGraph.invalidateModule(
        mod,
        invalidatedModules,
        timestamp,
        true
      )
    }
    this.environment.hot.send({ type: 'full-reload' })
    return []
  }
  ```

* 返回一个空数组并通过向客户端发送自定义事件来执行完全自定义的 HMR 处理：

  ```js
  hotUpdate() {
    if (this.environment.name !== 'client')
      return

    this.environment.hot.send({
      type: 'custom',
      event: 'special-update',
      data: {}
    })
    return []
  }
  ```

  客户端代码应使用 [HMR API](./api-hmr) 注册相应的处理程序（这可以通过相同插件的 `transform` 钩子注入）：

  ```js
  if (import.meta.hot) {
    import.meta.hot.on('special-update', (data) => {
      // 执行自定义更新
    })
  }
  ```

## 基于环境的插件 {#per-environment-plugins}

插件可以使用 `applyToEnvironment` 函数来定义它适用的环境。

```js
const UnoCssPlugin = () => {
  // 共享的全局状态
  return {
    buildStart() {
      // 使用 Wea​​kMap<Environment,Data> 初始化每个环境状态
      // 使用 this.environment
    },
    configureServer() {
      // 正常使用全局钩子
    },
    applyToEnvironment(environment) {
      // 如果此插件应在此环境中激活，则返回 true
      // 或返回一个新插件来替代它。
      // 如果不使用这个 hook，则插件在所有环境中都是激活的
    },
    resolveId(id, importer) {
      // 只对此插件适用的环境进行调用
    },
  }
}
```

如果一个插件没有环境感知功能，并且其状态没有基于当前环境进行区分，`applyToEnvironment` 钩子可以轻松地将其设置为针对每个环境工作。

```js
import { nonShareablePlugin } from 'non-shareable-plugin'

export default defineConfig({
  plugins: [
    {
      name: 'per-environment-plugin',
      applyToEnvironment(environment) {
        return nonShareablePlugin({ outputName: environment.name })
      },
    },
  ],
})
```

Vite 输出了一个 `perEnvironmentPlugin` 助手，以简化这些不需要其他钩子的情况：

```js
import { nonShareablePlugin } from 'non-shareable-plugin'

export default defineConfig({
  plugins: [
    perEnvironmentPlugin('per-environment-plugin', (environment) =>
      nonShareablePlugin({ outputName: environment.name }),
    ),
  ],
})
```

## 构建钩子中的环境 {#environment-in-build-hooks}

与开发期间一样，插件钩子在构建期间也接收环境实例，取代了 `ssr` 布尔值。
这同样适用于 `renderChunk`、`generateBundle` 和其他仅在构建时使用的钩子。

## 构建期间的共享插件 {#shared-plugins-during-build}

在 Vite 6 之前，插件管道在开发和构建期间的工作方式不同：

* **开发期间：** 插件是共享的
* **构建期间：** 插件对每个环境是隔离的（在不同的进程中：`vite build` 然后 `vite build --ssr`）。

这迫使框架通过写入文件系统的清单文件在 `client` 构建和 `ssr` 构建之间共享状态。在 Vite 6 中，我们现在在单个进程中构建所有环境，因此插件管道和环境间通信的方式可以与开发对齐。

在未来的主要版本（Vite 7 或 8）中，我们的目标是完全对齐：

* **在开发和构建期间：** 插件是共享的，并可以 [根据环境进行过滤](#per-environment-plugins)

在构建期间还会共享一个单一的 `ResolvedConfig` 实例，允许在整个应用构建过程中进行缓存，类似于我们在开发期间使用 `WeakMap<ResolvedConfig, CachedData>` 的方式。

对于 Vite 6，我们需要做一个较小的改动以保持向后兼容。生态系统插件当前使用 `config.build` 而不是 `environment.config.build` 来访问配置，因此我们需要默认为每个环境创建一个新的 `ResolvedConfig`。项目可以通过设置 `builder.sharedConfigBuild` 为 `true` 来选择共享完整的配置和插件管道。

此选项最初仅适用于一小部分项目，因此插件作者可以通过将 `sharedDuringBuild` 标志设置为 `true` 来选择特定插件在构建期间共享。这可以很容易地共享常规插件的状态：

```js
function myPlugin() {
  // 在开发和构建中的所有环境之间共享状态
  const sharedState = ...
  return {
    name: 'shared-plugin',
    transform(code, id) { ... },

    // 选择在所有环境中使用单个实例
    sharedDuringBuild: true,
  }
}
```

---

---
url: /guide/api-environment-frameworks.md
---
# 用于框架的环境 API {#environment-api-for-frameworks}

:::warning 实验性
环境 API 是实验性的。在 Vite 6 期间，我们将保持这些 API 的稳定，以便生态系统可以在其基础上进行实验和构建。我们计划在 Vite 7 中稳定这些新 API，并可能进行一些重大更改。

资料：

* [反馈讨论](https://github.com/vitejs/vite/discussions/16358) 我们在此处收集新 API 的反馈。
* [环境 API PR](https://github.com/vitejs/vite/pull/16471) 新 API 在此处被实现并进行了审查。

请与我们分享您的反馈。
:::

## 环境和框架 {#environments-and-frameworks}

隐式的 `ssr` 环境和其他非客户端环境在开发过程中默认使用 `RunnableDevEnvironment`。虽然这要求运行时与 Vite 服务器运行的环境相同，但这与 `ssrLoadModule` 类似，允许框架迁移并为其 SSR 开发方案启用模块热替换（HMR）。你可以使用 `isRunnableDevEnvironment` 函数来保护任何可运行的环境。

```ts
export class RunnableDevEnvironment extends DevEnvironment {
  public readonly runner: ModuleRunner
}

class ModuleRunner {
  /**
   * 要执行的 URL。
   * 可以接受文件路径，服务器路径，或者相对于根路径的 id。
   * 返回一个实例化的模块（和 ssrLoadModule 中的一样）
   */
  public async import(url: string): Promise<Record<string, any>>
  /**
   * 其他的 ModuleRunner 方法...
   */
}

if (isRunnableDevEnvironment(server.environments.ssr)) {
  await server.environments.ssr.runner.import('/entry-point.js')
}
```

:::warning
只有在第一次使用时，`runner` 才会被加载。请注意，当通过调用 `process.setSourceMapsEnabled` 或在不支持的情况下重写 `Error.prepareStackTrace` 创建 `runner` 时，Vite 会启用源映射支持。
:::

那些通过 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch) 与它们的运行环境进行交互的框架可以使用 `FetchableDevEnvironment`，它提供了一种标准化的方式来通过 `handleRequest` 方法处理请求：

```ts
import {
  createServer,
  createFetchableDevEnvironment,
  isFetchableDevEnvironment,
} from 'vite'

const server = await createServer({
  server: { middlewareMode: true },
  appType: 'custom',
  environments: {
    custom: {
      dev: {
        createEnvironment(name, config) {
          return createFetchableDevEnvironment(name, config, {
            handleRequest(request: Request): Promise<Response> | Response {
              // 处理请求并返回响应
            },
          })
        },
      },
    },
  },
})

// 现在，任何使用环境 API 的人都可以调用 `dispatchFetch`
if (isFetchableDevEnvironment(server.environments.custom)) {
  const response: Response = await server.environments.custom.dispatchFetch(
    new Request('/request-to-handle'),
  )
}
```

:::warning
Vite 会检查 `dispatchFetch` 方法的输入和输出：请求必须是全局 `Request` 类的一个实例，而响应必须是全局 `Response` 类的一个实例。如果不满足这些条件，Vite 将会抛出一个 `TypeError`。

尽管 `FetchableDevEnvironment` 是作为一个类来实现的，但请注意，Vite 团队可能会随时更改它，因为其被视为实现细节部分。
:::

## 默认 `RunnableDevEnvironment` {#default-runnabledevenvironment}

假设我们有一个配置为中间件模式的 Vite 服务器，如 [SSR 设置指南](/guide/ssr#setting-up-the-dev-server) 所述，我们可以使用环境 API 来实现 SSR 中间件。省略了错误处理。

```js
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const server = await createServer({
  server: { middlewareMode: true },
  appType: 'custom',
  environments: {
    server: {
      // 默认情况下，模块与 vite 开发服务器在同一进程中运行
    },
  },
})

// 在 TypeScript 中，你可能需要将这个转换为 RunnableDevEnvironment，或者
// 使用 "isRunnableDevEnvironment" 来保护对运行器的访问
const environment = server.environments.node

app.use('*', async (req, res, next) => {
  const url = req.originalUrl

  // 1. 读取 index.html
  const indexHtmlPath = path.resolve(__dirname, 'index.html')
  let template = fs.readFileSync(indexHtmlPath, 'utf-8')

  // 2. 应用 Vite HTML 转换。这将注入 Vite HMR 客户端，
  //    并应用来自 Vite 插件的 HTML 转换，例如
  //    @vitejs/plugin-react 提供的全局前置代码
  template = await server.transformIndexHtml(url, template)

  // 3. 加载服务器入口文件。import(url) 自动将
  //    ESM 源代码转换为 Node.js 可用的代码！
  //    不需要打包，并且提供全面的 HMR 支持。
  const { render } = await environment.runner.import('/src/entry-server.js')

  // 4. 渲染应用的 HTML。将假设 entry-server.js 导出的
  //    `render` 函数调用了对应框架的 SSR API，
  //    例如 ReactDOMServer.renderToString()
  const appHtml = await render(url)

  // 5. 将应用渲染的 HTML 注入到模板中。
  const html = template.replace(`<!--ssr-outlet-->`, appHtml)

  // 6. 发送渲染后的 HTML 回去。
  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
})
```

## 运行时无关的 SSR {#runtime-agnostic-ssr}

由于 `RunnableDevEnvironment` 只能用于在与 Vite 服务器相同的运行时中运行代码，它需要一个可以运行 Vite 服务器的运行时（即与 Node.js 兼容的运行时）。这意味着您需要使用原始的 `DevEnvironment` 来使其对运行时无关。

:::info `FetchableDevEnvironment` 提议

最初的提议是在 `DevEnvironment` 类上有一个 `run` 方法，该方法将允许消费者通过使用 `transport` 选项在运行器端调用一个导入。在我们的测试中，我们发现 API 还不够通用，以至于我们暂时不开始推荐它。目前，我们正在寻求对 [`FetchableDevEnvironment` 提议](https://github.com/vitejs/vite/discussions/18191) 的反馈。

:::

`RunnableDevEnvironment` 有一个 `runner.import` 函数，返回模块的值。但是这个函数在原始的 `DevEnvironment` 中不可用，并且需要将使用 Vite 的 API 和用户模块的代码解耦。

例如，下面的例子中，使用 Vite API 的代码使用了用户模块的值：

```ts
// 使用 Vite API 的代码
import { createServer } from 'vite'

const server = createServer()
const ssrEnvironment = server.environment.ssr
const input = {}

const { createHandler } = await ssrEnvironment.runner.import('./entrypoint.js')
const handler = createHandler(input)
const response = handler(new Request('/'))

// -------------------------------------
// ./entrypoint.js
export function createHandler(input) {
  return function handler(req) {
    return new Response('hello')
  }
}
```

如果你的代码可以在与用户模块相同的运行时中运行（即，它不依赖于 Node.js 特定的 API），你可以使用虚拟模块。这种方法避免了从使用 Vite API 的代码中获取值的需求。

```ts
// 使用 Vite API 的代码
import { createServer } from 'vite'

const server = createServer({
  plugins: [
    // 处理 `virtual:entrypoint` 的插件
    {
      name: 'virtual-module',
      /* 插件实现 */
    },
  ],
})
const ssrEnvironment = server.environment.ssr
const input = {}

// 使用每个环境工厂暴露的函数来运行代码
// 检查每个环境工厂提供了什么
if (ssrEnvironment instanceof RunnableDevEnvironment) {
  ssrEnvironment.runner.import('virtual:entrypoint')
} else if (ssrEnvironment instanceof CustomDevEnvironment) {
  ssrEnvironment.runEntrypoint('virtual:entrypoint')
} else {
  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)
}

// -------------------------------------
// virtual:entrypoint
const { createHandler } = await import('./entrypoint.js')
const handler = createHandler(input)
const response = handler(new Request('/'))

// -------------------------------------
// ./entrypoint.js
export function createHandler(input) {
  return function handler(req) {
    return new Response('hello')
  }
}
```

例如，如果你想在用户模块上调用 `transformIndexHtml`，你可以使用以下插件：

```ts {13-21}
function vitePluginVirtualIndexHtml(): Plugin {
  let server: ViteDevServer | undefined
  return {
    name: vitePluginVirtualIndexHtml.name,
    configureServer(server_) {
      server = server_
    },
    resolveId(source) {
      return source === 'virtual:index-html' ? '\0' + source : undefined
    },
    async load(id) {
      if (id === '\0' + 'virtual:index-html') {
        let html: string
        if (server) {
          this.addWatchFile('index.html')
          html = fs.readFileSync('index.html', 'utf-8')
          html = await server.transformIndexHtml('/', html)
        } else {
          html = fs.readFileSync('dist/client/index.html', 'utf-8')
        }
        return `export default ${JSON.stringify(html)}`
      }
      return
    },
  }
}
```

如果你的代码需要 Node.js API，你可以使用 `hot.send` 从用户模块与使用 Vite API 的代码进行通信。但是，请注意，这种方式在构建过程后可能无法以相同的方式工作。

```ts
// 使用 Vite API 的代码
import { createServer } from 'vite'

const server = createServer({
  plugins: [
    // 处理 `virtual:entrypoint` 的插件
    {
      name: 'virtual-module',
      /* 插件实现 */
    },
  ],
})
const ssrEnvironment = server.environment.ssr
const input = {}

// 使用每个环境工厂暴露的函数来运行代码
// 检查每个环境工厂提供了什么
if (ssrEnvironment instanceof RunnableDevEnvironment) {
  ssrEnvironment.runner.import('virtual:entrypoint')
} else if (ssrEnvironment instanceof CustomDevEnvironment) {
  ssrEnvironment.runEntrypoint('virtual:entrypoint')
} else {
  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)
}

const req = new Request('/')

const uniqueId = 'a-unique-id'
ssrEnvironment.send('request', serialize({ req, uniqueId }))
const response = await new Promise((resolve) => {
  ssrEnvironment.on('response', (data) => {
    data = deserialize(data)
    if (data.uniqueId === uniqueId) {
      resolve(data.res)
    }
  })
})

// -------------------------------------
// virtual:entrypoint
const { createHandler } = await import('./entrypoint.js')
const handler = createHandler(input)

import.meta.hot.on('request', (data) => {
  const { req, uniqueId } = deserialize(data)
  const res = handler(req)
  import.meta.hot.send('response', serialize({ res: res, uniqueId }))
})

const response = handler(new Request('/'))

// -------------------------------------
// ./entrypoint.js
export function createHandler(input) {
  return function handler(req) {
    return new Response('hello')
  }
}
```

## 构建过程中的环境 {#environments-during-build}

在命令行接口中，调用 `vite build` 和 `vite build --ssr` 仍将只构建客户端和仅 ssr 环境以保证向后兼容性。

当 `builder` 为 `undefined` 时（或者调用 `vite build --app`）时，`vite build` 将选择构建整个应用。这将在未来的主要版本中成为默认设置。将创建一个 `ViteBuilder` 实例（构建时等同于 `ViteDevServer`），用于为生产环境构建所有配置的环境。默认情况下，环境的构建按照 `environments` 记录的顺序依次运行。框架或用户可以进一步配置环境的构建方式，使用：

```js
export default {
  builder: {
    buildApp: async (builder) => {
      const environments = Object.values(builder.environments)
      return Promise.all(
        environments.map((environment) => builder.build(environment)),
      )
    },
  },
}
```

## 环境无关的代码 {#environment-agnostic-code}

大部分情况，当前的 `environment` 实例会作为正在运行代码的上下文中的一部分，所以通过 `server.environments` 来访问它们的需求应该很少。例如，在插件钩子内部，环境是作为 `PluginContext` 的一部分暴露出来的，所以可以使用 `this.environment` 来访问它。参见 [用于插件的环境 API](./api-environment-plugins.md) 了解如何构建对环境敏感的插件。

---

---
url: /guide/api-environment-runtimes.md
---
# 用于运行时的环境 API {#environment-api-for-runtimes}

:::warning 实验性
环境 API 是实验性的。在 Vite 6 期间，我们将保持这些 API 的稳定，以便生态系统可以在其基础上进行实验和构建。我们计划在 Vite 7 中稳定这些新 API，并可能进行一些重大更改。

资料：

* [反馈讨论](https://github.com/vitejs/vite/discussions/16358) 我们在此处收集新 API 的反馈。
* [环境 API PR](https://github.com/vitejs/vite/pull/16471) 新 API 在此处被实现并进行了审查。

请与我们分享您的反馈。
:::

## 环境工厂 {#environment-factories}

环境工厂（Environments factory）旨在由环境提供者（如 Cloudflare）实现，而不是由终端用户实现。环境工厂返回一个 `EnvironmentOptions`，用于在开发和构建环境中使用目标运行时的最常见情况。默认环境选项也可以设置，因此用户无需手动配置。

```ts
function createWorkerdEnvironment(
  userConfig: EnvironmentOptions,
): EnvironmentOptions {
  return mergeConfig(
    {
      resolve: {
        conditions: [
          /*...*/
        ],
      },
      dev: {
        createEnvironment(name, config) {
          return createWorkerdDevEnvironment(name, config, {
            hot: true,
            transport: customHotChannel(),
          })
        },
      },
      build: {
        createEnvironment(name, config) {
          return createWorkerdBuildEnvironment(name, config)
        },
      },
    },
    userConfig,
  )
}
```

配置文件可以写为：

```js
import { createWorkerdEnvironment } from 'vite-environment-workerd'

export default {
  environments: {
    ssr: createWorkerdEnvironment({
      build: {
        outDir: '/dist/ssr',
      },
    }),
    rsc: createWorkerdEnvironment({
      build: {
        outDir: '/dist/rsc',
      },
    }),
  },
}
```

并且框架可以使用带有 workerd 运行时的环境来执行以下操作：

```js
const ssrEnvironment = server.environments.ssr
```

## 创建新的环境工厂 {#creating-a-new-environment-factory}

Vite 开发服务器默认暴露两个环境：一个 `client` 环境和一个 `ssr` 环境。客户端环境默认是浏览器环境，模块运行器（module runner）通过将虚拟模块 `/@vite/client` 导入客户端应用来实现。SSR 环境默认在与 Vite 服务器相同的 Node 运行时中运行，允许应用服务器在开发期间使用完整的 HMR 支持来渲染请求。

转换后的源代码称为模块（module），在每个环境中处理的模块之间的关系保存在模块图中。这些模块的转换代码被发送到与每个环境关联的运行时以执行。当一个模块在运行时中被执行时，它的导入模块将被请求，从而触发模块图的一部分处理。

Vite 模块运行器允许首先使用 Vite 插件处理代码来运行任何代码。它不同于 `server.ssrLoadModule`，因为运行器实现与服务器解耦。这允许库和框架作者实现 Vite 服务器与运行器之间的通信层。浏览器通过服务器 Web Socket 和 HTTP 请求与其对应的环境通信。Node 模块运行器可以直接通过函数调用处理模块，因为它在同一进程中运行。其他环境可以通过连接到 JS 运行时（如 workerd）或 Worker 线程（如 Vitest）来运行模块。

此功能的目标之一是提供一个可定制的 API 来处理和运行代码。用户可以使用暴露的基础组件创建新的环境工厂。

```ts
import { DevEnvironment, HotChannel } from 'vite'

function createWorkerdDevEnvironment(
  name: string,
  config: ResolvedConfig,
  context: DevEnvironmentContext
) {
  const connection = /* ... */
  const transport: HotChannel = {
    on: (listener) => { connection.on('message', listener) },
    send: (data) => connection.send(data),
  }

  const workerdDevEnvironment = new DevEnvironment(name, config, {
    options: {
      resolve: { conditions: ['custom'] },
      ...context.options,
    },
    hot: true,
    transport,
  })
  return workerdDevEnvironment
}
```

## `ModuleRunner`

一个模块运行器在目标运行时中实例化。下一节中的所有 API 都从 `vite/module-runner` 导入，除非另有说明。这个导出入口文件尽可能保持轻量，仅导出创建模块运行器所需的最小部分。

**类型签名：**

```ts
export class ModuleRunner {
  constructor(
    public options: ModuleRunnerOptions,
    public evaluator: ModuleEvaluator = new ESModulesEvaluator(),
    private debug?: ModuleRunnerDebugger,
  ) {}
  /**
   * 要执行的 URL。
   * 可以是文件路径，服务器路径，或者相对于根路径的 id
   */
  public async import<T = any>(url: string): Promise<T>
  /**
   * 清除所有缓存，包括 HMR 监听器
   */
  public clearCache(): void
  /**
   * 清除所有缓存，移除所有 HMR 监听器，并重置源映射支持
   * 此方法不会停止 HMR 连接
   */
  public async close(): Promise<void>
  /**
   * 如果通过调用 `close()` 关闭了运行器，则返回 `true`
   */
  public isClosed(): boolean
}
```

`ModuleRunner` 中的模块评估器负责执行代码。Vite 默认导出 `ESModulesEvaluator`，它使用 `new AsyncFunction` 来执行代码。如果你的 JavaScript 运行时不支持不安全的运行，你可以提供你自己的实现。

模块运行器暴露了 `import` 方法。当 Vite 服务器触发 `full-reload` HMR 事件时，所有受影响的模块将被重新执行。请注意，当这种情况发生时，模块运行器不会更新 `exports` 对象（会覆盖它），如果你依赖于拥有最新的 `exports` 对象，你需要再次运行 `import` 或从 `evaluatedModules` 中获取模块。

**使用示例：**

```js
import { ModuleRunner, ESModulesEvaluator } from 'vite/module-runner'
import { transport } from './rpc-implementation.js'

const moduleRunner = new ModuleRunner(
  {
    transport,
  },
  new ESModulesEvaluator(),
)

await moduleRunner.import('/src/entry-point.js')
```

## `ModuleRunnerOptions`

```ts twoslash
import type {
  InterceptorOptions as InterceptorOptionsRaw,
  ModuleRunnerHmr as ModuleRunnerHmrRaw,
  EvaluatedModules,
} from 'vite/module-runner'
import type { Debug } from '@type-challenges/utils'

type InterceptorOptions = Debug<InterceptorOptionsRaw>
type ModuleRunnerHmr = Debug<ModuleRunnerHmrRaw>
/** 见下文 */
type ModuleRunnerTransport = unknown

// ---cut---
interface ModuleRunnerOptions {
  /**
   * 一组与服务器通信的方法
   */
  transport: ModuleRunnerTransport
  /**
   * 配置如何解析源映射。
   * 如果 `process.setSourceMapsEnabled` 可用，首选 `node`
   * 否则，它将默认使用 `prepareStackTrace`，这将
   * 覆盖 `Error.prepareStackTrace` 方法
   * 你可以提供一个对象来配置如何解析
   * 未被 Vite 处理的文件的内容和其源映射
   */
  sourcemapInterceptor?:
    | false
    | 'node'
    | 'prepareStackTrace'
    | InterceptorOptions
  /**
   * 禁用 HMR 或配置 HMR 选项
   *
   * @default true
   */
  hmr?: boolean | ModuleRunnerHmr
  /**
   * 自定义模块缓存。如果未提供，它将创建一个单独的模块缓存给
   * 每个模块运行器实例
   */
  evaluatedModules?: EvaluatedModules
}
```

## `ModuleEvaluator`

**类型签名：**

```ts twoslash
import type { ModuleRunnerContext as ModuleRunnerContextRaw } from 'vite/module-runner'
import type { Debug } from '@type-challenges/utils'

type ModuleRunnerContext = Debug<ModuleRunnerContextRaw>

// ---cut---
export interface ModuleEvaluator {
  /**
   *  转换后代码中前缀行的数量。
   */
  startOffset?: number
  /**
   * 运行由 Vite 转换的代码。
   * @param context 函数上下文
   * @param code 转换后的代码
   * @param id 用于获取模块的 ID
   */
  runInlinedModule(
    context: ModuleRunnerContext,
    code: string,
    id: string,
  ): Promise<any>
  /**
   * 运行外部化的模块
   * @param file 外部模块的文件 URL
   */
  runExternalModule(file: string): Promise<any>
}
```

Vite 默认导出了实现此接口的 `ESModulesEvaluator`。它使用 `new AsyncFunction` 来执行代码，因此，如果代码有内联源映射，它应该包含 [2 行的偏移](https://tc39.es/ecma262/#sec-createdynamicfunction) 以适应新增的行。这是由 `ESModulesEvaluator` 自动完成的。自定义评估器不会添加额外的行。

## `ModuleRunnerTransport` {#modulerunnertransport}

**类型签名：**

```ts twoslash
import type { ModuleRunnerTransportHandlers } from 'vite/module-runner'
/** 一个对象 */
type HotPayload = unknown
// ---cut---
interface ModuleRunnerTransport {
  connect?(handlers: ModuleRunnerTransportHandlers): Promise<void> | void
  disconnect?(): Promise<void> | void
  send?(data: HotPayload): Promise<void> | void
  invoke?(data: HotPayload): Promise<{ result: any } | { error: any }>
  timeout?: number
}
```

通过 RPC 或直接调用函数与环境通信的传输对象。如果未执行 `invoke` 方法，则必须执行 `send` 方法和 `connect` 方法。Vite 将在内部构建 `invoke` 方法。

你需要将它与服务器上的 `HotChannel` 实例结合起来，就像本例中在工作线程中创建模块运行程序一样：

::: code-group

```js [worker.js]
import { parentPort } from 'node:worker_threads'
import { fileURLToPath } from 'node:url'
import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'

/** @type {import('vite/module-runner').ModuleRunnerTransport} */
const transport = {
  connect({ onMessage, onDisconnection }) {
    parentPort.on('message', onMessage)
    parentPort.on('close', onDisconnection)
  },
  send(data) {
    parentPort.postMessage(data)
  },
}

const runner = new ModuleRunner(
  {
    transport,
  },
  new ESModulesEvaluator(),
)
```

```js [server.js]
import { BroadcastChannel } from 'node:worker_threads'
import { createServer, RemoteEnvironmentTransport, DevEnvironment } from 'vite'

function createWorkerEnvironment(name, config, context) {
  const worker = new Worker('./worker.js')
  const handlerToWorkerListener = new WeakMap()

  const workerHotChannel = {
    send: (data) => worker.postMessage(data),
    on: (event, handler) => {
      if (event === 'connection') return

      const listener = (value) => {
        if (value.type === 'custom' && value.event === event) {
          const client = {
            send(payload) {
              worker.postMessage(payload)
            },
          }
          handler(value.data, client)
        }
      }
      handlerToWorkerListener.set(handler, listener)
      worker.on('message', listener)
    },
    off: (event, handler) => {
      if (event === 'connection') return
      const listener = handlerToWorkerListener.get(handler)
      if (listener) {
        worker.off('message', listener)
        handlerToWorkerListener.delete(handler)
      }
    },
  }

  return new DevEnvironment(name, config, {
    transport: workerHotChannel,
  })
}

await createServer({
  environments: {
    worker: {
      dev: {
        createEnvironment: createWorkerEnvironment,
      },
    },
  },
})
```

:::

使用 HTTP 请求在运行程序和服务器之间进行通信的另一个示例：

```ts
import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'

export const runner = new ModuleRunner(
  {
    transport: {
      async invoke(data) {
        const response = await fetch(`http://my-vite-server/invoke`, {
          method: 'POST',
          body: JSON.stringify(data),
        })
        return response.json()
      },
    },
    hmr: false, // disable HMR as HMR requires transport.connect
  },
  new ESModulesEvaluator(),
)

await runner.import('/entry.js')
```

在这种情况下，可以使用 `NormalizedHotChannel` 中的 `handleInvoke` 方法：

```ts
const customEnvironment = new DevEnvironment(name, config, context)

server.onRequest((request: Request) => {
  const url = new URL(request.url)
  if (url.pathname === '/invoke') {
    const payload = (await request.json()) as HotPayload
    const result = customEnvironment.hot.handleInvoke(payload)
    return new Response(JSON.stringify(result))
  }
  return Response.error()
})
```

但请注意，要支持 HMR，必须使用 `send` 和 `connect` 方法。`send` 方法通常在触发自定义事件时调用（如`import.meta.hot.send("my-event")`）。

Vite 从主入口导出 `createServerHotChannel`，以支持 Vite SSR 期间的 HMR。

---

---
url: /guide/comparisons.md
---
# 与其他工具比较 {#comparisons}

## WMR {#wmr}

Preact 团队的 [WMR](https://github.com/preactjs/wmr) 旨在提供类似的功能集，Vite 的通用 Rollup 插件 API（用于开发和构建）就是受此启发而设计的。

目前，WMR 已经停止维护。Preact 团队现在建议搭配使用 Vite 和 [@preactjs/preset-vite](https://github.com/preactjs/preset-vite)。

## @web/dev-server {#web-dev-server}

[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/)（曾经是 `es-dev-server`）是一个伟大的项目，基于 koa 的 Vite 1.0 开发服务器就是受到了它的启发。

`@web/dev-server` 适用范围不是很广。它并未提供官方的框架集成，并且需要为生产构建手动设置 Rollup 配置。

总的来说，与 `@web/dev-server` 相比，Vite 是一个更有主见、集成度更高的工具，旨在提供开箱即用的工作流。话虽如此，但 `@web` 这个项目群包含了许多其他的优秀工具，也可以使 Vite 用户受益。

## Snowpack {#snowpack}

[Snowpack](https://www.snowpack.dev/) 也是一个与 Vite 十分类似的非构建式原生 ESM 开发服务器。该项目已经不维护了。团队目前正在开发 [Astro](https://astro.build/)，一个由 Vite 驱动的静态站点构建工具。Astro 团队目前是我们生态中非常活跃的成员，他们帮助 Vite 进益良多。

除了不同的实现细节外，这两个项目在技术上比传统工具有很多共同优势。Vite 的依赖预构建也受到了 Snowpack v1（现在是 [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)）的启发。若想了解 Vite 同这两个项目之间的一些主要区别，可以查看 [Vite v2 比较指南](https://v2.vite.dev/guide/comparisons)。

---

---
url: /config/preview-options.md
---
# 预览选项 {#preview-options}

除非另有说明，本节中的选项仅适用于预览。

## preview.host

* **类型：** `string | boolean`
* **默认：** [`server.host`](./server-options#server-host)

为开发服务器指定 ip 地址。
设置为 `0.0.0.0` 或 `true` 会监听所有地址，包括局域网和公共地址。

还可以通过 CLI 进行设置，使用 `--host 0.0.0.0` 或 `--host`。

::: tip 注意

在某些情况下，可能响应的是其他服务器而不是 Vite。
查看 [`server.host`](./server-options#server-host) 了解更多细节。

:::

## preview.allowedHosts

* **类型：** `string | true`
* **默认：** [`server.allowedHosts`](./server-options#server-allowedhosts)

Vite 允许响应的主机名。

查看 [`server.allowedHosts`](./server-options#server-allowedhosts) 以获取更多详细信息。

## preview.port {#preview-port}

* **类型：** `number`
* **默认：** `4173`

指定开发服务器端口。注意，如果设置的端口已被使用，Vite 将自动尝试下一个可用端口，所以这可能不是最终监听的服务器端口。

**示例：**

```js
export default defineConfig({
  server: {
    port: 3030,
  },
  preview: {
    port: 8080,
  },
})
```

## preview.strictPort {#preview-strictport}

* **类型：** `boolean`
* **默认：** [`server.strictPort`](./server-options#server-strictport)

设置为 `true` 时，如果端口已被使用，则直接退出，而不会再进行后续端口的尝试。

## preview.https {#preview-https}

* **类型：** `https.ServerOptions`
* **默认：** [`server.https`](./server-options#server-https)

启用 TLS + HTTP/2。

有关更多详细信息，请参阅 [`server.https`](./server-options#server-https)。

## preview.open {#preview-open}

* **类型：** `boolean | string`
* **默认：** [`server.open`](./server-options#server-open)

开发服务器启动时，自动在浏览器中打开应用程序。当该值为字符串时，它将被用作 URL 的路径名。如果你想在你喜欢的某个浏览器打开该开发服务器，你可以设置环境变量 `process.env.BROWSER` （例如 `firefox`）。欲了解更多细节，请参阅 [`open` 包的源码](https://github.com/sindresorhus/open#app)。

`BROWSER` 和 `BROWSER_ARGS` 是两个特殊的环境变量，你可以在 `.env` 文件中设置它们用以配置本选项。查看 [`open` 这个包](https://github.com/sindresorhus/open#app) 了解更多详情。

## preview.proxy {#preview-proxy}

* **类型：** `Record<string, string | ProxyOptions>`
* **默认：** [`server.proxy`](./server-options#server-proxy)

为开发服务器配置自定义代理规则。其值的结构为 `{ key: options }` 的对象。如果 key 以 `^` 开头，它将被识别为 `RegExp`，其中 `configure` 选项可用于访问代理实例。

基于 [`http-proxy`](https://github.com/http-party/node-http-proxy) 实现，完整的参数列表参见 [此链接](https://github.com/http-party/node-http-proxy#options)。

## preview.cors {#preview-cors}

* **类型：** `boolean | CorsOptions`
* **默认：** [`server.cors`](./server-options#server-cors)

为预览服务器配置 CORS。

请查看 [`server.cors`](./server-options#server-cors) 了解更多细节。

## preview.headers {#preview-headers}

* **类型：** `OutgoingHttpHeaders`

指明服务器返回的响应头。

---

---
url: /changes/hotupdate-hook.md
---
# HMR `hotUpdate` 插件钩子 {#hmr-hotupdate-plugin-hook}

::: tip 反馈
可以在 [环境 API 讨论](https://github.com/vitejs/vite/discussions/16358) 中向我们提供反馈
:::

我们计划废弃 `handleHotUpdate` 插件钩子，转而使用能够感知 [环境 API](/guide/api-environment.md) 的 [`hotUpdate` 钩子](/guide/api-environment#the-hotupdate-hook)，并通过 `create` 和 `delete` 来处理额外的监听事件。

影响范围：`Vite 插件作者`

::: warning 即将废弃
`hotUpdate` 钩子最初在 `v6.0` 版本中引入。我们计划在 `v7.0` 版本中废弃 `handleHotUpdate` 钩子。我们目前还不建议你停止使用 `handleHotUpdate`。如果你想尝试并向我们提供反馈，你可以在你的 vite 配置文件中将 `future.removePluginHookHandleHotUpdate` 设置为 `"warn"`。
:::

## 动机 {#motivation}

[`handleHotUpdate` 钩子](/guide/api-plugin.md#handlehotupdate) 可以让你执行自定义的模块热替换（HMR）更新处理。在 `HmrContext` 中，可以传入一个需要更新的模块列表。

```ts
interface HmrContext {
  file: string
  timestamp: number
  modules: Array<ModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

`handleHotUpdate` 钩子在所有环境中只调用一次，传入的模块只有来自客户端和 SSR 环境的混合信息。一旦框架开始使用自定义环境，就需要一个新的钩子为每个环境调用。

新的 `hotUpdate` 钩子的工作方式与 `handleHotUpdate` 一样，但是它会在每个环境中被调用，并且会接收一个新的 `HotUpdateOptions` 实例：

```ts
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

你可以像在其他插件钩子中一样，通过 `this.environment` 来访问当前的开发环境。现在，`modules` 列表只包含来自当前环境的模块节点。每个环境更新都可以定义不同的更新策略。

这个钩子也会在处理额外的监听事件时被调用，而不仅仅是在 `'update'` 事件中。你可以使用 `type` 来区分这些事件。

## 迁移指南 {#migration-guide}

过滤并缩小受影响的模块列表，使 HMR 更加准确。

```js
handleHotUpdate({ modules }) {
  return modules.filter(condition)
}

// 迁移至：

hotUpdate({ modules }) {
  return modules.filter(condition)
}
```

返回一个空数组并执行完全重载：

```js
handleHotUpdate({ server, modules, timestamp }) {
  // 手动使模块失效
  const invalidatedModules = new Set()
  for (const mod of modules) {
    server.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    )
  }
  server.ws.send({ type: 'full-reload' })
  return []
}

// 迁移至：

hotUpdate({ modules, timestamp }) {
  // 手动使模块失效
  const invalidatedModules = new Set()
  for (const mod of modules) {
    this.environment.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    )
  }
  this.environment.hot.send({ type: 'full-reload' })
  return []
}
```

返回一个空数组并通过向客户端发送自定义事件来执行完全自定义的 HMR 处理：

```js
handleHotUpdate({ server }) {
  server.ws.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}

// 迁移至：

hotUpdate() {
  this.environment.hot.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}
```

---

---
url: /guide/api-hmr.md
---
# HMR API {#hmr-api}

:::tip 注意
这里是客户端 HMR API。若要在插件中处理 HMR 更新，详见 [handleHotUpdate](./api-plugin#handlehotupdate)。

手动 HMR API 主要用于框架和工具作者。作为最终用户，HMR 可能已经在特定于框架的启动器模板中为你处理过了。
:::

Vite 通过特殊的 `import.meta.hot` 对象暴露手动 HMR API。

```ts twoslash
import type { ModuleNamespace } from 'vite/types/hot.d.ts'
import type {
  CustomEventName,
  InferCustomEventPayload,
} from 'vite/types/customEvent.d.ts'

// ---cut---
interface ImportMeta {
  readonly hot?: ViteHotContext
}

interface ViteHotContext {
  readonly data: any

  accept(): void
  accept(cb: (mod: ModuleNamespace | undefined) => void): void
  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void
  accept(
    deps: readonly string[],
    cb: (mods: Array<ModuleNamespace | undefined>) => void,
  ): void

  dispose(cb: (data: any) => void): void
  prune(cb: (data: any) => void): void
  invalidate(message?: string): void

  on<T extends CustomEventName>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  off<T extends CustomEventName>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  send<T extends CustomEventName>(
    event: T,
    data?: InferCustomEventPayload<T>,
  ): void
}
```

## 必需的条件守卫 {#required-conditional-guard}

首先，请确保用一个条件语句守护所有 HMR API 的使用，这样代码就可以在生产环境中被 tree-shaking 优化：

```js
if (import.meta.hot) {
  // HMR 代码
}
```

## TypeScript 的智能提示 {#intellisense-for-typescript}

Vite 在 [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts) 中为 `import.meta.hot` 提供了类型定义。你可以在 `src` 目录中创建一个 `env.d.ts`，以便 TypeScript 获取类型定义：

```ts
/// <reference types="vite/client" />
```

## `hot.accept(cb)` {#hot-accept-cb}

要接收模块自身，应使用 `import.meta.hot.accept`，参数为接收已更新模块的回调函数：

```js twoslash
import 'vite/client'
// ---cut---
export const count = 1

if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    if (newModule) {
      //  当语法错误发生时，newModule 是 undefined
      console.log('updated: count is now ', newModule.count)
    }
  })
}
```

“接受” 热更新的模块被认为是 **HMR 边界**。

Vite 的 HMR 实际上并不替换最初导入的模块：如果一个 HMR 边界模块重新导出来自依赖项的导入，则它应负责更新这些重新导出的模块（这些导出必须使用 `let`）。此外，从边界模块向上的导入者将不会收到更新。这种简化的 HMR 实现对于大多数开发用例来说已经足够了，同时允许我们跳过生成代理模块的昂贵工作。

Vite 要求这个函数的调用在源代码中显示为 `import.meta.hot.accept(`（对空格敏感），这样模块才能接受更新。这是 Vite 为使模块支持 HMR 而进行的静态分析的一个要求。

## `hot.accept(deps, cb)` {#hot-accept-deps-cb}

模块也可以接受直接依赖项的更新，而无需重新加载自身：

```js twoslash
// @filename: /foo.d.ts
export declare const foo: () => void

// @filename: /example.js
import 'vite/client'
// ---cut---
import { foo } from './foo.js'

foo()

if (import.meta.hot) {
  import.meta.hot.accept('./foo.js', (newFoo) => {
    // 回调函数接收到更新后的'./foo.js' 模块
    newFoo?.foo()
  })

  // 也可以接受一个依赖模块的数组：
  import.meta.hot.accept(
    ['./foo.js', './bar.js'],
    ([newFooModule, newBarModule]) => {
      // 只有当所更新的模块非空时，回调函数接收一个数组
      // 如果更新不成功（例如语法错误），则该数组为空
    }
  )
}
```

## `hot.dispose(cb)` {#hot-dispose-cb}

一个接收自身的模块或一个期望被其他模块接收的模块可以使用 `hot.dispose` 来清除任何由其更新副本产生的持久副作用：

```js twoslash
import 'vite/client'
// ---cut---
function setupSideEffect() {}

setupSideEffect()

if (import.meta.hot) {
  import.meta.hot.dispose((data) => {
    // 清理副作用
  })
}
```

## `hot.prune(cb)` {#hot-prune-cb}

注册一个回调，当模块在页面上不再被导入时调用。与 `hot.dispose` 相比，如果源代码更新时自行清理了副作用，你只需要在模块从页面上被删除时，使用此方法进行清理。Vite 目前在 `.css` 导入上使用此方法。

```js twoslash
import 'vite/client'
// ---cut---
function setupOrReuseSideEffect() {}

setupOrReuseSideEffect()

if (import.meta.hot) {
  import.meta.hot.prune((data) => {
    // 清理副作用
  })
}
```

## `hot.data` {#hot-data}

`import.meta.hot.data` 对象在同一个更新模块的不同实例之间持久化。它可以用于将信息从模块的前一个版本传递到下一个版本。

注意，不支持对 `data` 本身的重新赋值。相反，你应该对 `data` 对象的属性进行突变，以便保留从其他处理程序添加的信息。

```js twoslash
import 'vite/client'
// ---cut---
// ok
import.meta.hot.data.someValue = 'hello'

// 不支持
import.meta.hot.data = { someValue: 'hello' }
```

## `hot.decline()` {#hot-decline}

目前是一个空操作并暂留用于向后兼容。若有新的用途设计可能在未来会发生变更。要指明某模块是不可热更新的，请使用 `hot.invalidate()`。

## `hot.invalidate(message?: string)` {#hot-invalidate}

一个接收自身的模块可以在运行时意识到它不能处理 HMR 更新，因此需要将更新强制传递给导入者。通过调用 `import.meta.hot.invalidate()`，HMR 服务将使调用方的导入失效，就像调用方不是接收自身的一样。这会同时在浏览器控制台和命令行中打印出一条信息，你可以传入这条信息，对发生失效的原因给予一些上下文。

请注意，你应该总是调用 `import.meta.hot.accept`，即使你打算随后立即调用 `invalidate`，否则 HMR 客户端将不会监听未来对接收自身模块的更改。为了清楚地表达你的意图，我们建议在 `accept` 回调中调用 `invalidate`，例如：

```js twoslash
import 'vite/client'
// ---cut---
import.meta.hot.accept((module) => {
  // 你可以使用新的模块实例来决定是否使其失效。
  if (cannotHandleUpdate(module)) {
    import.meta.hot.invalidate()
  }
})
```

## `hot.on(event, cb)` {#hot-onevent-cb}

监听自定义 HMR 事件。

以下 HMR 事件由 Vite 自动触发：

* `'vite:beforeUpdate'` 当更新即将被应用时（例如，一个模块将被替换）
* `'vite:afterUpdate'` 当更新已经被应用时（例如，一个模块已被替换）
* `'vite:beforeFullReload'` 当完整的重载即将发生时
* `'vite:beforePrune'` 当不再需要的模块即将被剔除时
* `'vite:invalidate'` 当使用 `import.meta.hot.invalidate()` 使一个模块失效时
* `'vite:error'` 当发生错误时（例如，语法错误）
* `'vite:ws:disconnect'` 当 WebSocket 连接丢失时
* `'vite:ws:connect'` 当 WebSocket 重新建立连接时

自定义 HMR 事件可以由插件发送。更多细节详见 [handleHotUpdate](./api-plugin#handleHotUpdate)。

## `hot.off(event, cb)` {#hot-offevent-cb}

从事件监听器中移除回调函数。

## `hot.send(event, data)` {#hot-send-event-data}

发送自定义事件到 Vite 开发服务器。

如果在连接前调用，数据会先被缓存、等到连接建立好后再发送。

查看 [客户端与服务端间通信](/guide/api-plugin.html#client-server-communication) 以及 [自定义事件的 TypeScript 类型定义指南](/guide/api-plugin.html#typescript-for-custom-events) 章节获取更多细节。

## 推荐阅读 {#further-reading}

如果你想深入了解如何使用 HMR API，以及它的内部运作机制，可以参考以下资源：

* [热模块替换其实很简单](https://bjornlu.com/blog/hot-module-replacement-is-easy)

---

---
url: /guide/api-javascript.md
---
# JavaScript API {#javascript-api}

Vite 的 JavaScript API 是完全类型化的，我们推荐使用 TypeScript 或者在 VS Code 中启用 JS 类型检查来利用智能提示和类型签名。

## `createServer` {#createserver}

**类型签名：**

```ts
async function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>
```

**使用示例：**

```ts twoslash
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

const server = await createServer({
  // 任何合法的用户配置选项，加上 `mode` 和 `configFile`
  configFile: false,
  root: __dirname,
  server: {
    port: 1337,
  },
})
await server.listen()

server.printUrls()
server.bindCLIShortcuts({ print: true })
```

::: tip 注意
当在同一个 Node.js 进程中使用 `createServer` 和 `build` 时，两个函数都依赖于 `process.env.NODE_ENV` 才可正常工作，而这个环境变量又依赖于 `mode` 配置项。为了避免行为冲突，请在使用这两个 API 时为 `process.env.NODE_ENV` 或者 `mode` 配置项、字段设置参数值 `development`，或者你也可以生成另一个子进程，分别运行这两个 API。
:::

::: tip 注意
当使用 [中间件模式](/config/server-options.md#server-middlewaremode) 与 [WebSocket 代理配置](/config/server-options.md#server-proxy) 时，父 http 服务器应该在 `middlewareMode` 中提供，以正确绑定代理。

```ts twoslash
import http from 'http'
import { createServer } from 'vite'

const parentServer = http.createServer() // or express, koa, etc.

const vite = await createServer({
  server: {
    // 开启中间件模式
    middlewareMode: {
      // 提供父 http 服务器以代理 WebSocket
      server: parentServer,
    },
    proxy: {
      '/ws': {
        target: 'ws://localhost:3000',
        // Proxying WebSocket
        ws: true,
      },
    },
  },
})

// @noErrors: 2339
parentServer.use(vite.middlewares)
```

## `InlineConfig` {#inlineconfig}

`InlineConfig` 接口扩展了 `UserConfig` 并添加了以下属性：

* `configFile`：指明要使用的配置文件。如果没有设置，Vite 将尝试从项目根目录自动解析。设置为 `false` 可以禁用自动解析功能。

## `ResolvedConfig` {#resolvedconfig}

`ResolvedConfig` 接口和 `UserConfig` 有完全相同的属性，期望多数属性是已经解析完成且不为 undefined 的。它同样包括下面这样的工具方法：

* `config.assetsInclude`：一个函数，用来检查一个 `id` 是否被考虑为是一个资源。
* `config.logger`：Vite 内部的日志对象。

## `ViteDevServer` {#vitedevserver}

```ts
interface ViteDevServer {
  /**
   * 被解析的 Vite 配置对象
   */
  config: ResolvedConfig
  /**
   * 一个 connect 应用实例
   * - 可以用于将自定义中间件附加到开发服务器。
   * - 还可以用作自定义http服务器的处理函数。
      或作为中间件用于任何 connect 风格的 Node.js 框架。
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * 本机 node http 服务器实例
   */
  httpServer: http.Server | null
  /**
   * chokidar 监听器实例。如果 `config.server.watch` 被设置为 `null`，
   * 它不会监听任何文件，并且调用 `add` 或 `unwatch` 将不起作用。
   * https://github.com/paulmillr/chokidar/tree/3.6.0#api
   */
  watcher: FSWatcher
  /**
   * web socket 服务器，带有 `send(payload)` 方法。
   */
  ws: WebSocketServer
  /**
   * Rollup 插件容器，可以针对给定文件运行插件钩子。
   */
  pluginContainer: PluginContainer
  /**
   * 跟踪导入关系、url 到文件映射和 hmr 状态的模块图。
   */
  moduleGraph: ModuleGraph
  /**
   * Vite 在 CLI 上打印的已解析的 URL（经 URL 编码处理）。
   * 在中间件模式下或服务器未监听任何端口时，返回 `null`。
   */
  resolvedUrls: ResolvedServerUrls | null
  /**
   * 编程式地解析、加载和转换一个 URL 并获得
   * 还没有进入 HTTP 请求管道中的结果
   */
  transformRequest(
    url: string,
    options?: TransformOptions,
  ): Promise<TransformResult | null>
  /**
   * 应用 Vite 内建 HTML 转换和任意插件 HTML 转换
   */
  transformIndexHtml(
    url: string,
    html: string,
    originalUrl?: string,
  ): Promise<string>
  /**
   * 加载一个给定的 URL 作为 SSR 的实例化模块
   */
  ssrLoadModule(
    url: string,
    options?: { fixStacktrace?: boolean },
  ): Promise<Record<string, any>>
  /**
   * 解决 ssr 错误堆栈信息
   */
  ssrFixStacktrace(e: Error): void
  /**
   * 触发模块图中某个模块的 HMR。你可以使用 `server.moduleGraph`
   * API 来检索要重新加载的模块。如果 `hmr` 是 `false`，则不进行任何操作
   */
  reloadModule(module: ModuleNode): Promise<void>
  /**
   * 启动服务器
   */
  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
  /**
   * 重启服务器
   *
   * @param forceOptimize - 强制优化器打包，和命令行内使用 --force 一致
   */
  restart(forceOptimize?: boolean): Promise<void>
  /**
   * 停止服务器
   */
  close(): Promise<void>
  /**
   * 绑定 CLI 快捷键
   */
  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
  /**
   * 调用 `await server.waitForRequestsIdle(id)` 会等待所有的静态导入
   * 都被处理完。如果这个函数是从一个加载或转换的插件钩子中被调用的，那么你需要
   * 把 id 作为参数传入，以避免死锁。在模块图的第一个静态导入部分被处理之后
   * 调用这个函数，它将立即返回。
   * @实验性
   */
  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
}
```

:::info
`waitForRequestsIdle` 的设计初衷是作为一种应急措施，以改善那些无法按照 Vite 开发服务器按需加载特性来实现的功能的开发体验。像 Tailwind 这样的工具可以在启动期间使用它，以便在应用代码被加载之前延迟生成应用的 CSS 类，从而避免样式的闪烁变化。当这个函数在加载或转换钩子中被使用，并且使用的是默认的 HTTP1 服务器时，六个 http 通道中的一个将被阻塞，直到服务器处理完所有的静态导入。Vite 的依赖优化器目前使用这个函数来避免在缺少依赖项时进行全页刷新，它通过延迟加载预打包的依赖项，直到从静态导入的源收集到所有的导入依赖项。在未来的主要版本中，Vite 可能会采取不同的策略，将 `optimizeDeps.crawlUntilStaticImports: false` 设置为默认值，以避免在大型应用程序在冷启动期间出现性能下降。
:::

## `build` {#build}

**类型签名：**

```ts
async function build(
  inlineConfig?: InlineConfig,
): Promise<RollupOutput | RollupOutput[]>
```

**使用示例：**

```ts twoslash [vite.config.js]
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { build } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

await build({
  root: path.resolve(__dirname, './project'),
  base: '/foo/',
  build: {
    rollupOptions: {
      // ...
    },
  },
})
```

## `preview` {#preview}

**类型签名：**

```ts
async function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>
```

**示例用法：**

```ts twoslash
import { preview } from 'vite'

const previewServer = await preview({
  // 任何合法的用户配置选项，加上 `mode` 和 `configFile`
  preview: {
    port: 8080,
    open: true,
  },
})

previewServer.printUrls()
previewServer.bindCLIShortcuts({ print: true })
```

## `PreviewServer`

```ts
interface PreviewServer {
  /**
   * 解析后的 vite 配置对象
   */
  config: ResolvedConfig
  /**
   * 一个 connect 应用实例。
   * - 可用作将自定义中间件附加到预览服务器上。
   * - 还可用作自定义 HTTP 服务器的处理函数
   *   或作为任何 connect 风格的 Node.js 框架的中间件
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * 原生 Node http 服务器实例
   */
  httpServer: http.Server
  /**
   * Vite 在 CLI 上打印的已解析的 URL（经 URL 编码处理）。
   * 在服务器未监听任何端口时，返回 `null`。
   */
  resolvedUrls: ResolvedServerUrls | null
  /**
   * 打印服务器 URL
   */
  printUrls(): void
  /**
   * 设置 CLI 快捷键
   */
  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void
}
```

## `resolveConfig` {#resolveconfig}

**类型签名：**

```ts
async function resolveConfig(
  inlineConfig: InlineConfig,
  command: 'build' | 'serve',
  defaultMode = 'development',
  defaultNodeEnv = 'development',
  isPreview = false,
): Promise<ResolvedConfig>
```

该 `command` 值在开发环境和预览环境 为 `serve`，而在构建环境是 `build`。

## `mergeConfig`

**类型签名：**

```ts
function mergeConfig(
  defaults: Record<string, any>,
  overrides: Record<string, any>,
  isRoot = true,
): Record<string, any>
```

深度合并两份配置。`isRoot` 代表着 Vite 配置被合并的层级。举个例子，如果你是要合并两个 `build` 选项请设为 `false`。

::: tip NOTE
`mergeConfig` 只接受对象形式的配置。如果有一个回调形式的配置，应该在将其传递给 `mergeConfig` 之前先调用该回调函数，将其转换成对象形式。

你可以使用 `defineConfig` 工具函数将回调形式的配置与另一个配置合并：

```ts twoslash
import {
  defineConfig,
  mergeConfig,
  type UserConfigFnObject,
  type UserConfig,
} from 'vite'
declare const configAsCallback: UserConfigFnObject
declare const configAsObject: UserConfig

// ---cut---
export default defineConfig((configEnv) =>
  mergeConfig(configAsCallback(configEnv), configAsObject),
)
```

:::

## `searchForWorkspaceRoot`

**类型签名：**

```ts
function searchForWorkspaceRoot(
  current: string,
  root = searchForPackageRoot(current),
): string
```

**相关内容：** [server.fs.allow](/config/server-options.md#server-fs-allow)

如果当前工作空间满足以下条件，则搜索它的根目录，否则它将回退到 `root`：

* `package.json` 中包含 `workspaces` 字段
* 包含以下文件之一：
  * `lerna.json`
  * `pnpm-workspace.yaml`

## `loadEnv`

**类型签名：**

```ts
function loadEnv(
  mode: string,
  envDir: string,
  prefixes: string | string[] = 'VITE_',
): Record<string, string>
```

**相关内容：** [`.env` Files](./env-and-mode.md#env-files)

加载 `envDir` 中的 `.env` 文件。默认情况下只有前缀为 `VITE_` 会被加载，除非更改了 `prefixes` 配置。

## `normalizePath`

**类型签名：**

```ts
function normalizePath(id: string): string
```

**相关内容：** [路径规范化](./api-plugin.md#path-normalization)

规范化路径，以便在 Vite 插件之间互操作。

## `transformWithEsbuild`

**类型签名：**

```ts
async function transformWithEsbuild(
  code: string,
  filename: string,
  options?: EsbuildTransformOptions,
  inMap?: object,
): Promise<ESBuildTransformResult>
```

通过 esbuild 转换 JavaScript 或 TypeScript 文件。对于更想要匹配 Vite 内部 esbuild 转换的插件很有用。

## `loadConfigFromFile`

**类型签名：**

```ts
async function loadConfigFromFile(
  configEnv: ConfigEnv,
  configFile?: string,
  configRoot: string = process.cwd(),
  logLevel?: LogLevel,
  customLogger?: Logger,
): Promise<{
  path: string
  config: UserConfig
  dependencies: string[]
} | null>
```

手动通过 esbuild 加载一份 Vite 配置。

## `preprocessCSS`

* **实验性：** [提供反馈](https://github.com/vitejs/vite/discussions/13815)

**类型签名：**

```ts
async function preprocessCSS(
  code: string,
  filename: string,
  config: ResolvedConfig,
): Promise<PreprocessCSSResult>

interface PreprocessCSSResult {
  code: string
  map?: SourceMapInput
  modules?: Record<string, string>
  deps?: Set<string>
}
```

预处理 `.css`、`.scss`、`.sass`、`.less`、`.styl` 和 `.stylus` 文件，将它们转化为纯 CSS，这样就可以在浏览器中使用或者被其他工具解析了。这和 [内置的 CSS 预处理器](/guide/features#css-pre-processors) 很像，如果你使用了这个功能，则必须安装相应的预处理器。

使用哪个预处理器是根据 `filename` 的扩展名来推断的。如果 `filename` 以 `.module.{ext}` 结尾，那么它就会被推断为 [CSS module](https://github.com/css-modules/css-modules)，返回的结果会包含一个 `modules` 对象，这个对象将原始的类名映射到转换后的类名。

需要注意的是，预处理不会解析 `url()` 或 `image-set()` 中的 URL。

---

---
url: /guide/rolldown.md
---
# Rolldown 集成 {#rolldown-integration}

Vite 计划将由 Rust 驱动的 JavaScript 打包工具 [Rolldown](https://rolldown.rs) 集成进来，以提升构建的性能和功能。

## Rolldown 是什么？ {#what-is-rolldown}

Rolldown 是一个现代化、高性能的 JavaScript 打包工具，由 Rust 编写。它被设计为 Rollup 的替代品，旨在保持与现有生态系统兼容的同时，显著提升性能。

Rolldown 专注于三个主要原则：

* **速度**：利用 Rust 的高性能进行构建
* **兼容性**：能够与现有的 Rollup 插件一起工作
* **优化**：拥有比 esbuild 和 Rollup 更先进的特性

## 为什么 Vite 要迁移到 Rolldown {#why-vite-is-migrating-to-rolldown}

1. **统一**：Vite 目前使用 esbuild 进行依赖预打包，使用 Rollup 进行生产构建。Rolldown 的目标是将这两个过程统一到一个高性能的打包工具中，以降低复杂性。

2. **性能**：Rolldown 的 Rust 实现在性能上比基于 JavaScript 的打包工具有显著的提升。虽然具体的基准测试可能会因项目大小和复杂性而有所不同，但早期测试表明，与 Rollup 相比，Rolldown 的速度有望得到提高。

3. **额外特性**：Rolldown 提供了 Rollup 或 esbuild 中没有的功能，例如高级的分块控制，内置的模块热替换（HMR），以及模块联邦（Module Federation）。

欲深入了解 Rolldown 的设计动机，请参阅[构建 Rolldown 的原因](https://rolldown.rs/guide/#why-rolldown)。

## 尝试 `rolldown-vite` 的好处 {#benefits-of-trying-rolldown-vite}

* 对于大型项目，可以显著提升构建速度
* 提供有价值的反馈，参与塑造 Vite 的未来打包体验
* 为最终的官方 Rolldown 集成做好准备

## 如何尝试 Rolldown {#how-to-try-rolldown}

基于 Rolldown 驱动的 Vite 目前以名为 `rolldown-vite` 的独立包提供。如果你的项目中直接依赖了 `vite`，可以在项目的 `package.json`文件里将 `vite` 包设置别名指向 `rolldown-vite`，这样就能实现无缝替换。

```json
{
  "dependencies": {
    "vite": "^6.0.0" // [!code --]
    "vite": "npm:rolldown-vite@latest" // [!code ++]
  }
}
```

如果你使用了 Vitepress 或其他以 Vite 作为同等依赖（peer dependency）的元框架，你需要在 `package.json` 文件中覆盖 `vite` 依赖，具体操作方式会因你使用的包管理器而略有不同。

:::code-group

```json [npm]
{
  "overrides": {
    "vite": "npm:rolldown-vite@latest"
  }
}
```

```json [Yarn]
{
  "resolutions": {
    "vite": "npm:rolldown-vite@latest"
  }
}
```

```json [pnpm]
{
  "pnpm": {
    "overrides": {
      "vite": "npm:rolldown-vite@latest"
    }
  }
}
```

```json [Bun]
{
  "overrides": {
    "vite": "npm:rolldown-vite@latest"
  }
}
```

:::

在添加 overrides 之后，重新安装你的依赖并像往常一样启动你的开发服务器或构建你的项目即可，无需进一步的配置更改。

## 已知限制 {#known-limitations}

虽然 Rolldown 的目标是成为 Rollup 的替代品，但还有一些特性正在实现中，以及一些小的有意的行为差异。需要查看完整的列表，请参考 [这个 GitHub PR](https://github.com/vitejs/rolldown-vite/pull/84#issue-2903144667)，它会定期更新。

### 验证选项错误 {#option-validation-errors}

当传入未知或无效选项时，Rolldown 会抛出错误。由于 Rolldown 不支持 Rollup 中的部分选项，根据您或所使用的元框架设置的选项，可能会遇到相关错误。下方展示了此类错误消息的示例：

> Error: Failed validate input options.
>
> * For the "preserveEntrySignatures". Invalid key: Expected never but received "preserveEntrySignatures".

如果你自己没有传递这个选项，这个问题必须由使用的框架来解决。你可以通过设置 `ROLLDOWN_OPTIONS_VALIDATION=loose` 环境变量来暂时忽略这个错误。

## 性能 {#performance}

`rolldown-vite` 主要致力于确保与现有生态系统的兼容性，因此其默认配置旨在实现平滑过渡。如果你切换到更快的基于 Rust 的内部插件或进行其他自定义配置，还可以获得进一步的性能提升。

## 启用原生插件 {#enabling-native-plugins}

感谢 Rolldown 和 Oxc，各种内部的 Vite 插件，如别名或解析插件，已被转换为 Rust。在撰写本文时，这些插件默认并未启用，因为它们的行为可能与 JavaScript 版本不同。

要测试它们，你可以在你的 Vite 配置中将 `experimental.enableNativePlugin` 选项设置为 `true`。

### `withFilter` 包装器 {#withfilter-wrapper}

插件作者可以选择使用 [钩子过滤功能](#hook-filter-feature)，以减少 Rust 和 JavaScript 运行时之间的通信开销。
但如果你使用的某些插件还未采用该功能，而你又希望受益于它，可以使用 `withFilter` 包装器自行为插件添加过滤条件。

```js
// 在你的 vite.config.ts 中
import { withFilter, defineConfig } from 'vite'
import svgr from 'vite-plugin-svgr'

export default defineConfig({
  plugins: [
    // 仅对以 `.svg?react` 结尾的文件加载 `svgr` 插件
    withFilter(
      svgr({
        /*...*/
      }),
      { load: { id: /\.svg?react$/ } },
    ),
  ],
})
```

## 反馈问题 {#reporting-issues}

由于这是一个实验性的集成，你可能会遇到一些问题。如果你遇到问题，请在 [`vitejs/rolldown-vite`](https://github.com/vitejs/rolldown-vite) 仓库中反馈，**而不是主 Vite 仓库**。

在 [上报问题](https://github.com/vitejs/rolldown-vite/issues/new) 时，请根据相应的问题模板进行操作，并提供模板中所需的信息，这通常包括：

* 问题的最小复现
* 你的环境详细信息（操作系统，Node 版本，包管理器）
* 任何相关的错误信息或日志

如果你想进行实时讨论和故障排除，请确保加入 [Rolldown Discord](https://chat.rolldown.rs/)。

## 版本管理策略 {#versioning-policy}

`rolldown-vite` 的版本管理策略与普通 Vite 包保持主版本号和次版本号的一致。这种同步确保了在某个特定的 Vite 次版本发布中包含的功能，也会出现在对应的 `rolldown-vite` 次版本发布中。但需要注意的是，补丁版本在两个项目之间并不同步。如果你想确认普通 Vite 包的某个具体变更是否已经包含在 `rolldown-vite` 中，可以随时查阅 [`rolldown-vite` 独立的更新日志](https://github.com/vitejs/rolldown-vite/blob/rolldown-vite/packages/vite/CHANGELOG.md) 以确认。

此外，请注意，`rolldown-vite` 本身仍处于实验阶段。由于其实验性质，即使在补丁版本中也可能引入破坏性变更。另外，`rolldown-vite` 仅对其最新的次版本进行更新。即使是重要的安全问题或 bug 修复，也不会为较早的主版本或次版本发布补丁。

## 未来计划 {#future-plans}

`rolldown-vite` 包是一个临时的解决方案，用于收集反馈和稳定 Rolldown 的集成。在未来，这个功能将被合并回主 Vite 仓库。

我们鼓励你尝试 `rolldown-vite` 并通过反馈和问题报告来参与其开发工作。

未来我们将为 Vite 引入全量打包模式（Full Bundle Mode），该模式将在生产环境 *和开发模式* 下提供打包后的文件。

### 为何引入全量打包模式？ {#why-introducing-full-bundle-mode}

Vite 以其非打包开发服务器方案著称，这正是其早期凭借速度优势迅速流行的关键原因。这种方案最初是尝试探索在不进行传统打包的情况下，开发服务器性能能达到何种极限。

但随着项目规模和复杂度的增长，两大挑战逐渐显现：

1. **开发/生产环境不一致性**：开发环境提供的非打包 JavaScript 与生产环境打包构建产物存在运行时行为差异，可能导致仅在生产环境暴露的问题，增加调试难度。

2. **开发阶段性能衰减**：非打包方案导致每个模块需单独请求，产生大量网络请求。虽然 *对生产环境无影响*，但会造成开发服务器启动和页面刷新时的显著开销。在大型应用中（需处理数百甚至数千独立请求）该问题尤为突出，若开发者使用网络代理，刷新延迟和开发体验下降将更加严重。

通过 Rolldown 的整合，我们有机会在保持 Vite 标志性性能的同时统一开发与生产体验。全量打包模式将实现：

* 大型应用仍保持快速启动
* 开发与生产环境行为一致性
* 降低页面刷新的网络开销
* 在 ESM 输出基础上维持高效 HMR

该模式初期将作为可选特性提供（类似 Rolldown 整合方案），我们计划在收集反馈并确保稳定性后将其设为默认模式。

## 插件/框架作者指南 {#plugin-framework-authors-guide}

::: tip
这部分内容主要是针对插件和框架的开发者。如果你是一般用户，你可以忽略这部分内容。
:::

### 主要变更概述 {#overview-of-major-changes}

* Rolldown 用于构建（之前使用 Rollup）
* Rolldown 用于 optimizer（之前使用 esbuild）
* Rolldown 处理 CommonJS 支持（之前使用 @rollup/plugin-commonjs）
* Oxc 用于语法降级（之前使用 esbuild）
* Lightning CSS 默认用于 CSS 压缩（之前使用 esbuild）
* Oxc minifier 默认用于 JS 压缩（之前使用 esbuild）
* Rolldown 用于打包配置（之前使用 esbuild）

### 检测 `rolldown-vite` {#detecting-rolldown-vite}

::: warning
在大多数情况下，你不需要检测你的插件是运行在 `rolldown-vite` 还是 `vite` 上，你应该在两者之间寻求一致的行为，而不是采用条件分支。
:::

如果你需要 `rolldown-vite` 有不同的行为，你有两种方法可以检测是否使用了 `rolldown-vite`：

检查 `this.meta.rolldownVersion` 的存在：

```js
const plugin = {
  resolveId() {
    if (this.meta.rolldownVersion) {
      // rolldown-vite 的逻辑
    } else {
      // rollup-vite 的逻辑
    }
  },
}
```

检查 `rolldownVersion` export 的存在：

```js
import * as vite from 'vite'

if (vite.rolldownVersion) {
  // rolldown-vite 的逻辑
} else {
  // rollup-vite 的逻辑
}
```

如果你将 `vite` 作为依赖项（dependency），而不是同等依赖（peer dependency），那么 `rolldownVersion` export 非常有用，因为它可以在你代码的任何地方使用。

### 在 Rolldown 中忽略选项验证 {#ignoring-option-validation-in-rolldown}

如 [前文所述](#option-validation-errors)，当传入未知或无效选项时，Rolldown 会抛出错误。

可通过条件式传递选项（通过 [如上所示](#detecting-rolldown-vite) 检测是否使用 `rolldown-vite`）来修复此问题。

在此场景中，设置环境变量 `ROLLDOWN_OPTIONS_VALIDATION=loose` 亦可抑制错误。
但需注意，**最终仍需停止传递 Rolldown 不支持的选项**。

### `transformWithEsbuild` 需要单独安装 `esbuild` {#transformwithesbuild-requires-installing-esbuild-separately}

一个类似的函数，名为 `transformWithOxc`，它使用 Oxc 而非 `esbuild`，从 `rolldown-vite` 中导出。

### `esbuild` 选项的兼容层 {#compatibility-layer-for-esbuild-options}

Rolldown-Vite 有一个兼容层，用于将 `esbuild` 的选项转换为相应的 Oxc 或 `rolldown` 选项。正如 [生态系统 CI](https://github.com/vitejs/vite-ecosystem-ci/blob/rolldown-vite/README-temp.md) 中测试的那样，这在许多情况，包括简单的 `esbuild` 插件下都有效。
虽说如此，但 **我们将在未来移除对 `esbuild` 选项的支持**，并鼓励你尝试使用相应的 Oxc 或 `rolldown` 选项。
你可以从 `configResolved` 钩子获取由兼容层设置的选项。

```js
const plugin = {
  name: 'log-config',
  configResolved(config) {
    console.log('options', config.optimizeDeps, config.oxc)
  },
},
```

### 钩子过滤功能 {#hook-filter-feature}

Rolldown 引入了[钩子过滤功能](https://rolldown.rs/guide/plugin-development#plugin-hook-filters)，以减少 Rust 和 JavaScript 运行时之间的通信开销。通过使用此功能，你可以使你的插件性能更高。
这也在 Rollup 4.38.0+ 和 Vite 6.3.0+ 被支持。为了使你的插件向后兼容较旧的版本，请确保也在钩子处理程序内运行过滤器。

### 在 `load` 或 `transform` 钩子中将内容转换为 JavaScript {#converting-content-to-javascript-in-load-or-transform-hooks}

如果你在 `load` 或 `transform` 钩子中将内容转换为 JavaScript，你可能需要添加 `moduleType: 'js'` 到返回值中。

```js
const plugin = {
  name: 'txt-loader',
  load(id) {
    if (id.endsWith('.txt')) {
      const content = fs.readFile(id, 'utf-8')
      return {
        code: `export default ${JSON.stringify(content)}`,
        moduleType: 'js', // [!code ++]
      }
    }
  },
}
```

这是因为 [Rolldown 支持非 JavaScript 模块](https://rolldown.rs/guide/in-depth/module-types) 并且除非指定，否则从扩展名推断模块类型。注意 `rolldown-vite` 不支持开发中的 ModuleTypes。

---

---
url: /config/ssr-options.md
---
# SSR 选项 {#ssr-options}

除非另有说明，本节中的选项适用于开发和构建。

## ssr.external

* **类型:** `string[] | true`
* **相关：** [SSR 外部化](/guide/ssr#ssr-externals)

这个选项可以将指定的依赖项和它们传递的依赖项进行外部化，以供服务端渲染（SSR）使用。默认情况下，所有的依赖项都会被外部化，除了那些被链接的依赖项（为了HMR）。如果希望将这些软链接的依赖项也外部化，你可以将其名称传给这个选项。

如果这个选项设置为 `true`，那么所有的依赖项，包括被链接的依赖项，都将被外部化。

需要注意的是，如果在该选项明确列出了一些依赖项（使用 `string[]` 类型），那么其将始终被优先考虑，即使它们也在 `ssr.noExternal` 中被列出（无论使用何种类型）。

## ssr.noExternal {#ssr-noexternal}

* **类型：** `string | RegExp | (string | RegExp)[] | true`
* **相关：** [SSR 外部化](/guide/ssr#ssr-externals)

这个选项可以防止列出的依赖项在服务端渲染（SSR）时被外部化，这些依赖项将会在构建过程中被打包。默认情况下，只有软链接的依赖项不会被外部化（这是为了HMR）。如果你希望将软链接的依赖项也外部化，可以将其名称传给 `ssr.external` 选项。

如果这个选项设置为 `true`，那么没有任何依赖项会被外部化。然而，如果你在 `ssr.external` 中明确列出了一些依赖项（使用 `string[]` 类型），那么这些依赖项可以优先被外部化。如果设置了 `ssr.target: 'node'`，那么 Node.js 的内置模块也会被默认外部化。

需要注意的是，如果 `ssr.noExternal: true` 和 `ssr.external: true` 都被设置了，那么 `ssr.noExternal` 将优先生效，没有任何依赖项会被外部化。

## ssr.target

* **类型：** `'node' | 'webworker'`
* **默认：** `node`

SSR 服务器的构建目标。

## ssr.resolve.conditions {#ssr-resolve-conditions}

* **类型：** `string[]`
* **默认：** `['module', 'node', 'development|production']`(`defaultServerConditions`) (当 `ssr.target === 'webworker'` 时为 `['module', 'browser', 'development|production']` (`defaultClientConditions`) )
* **相关：** [解析情景](./shared-options.md#resolve-conditions)

这些条件会在插件管道中使用，并且只会影响 SSR 构建期间的非外部化依赖项。使用 `ssr.resolve.externalConditions` 来影响外部化导入。

## ssr.resolve.externalConditions {#ssr-resolve-externalconditions}

* **类型：** `string[]`
* **默认：** `['node']`

在对外部化的直接依赖项（由 Vite 导入的外部依赖项）进行 SSR 导入（包括 `ssrLoadModule`）期间所使用的条件。

:::tip

使用该选项时，请确保在开发和构建中使用 [`--conditions` flag](https://nodejs.org/docs/latest/api/cli.html#-c-condition---conditionscondition) 以相同的值运行 Node，以获得一致的行为。

例如，当设置 `['node', 'custom']` 时，应该在 dev 中运行 `NODE_OPTIONS='--conditions custom' vite`，在 build 后运行 `NODE_OPTIONS="--conditions custom" node ./dist/server.js`。

:::

### ssr.resolve.mainFields

* **类型：** `string[]`
* **默认：** `['module', 'jsnext:main', 'jsnext']`

在解析一个包的入口文件时，会尝试使用 `package.json` 中的字段列表。请注意，这些字段的优先级低于从条件导出解析的 `exports` 字段：如果能从 `exports` 字段成功解析出入口文件，那么 main 字段将会被忽略。此设置仅影响未外部化的依赖项。

---

---
url: /README.md
---
> ### 敬请所有读者注意
>
> * 原则上这里只进行英文版对应的翻译工作，如果觉得原文有改进之处，或任何不仅针对中文版，而受益所有语言版本的想法，建议直接在英文版仓库讨论。
> * **原则上这里不适合讨论 Vite 的使用问题**，建议相关问题在 Vite 的 [issues 区](https://github.com/vitejs/vite/issues)、[Vite 官方讨论区](https://chat.vite.dev/) 或各大主流技术社区讨论，以便得到更多帮助和更充分的讨论。

# Vite 中文文档

> Vite：下一代前端开发与构建工具

* 💡 极速的开发服务器启动
* ⚡️ 轻量快速的模块热替换（HMR）
* 🛠️ 丰富的功能
* 📦 自带优化的构建
* 🔩 通用的插件接口
* 🔑 完全类型化的 API

Vite （法语意为 “迅速”，发音 /vit/）是一种全新的前端构建工具，它极大地改善了前端开发体验。

## 📝 如何参与贡献

目前 Vite 中文文档处于 v6 版本，内容 **每日** 根据英文文档同步更新。

**工作流介绍：** 英文文档的所在 [请点击此链接](https://github.com/vitejs/vite/tree/main/docs)，我们会每天拉取英文版文档内容的更新到 sync-docs 分支，并由印记中文 bot 自动发起 Pull Request，解决 Git 冲突并翻译内容。

贡献指南敬请查看本仓库的 [Wiki](https://github.com/vitejs/docs-cn/wiki) 区。

## 📥 如何开始编辑

```bash
# 克隆本仓库
$ git clone https://github.com/vitejs/docs-cn.git

# 安装依赖
$ npm install
# 或者使用 pnpm
$ pnpm i

# 启动开发服务器
$ pnpm dev
```

## 版权声明

本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议  (CC BY-NC-SA 4.0) 进行许可。

## 贡献者统计

> 统计规则：所有通过 Pull Request 产生了对 `main` 分支 commit 的贡献者。
>
> 头像图生成逻辑参见：[github-contributor-svg-generator](https://github.com/ShenQingchuan/github-contributor-svg-generator)

---

---
url: /guide/api-vite-runtime.md
---
# Vite Runtime API {#vite-runtime-api}

:::warning 底层 API
这个 API 在 Vite 5.1 中作为一个实验性特性引入。它被添加以 [收集反馈](https://github.com/vitejs/vite/discussions/15774)。在Vite 5.2 中，它可能会有破坏性的变化，所以在使用它时，请确保将 Vite 版本固定在 `~5.1.0`。这是一个面向库和框架作者的底层 API。如果你的目标是开发应用，请确保首先查看 [Vite SSR 精选板块](https://github.com/vitejs/awesome-vite#ssr) 的高级 SSR 插件和工具。

目前，这种 API 正在以 [环境 API](https://github.com/vitejs/vite/discussions/16358) 的形式进行修正，并在 `^6.0.0-alpha.0` 版本中发布。
:::

"Vite 运行时" 是一个工具，它允许首先用 Vite 插件处理任何代码后运行。它与 `server.ssrLoadModule` 不同，因为运行时实现是从服务器解耦的。这允许库和框架作者实现他们自己的服务器和运行时之间的通信层。

这个特性的一个目标是提供一个可定制的API来处理和运行代码。Vite 提供了足够的工具来开箱即用 Vite 运行时，但如果用户的需求与 Vite 的内置实现不一致，他们可以在其基础上进行构建。

除非另有说明，所有API都可以从 `vite/runtime` 导入。

## `ViteRuntime`

**类型签名：**

```ts
export class ViteRuntime {
  constructor(
    public options: ViteRuntimeOptions,
    public runner: ViteModuleRunner,
    private debug?: ViteRuntimeDebugger,
  ) {}
  /**
   * 要执行的 URL。可以是文件路径、服务器路径，或者是相对于根目录的 id。
   */
  public async executeUrl<T = any>(url: string): Promise<T>
  /**
   * 执行的入口文件 URL。可以是文件路径、服务器路径，或者是相对于根目录的 id。
   * 如果是由 HMR 触发的全面重载，那么这就是将要被重载的模块。
   * 如果这个方法被多次调用，所有的入口文件都将逐一被重新加载。
   */
  public async executeEntrypoint<T = any>(url: string): Promise<T>
  /**
   * 清除所有缓存，包括 HMR 监听器。
   */
  public clearCache(): void
  /**
   * 清除所有缓存，移除所有 HMR 监听器，并重置 sourcemap 支持。
   * 此方法不会停止 HMR 连接。
   */
  public async destroy(): Promise<void>
  /**
   * 如果通过调用 `destroy()` 方法销毁了运行时，则返回 `true`。
   */
  public isDestroyed(): boolean
}
```

::: tip 进阶用法
如果你是从 `server.ssrLoadModule` 迁移过来，并且想要支持模块热替换（HMR），你可以考虑用 [`createViteRuntime`](#createviteruntime) 替代。
:::

当你初始化 `ViteRuntime` 类时，需要 `root` 和 `fetchModule` 这两个选项。Vite 在 [`server`](/guide/api-javascript) 实例中公开了 `ssrFetchModule`，以便更方便地与 Vite SSR 集成。Vite 主入口也导出了 `fetchModule` - 它不会假设代码的运行方式，这与期望代码通过 `new Function` 运行的 `ssrFetchModule` 是不同的，这一点可以从这些函数返回的 sourcemap 中看出。

`ViteRuntime` 中的 Runner 负责执行代码。Vite 开箱即用地提供了 `ESModulesRunner`，它使用 `new AsyncFunction` 来运行代码。如果你的 JavaScript 运行环境不支持不安全的执行，你可以提供你自己的实现。

运行时公开的两个主要方法是 `executeUrl` 和 `executeEntrypoint`。它们之间唯一的区别是，如果模块热替换（HMR）触发了 `full-reload` 事件，那么 `executeEntrypoint` 执行的所有模块都将重新执行。但请注意，当这种情况发生时，Vite 运行时不会更新 `exports` 对象（它会被覆盖），如果你需要最新的 `exports` 对象，你需要重新运行 `executeUrl` 或从 `moduleCache` 再次获取模块。

**使用示例：**

```js
import { ViteRuntime, ESModulesRunner } from 'vite/runtime'
import { root, fetchModule } from './rpc-implementation.js'

const runtime = new ViteRuntime(
  {
    root,
    fetchModule,
    // 你也可以提供 hmr.connection 以支持 HMR。
  },
  new ESModulesRunner(),
)

await runtime.executeEntrypoint('/src/entry-point.js')
```

## `ViteRuntimeOptions`

```ts
export interface ViteRuntimeOptions {
  /**
   * 项目根目录
   */
  root: string
  /**
   * 获取模块信息的方法
   * 对于 SSR，Vite 提供了你可以使用的 `server.ssrFetchModule` 函数。
   * 对于其他运行时用例，Vite 也从其主入口点提供了 `fetchModule`。
   */
  fetchModule: FetchFunction
  /**
   * 配置 sourcemap 的解析方式。如果 `process.setSourceMapsEnabled` 可用，优先选择 `node`。
   * 否则，默认使用 `prepareStackTrace`，这会覆盖 `Error.prepareStackTrace` 方法。
   * 你可以提供一个对象来配置如何解析那些没有被 Vite 处理过的文件的内容和源代码映射。
   */
  sourcemapInterceptor?:
    | false
    | 'node'
    | 'prepareStackTrace'
    | InterceptorOptions
  /**
   * 禁用 HMR 或配置 HMR 选项。
   */
  hmr?:
    | false
    | {
        /**
         * 配置 HMR 如何在客户端和服务器之间通信。
         */
        connection: HMRRuntimeConnection
        /**
         * 配置 HMR 日志。
         */
        logger?: false | HMRLogger
      }
  /**
   * 自定义模块缓存。如果未提供，它将为每个 Vite 运行环境实例创建一个独立的模块缓存。
   */
  moduleCache?: ModuleCacheMap
}
```

## `ViteModuleRunner`

**类型签名：**

```ts
export interface ViteModuleRunner {
  /**
   * 运行被 Vite 转换过的代码。
   * @param context Function context
   * @param code Transformed code
   * @param id ID that was used to fetch the module
   */
  runViteModule(
    context: ViteRuntimeModuleContext,
    code: string,
    id: string,
  ): Promise<any>
  /**
   * 运行已外部化的模块。
   * @param file File URL to the external module
   */
  runExternalModule(file: string): Promise<any>
}
```

Vite 默认导出了实现了这个接口的 `ESModulesRunner`。它使用 `new AsyncFunction` 来执行代码，所以如果代码中有内联的源代码映射（sourcemap），它应该包含 [2行的偏移](https://tc39.es/ecma262/#sec-createdynamicfunction) 以适应新添加的行。这是由 `server.ssrFetchModule` 自动完成的。如果你的 runner 实现没有这个限制，你应该直接使用 `fetchModule`（从 `vite` 导出）。

## HMRRuntimeConnection

**类型签名：**

```ts
export interface HMRRuntimeConnection {
  /**
   * 在向客户端发送消息之前进行检查
   */
  isReady(): boolean
  /**
   * 向客户端发送消息
   */
  send(message: string): void
  /**
   * 配置当此连接触发更新时如何处理 HMR。
   * 此方法期望连接将开始监听 HMR 更新，并在接收到时调用此回调。
   */
  onUpdate(callback: (payload: HMRPayload) => void): void
}
```

这个接口定义了如何建立模块热替换（HMR）的通信。Vite 从主入口处导出 `ServerHMRConnector`，以在 Vite SSR 期间支持 HMR。当自定义事件被触发时（例如，`import.meta.hot.send("my-event")`），通常会调用 `isReady` 和 `send` 方法。

只有在新的运行环境启动时，才会调用 `onUpdate`。它传递下来一个在连接触发 HMR 事件时应该调用的方法。实现方式取决于连接的类型（例如，它可以是 `WebSocket`/`EventEmitter`/`MessageChannel`），但通常看起来像这样：

```js
function onUpdate(callback) {
  this.connection.on('hmr', (event) => callback(event.data))
}
```

回调会被放入队列中，它会等待当前的更新完成后才处理下一个更新。与浏览器的实现不同，Vite 运行环境中的 HMR 更新会等到所有的监听器（例如，`vite:beforeUpdate`/`vite:beforeFullReload`）都完成后才更新模块。

## `createViteRuntime`

**类型签名：**

```ts
async function createViteRuntime(
  server: ViteDevServer,
  options?: MainThreadRuntimeOptions,
): Promise<ViteRuntime>
```

**使用示例：**

```js
import { createServer } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

;(async () => {
  const server = await createServer({
    root: __dirname,
  })
  await server.listen()

  const runtime = await createViteRuntime(server)
  await runtime.executeEntrypoint('/src/entry-point.js')
})()
```

这个方法可以作为 `server.ssrLoadModule` 的简单替代。不同于 `ssrLoadModule`，`createViteRuntime` 默认就支持 HMR。你可以传递 [`options`](#mainthreadruntimeoptions) 来定制 SSR 运行环境的行为，以满足你的需求。

## `MainThreadRuntimeOptions`

```ts
export interface MainThreadRuntimeOptions
  extends Omit<ViteRuntimeOptions, 'root' | 'fetchModule' | 'hmr'> {
  /**
   * 禁用 HMR 或配置 HMR 日志。
   */
  hmr?:
    | false
    | {
        logger?: false | HMRLogger
      }
  /**
   * 提供自定义模块运行器。这决定了代码的执行方式。
   */
  runner?: ViteModuleRunner
}
```

---

---
url: /config/worker-options.md
---
# Worker 选项 {#worker-options}

除非另有说明，本节中的选项适用于所有开发、构建和预览。

## worker.format

* **类型：** `'es' | 'iife'`
* **默认：** `'iife'`

worker 打包时的输出类型。

## worker.plugins

* **类型：** [`() => (Plugin | Plugin[])[]`](./shared-options#plugins)

应用于 worker 打包的 Vite 插件。注意 [config.plugins](./shared-options#plugins) 仅会在开发（dev）阶段应用于 worker，若要配置在构建（build）阶段应用于 worker 的插件则应该在本选项这里配置。
该函数应返回新的插件实例，因为它们在并行的 rollup worker 构建中使用。因此，在 `config` 钩子中修改 `config.worker` 选项将被忽略。

## worker.rollupOptions

* **类型：** [`RollupOptions`](https://cn.rollupjs.org/configuration-options/)

用于打包 worker 的 Rollup 配置项。
